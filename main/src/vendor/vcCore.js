var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/rdf-canonize/lib/IdentifierIssuer.js
var require_IdentifierIssuer = __commonJS((exports, module) => {
  module.exports = class IdentifierIssuer {
    constructor(prefix, existing = new Map, counter = 0) {
      this.prefix = prefix;
      this._existing = existing;
      this.counter = counter;
    }
    clone() {
      const { prefix, _existing, counter } = this;
      return new IdentifierIssuer(prefix, new Map(_existing), counter);
    }
    getId(old) {
      const existing = old && this._existing.get(old);
      if (existing) {
        return existing;
      }
      const identifier = this.prefix + this.counter;
      this.counter++;
      if (old) {
        this._existing.set(old, identifier);
      }
      return identifier;
    }
    hasId(old) {
      return this._existing.has(old);
    }
    getOldIds() {
      return [...this._existing.keys()];
    }
  };
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/rdf-canonize/lib/MessageDigest-browser.js
var require_MessageDigest_browser = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  require_setImmediate();
  var crypto2 = self.crypto || self.msCrypto;
  module.exports = class MessageDigest {
    constructor(algorithm) {
      if (!(crypto2 && crypto2.subtle)) {
        throw new Error("crypto.subtle not found.");
      }
      if (algorithm === "sha256") {
        this.algorithm = { name: "SHA-256" };
      } else if (algorithm === "sha1") {
        this.algorithm = { name: "SHA-1" };
      } else {
        throw new Error(`Unsupported algorithm "${algorithm}".`);
      }
      this._content = "";
    }
    update(msg) {
      this._content += msg;
    }
    async digest() {
      const data = new TextEncoder().encode(this._content);
      const buffer = new Uint8Array(await crypto2.subtle.digest(this.algorithm, data));
      let hex = "";
      for (let i = 0;i < buffer.length; ++i) {
        hex += buffer[i].toString(16).padStart(2, "0");
      }
      return hex;
    }
  };
});

// node_modules/rdf-canonize/lib/Permuter.js
var require_Permuter = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = class Permuter {
    constructor(list) {
      this.current = list.sort();
      this.done = false;
      this.dir = new Map;
      for (let i = 0;i < list.length; ++i) {
        this.dir.set(list[i], true);
      }
    }
    hasNext() {
      return !this.done;
    }
    next() {
      const { current, dir } = this;
      const rval = current.slice();
      let k = null;
      let pos = 0;
      const length = current.length;
      for (let i = 0;i < length; ++i) {
        const element = current[i];
        const left = dir.get(element);
        if ((k === null || element > k) && (left && i > 0 && element > current[i - 1] || !left && i < length - 1 && element > current[i + 1])) {
          k = element;
          pos = i;
        }
      }
      if (k === null) {
        this.done = true;
      } else {
        const swap = dir.get(k) ? pos - 1 : pos + 1;
        current[pos] = current[swap];
        current[swap] = k;
        for (const element of current) {
          if (element > k) {
            dir.set(element, !dir.get(element));
          }
        }
      }
      return rval;
    }
  };
});

// node_modules/rdf-canonize/lib/NQuads.js
var require_NQuads = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  var RDF_LANGSTRING = RDF + "langString";
  var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
  var TYPE_NAMED_NODE = "NamedNode";
  var TYPE_BLANK_NODE = "BlankNode";
  var TYPE_LITERAL = "Literal";
  var TYPE_DEFAULT_GRAPH = "DefaultGraph";
  var REGEX = {};
  (() => {
    const iri = "(?:<([^:]+:[^>]*)>)";
    const PN_CHARS_BASE = "A-Z" + "a-z" + "À-Ö" + "Ø-ö" + "ø-˿" + "Ͱ-ͽ" + "Ϳ-῿" + "‌-‍" + "⁰-↏" + "Ⰰ-⿯" + "、-퟿" + "豈-﷏" + "ﷰ-�";
    const PN_CHARS_U = PN_CHARS_BASE + "_";
    const PN_CHARS = PN_CHARS_U + "0-9" + "-" + "·" + "̀-ͯ" + "‿-⁀";
    const BLANK_NODE_LABEL = "(_:" + "(?:[" + PN_CHARS_U + "0-9])" + "(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?" + ")";
    const bnode = BLANK_NODE_LABEL;
    const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
    const datatype = "(?:\\^\\^" + iri + ")";
    const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
    const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
    const ws = "[ \\t]+";
    const wso = "[ \\t]*";
    const subject = "(?:" + iri + "|" + bnode + ")" + ws;
    const property = iri + ws;
    const object = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
    const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
    REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
    REGEX.empty = new RegExp("^" + wso + "$");
    REGEX.quad = new RegExp("^" + wso + subject + property + object + graphName + wso + "$");
  })();
  module.exports = class NQuads {
    static parse(input) {
      const dataset = [];
      const graphs = {};
      const lines = input.split(REGEX.eoln);
      let lineNumber = 0;
      for (const line of lines) {
        lineNumber++;
        if (REGEX.empty.test(line)) {
          continue;
        }
        const match = line.match(REGEX.quad);
        if (match === null) {
          throw new Error("N-Quads parse error on line " + lineNumber + ".");
        }
        const quad = { subject: null, predicate: null, object: null, graph: null };
        if (match[1] !== undefined) {
          quad.subject = { termType: TYPE_NAMED_NODE, value: match[1] };
        } else {
          quad.subject = { termType: TYPE_BLANK_NODE, value: match[2] };
        }
        quad.predicate = { termType: TYPE_NAMED_NODE, value: match[3] };
        if (match[4] !== undefined) {
          quad.object = { termType: TYPE_NAMED_NODE, value: match[4] };
        } else if (match[5] !== undefined) {
          quad.object = { termType: TYPE_BLANK_NODE, value: match[5] };
        } else {
          quad.object = {
            termType: TYPE_LITERAL,
            value: undefined,
            datatype: {
              termType: TYPE_NAMED_NODE
            }
          };
          if (match[7] !== undefined) {
            quad.object.datatype.value = match[7];
          } else if (match[8] !== undefined) {
            quad.object.datatype.value = RDF_LANGSTRING;
            quad.object.language = match[8];
          } else {
            quad.object.datatype.value = XSD_STRING;
          }
          quad.object.value = _unescape(match[6]);
        }
        if (match[9] !== undefined) {
          quad.graph = {
            termType: TYPE_NAMED_NODE,
            value: match[9]
          };
        } else if (match[10] !== undefined) {
          quad.graph = {
            termType: TYPE_BLANK_NODE,
            value: match[10]
          };
        } else {
          quad.graph = {
            termType: TYPE_DEFAULT_GRAPH,
            value: ""
          };
        }
        if (!(quad.graph.value in graphs)) {
          graphs[quad.graph.value] = [quad];
          dataset.push(quad);
        } else {
          let unique = true;
          const quads = graphs[quad.graph.value];
          for (const q of quads) {
            if (_compareTriples(q, quad)) {
              unique = false;
              break;
            }
          }
          if (unique) {
            quads.push(quad);
            dataset.push(quad);
          }
        }
      }
      return dataset;
    }
    static serialize(dataset) {
      if (!Array.isArray(dataset)) {
        dataset = NQuads.legacyDatasetToQuads(dataset);
      }
      const quads = [];
      for (const quad of dataset) {
        quads.push(NQuads.serializeQuad(quad));
      }
      return quads.sort().join("");
    }
    static serializeQuadComponents(s, p, o, g) {
      let nquad = "";
      if (s.termType === TYPE_NAMED_NODE) {
        nquad += `<${s.value}>`;
      } else {
        nquad += `${s.value}`;
      }
      nquad += ` <${p.value}> `;
      if (o.termType === TYPE_NAMED_NODE) {
        nquad += `<${o.value}>`;
      } else if (o.termType === TYPE_BLANK_NODE) {
        nquad += o.value;
      } else {
        nquad += `"${_escape(o.value)}"`;
        if (o.datatype.value === RDF_LANGSTRING) {
          if (o.language) {
            nquad += `@${o.language}`;
          }
        } else if (o.datatype.value !== XSD_STRING) {
          nquad += `^^<${o.datatype.value}>`;
        }
      }
      if (g.termType === TYPE_NAMED_NODE) {
        nquad += ` <${g.value}>`;
      } else if (g.termType === TYPE_BLANK_NODE) {
        nquad += ` ${g.value}`;
      }
      nquad += ` .
`;
      return nquad;
    }
    static serializeQuad(quad) {
      return NQuads.serializeQuadComponents(quad.subject, quad.predicate, quad.object, quad.graph);
    }
    static legacyDatasetToQuads(dataset) {
      const quads = [];
      const termTypeMap = {
        "blank node": TYPE_BLANK_NODE,
        IRI: TYPE_NAMED_NODE,
        literal: TYPE_LITERAL
      };
      for (const graphName in dataset) {
        const triples = dataset[graphName];
        triples.forEach((triple) => {
          const quad = {};
          for (const componentName in triple) {
            const oldComponent = triple[componentName];
            const newComponent = {
              termType: termTypeMap[oldComponent.type],
              value: oldComponent.value
            };
            if (newComponent.termType === TYPE_LITERAL) {
              newComponent.datatype = {
                termType: TYPE_NAMED_NODE
              };
              if ("datatype" in oldComponent) {
                newComponent.datatype.value = oldComponent.datatype;
              }
              if ("language" in oldComponent) {
                if (!("datatype" in oldComponent)) {
                  newComponent.datatype.value = RDF_LANGSTRING;
                }
                newComponent.language = oldComponent.language;
              } else if (!("datatype" in oldComponent)) {
                newComponent.datatype.value = XSD_STRING;
              }
            }
            quad[componentName] = newComponent;
          }
          if (graphName === "@default") {
            quad.graph = {
              termType: TYPE_DEFAULT_GRAPH,
              value: ""
            };
          } else {
            quad.graph = {
              termType: graphName.startsWith("_:") ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,
              value: graphName
            };
          }
          quads.push(quad);
        });
      }
      return quads;
    }
  };
  function _compareTriples(t1, t2) {
    if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {
      return false;
    }
    if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {
      return false;
    }
    if (t1.object.termType !== TYPE_LITERAL) {
      return true;
    }
    return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;
  }
  var _escapeRegex = /["\\\n\r]/g;
  function _escape(s) {
    return s.replace(_escapeRegex, function(match) {
      switch (match) {
        case '"':
          return "\\\"";
        case "\\":
          return "\\\\";
        case `
`:
          return "\\n";
        case "\r":
          return "\\r";
      }
    });
  }
  var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
  function _unescape(s) {
    return s.replace(_unescapeRegex, function(match, code, u, U) {
      if (code) {
        switch (code) {
          case "t":
            return "\t";
          case "b":
            return "\b";
          case "n":
            return `
`;
          case "r":
            return "\r";
          case "f":
            return "\f";
          case '"':
            return '"';
          case "'":
            return "'";
          case "\\":
            return "\\";
        }
      }
      if (u) {
        return String.fromCharCode(parseInt(u, 16));
      }
      if (U) {
        throw new Error("Unsupported U escape");
      }
    });
  }
});

// node_modules/rdf-canonize/lib/URDNA2015.js
var require_URDNA2015 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var IdentifierIssuer = require_IdentifierIssuer();
  var MessageDigest = require_MessageDigest_browser();
  var Permuter = require_Permuter();
  var NQuads = require_NQuads();
  module.exports = class URDNA2015 {
    constructor({
      createMessageDigest = () => new MessageDigest("sha256"),
      canonicalIdMap = new Map,
      maxDeepIterations = Infinity
    } = {}) {
      this.name = "URDNA2015";
      this.blankNodeInfo = new Map;
      this.canonicalIssuer = new IdentifierIssuer("_:c14n", canonicalIdMap);
      this.createMessageDigest = createMessageDigest;
      this.maxDeepIterations = maxDeepIterations;
      this.quads = null;
      this.deepIterations = null;
    }
    async main(dataset) {
      this.deepIterations = new Map;
      this.quads = dataset;
      for (const quad of dataset) {
        this._addBlankNodeQuadInfo({ quad, component: quad.subject });
        this._addBlankNodeQuadInfo({ quad, component: quad.object });
        this._addBlankNodeQuadInfo({ quad, component: quad.graph });
      }
      const hashToBlankNodes = new Map;
      const nonNormalized = [...this.blankNodeInfo.keys()];
      let i = 0;
      for (const id of nonNormalized) {
        if (++i % 100 === 0) {
          await this._yield();
        }
        await this._hashAndTrackBlankNode({ id, hashToBlankNodes });
      }
      const hashes = [...hashToBlankNodes.keys()].sort();
      const nonUnique = [];
      for (const hash of hashes) {
        const idList = hashToBlankNodes.get(hash);
        if (idList.length > 1) {
          nonUnique.push(idList);
          continue;
        }
        const id = idList[0];
        this.canonicalIssuer.getId(id);
      }
      for (const idList of nonUnique) {
        const hashPathList = [];
        for (const id of idList) {
          if (this.canonicalIssuer.hasId(id)) {
            continue;
          }
          const issuer = new IdentifierIssuer("_:b");
          issuer.getId(id);
          const result = await this.hashNDegreeQuads(id, issuer);
          hashPathList.push(result);
        }
        hashPathList.sort(_stringHashCompare);
        for (const result of hashPathList) {
          const oldIds = result.issuer.getOldIds();
          for (const id of oldIds) {
            this.canonicalIssuer.getId(id);
          }
        }
      }
      const normalized = [];
      for (const quad of this.quads) {
        const nQuad = NQuads.serializeQuadComponents(this._componentWithCanonicalId(quad.subject), quad.predicate, this._componentWithCanonicalId(quad.object), this._componentWithCanonicalId(quad.graph));
        normalized.push(nQuad);
      }
      normalized.sort();
      return normalized.join("");
    }
    async hashFirstDegreeQuads(id) {
      const nquads = [];
      const info = this.blankNodeInfo.get(id);
      const quads = info.quads;
      for (const quad of quads) {
        const copy = {
          subject: null,
          predicate: quad.predicate,
          object: null,
          graph: null
        };
        copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, "subject");
        copy.object = this.modifyFirstDegreeComponent(id, quad.object, "object");
        copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, "graph");
        nquads.push(NQuads.serializeQuad(copy));
      }
      nquads.sort();
      const md = this.createMessageDigest();
      for (const nquad of nquads) {
        md.update(nquad);
      }
      info.hash = await md.digest();
      return info.hash;
    }
    async hashRelatedBlankNode(related, quad, issuer, position) {
      let id;
      if (this.canonicalIssuer.hasId(related)) {
        id = this.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id = issuer.getId(related);
      } else {
        id = this.blankNodeInfo.get(related).hash;
      }
      const md = this.createMessageDigest();
      md.update(position);
      if (position !== "g") {
        md.update(this.getRelatedPredicate(quad));
      }
      md.update(id);
      return md.digest();
    }
    async hashNDegreeQuads(id, issuer) {
      const deepIterations = this.deepIterations.get(id) || 0;
      if (deepIterations > this.maxDeepIterations) {
        throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
      }
      this.deepIterations.set(id, deepIterations + 1);
      const md = this.createMessageDigest();
      const hashToRelated = await this.createHashToRelated(id, issuer);
      const hashes = [...hashToRelated.keys()].sort();
      for (const hash of hashes) {
        md.update(hash);
        let chosenPath = "";
        let chosenIssuer;
        const permuter = new Permuter(hashToRelated.get(hash));
        let i = 0;
        while (permuter.hasNext()) {
          const permutation = permuter.next();
          if (++i % 3 === 0) {
            await this._yield();
          }
          let issuerCopy = issuer.clone();
          let path = "";
          const recursionList = [];
          let nextPermutation = false;
          for (const related of permutation) {
            if (this.canonicalIssuer.hasId(related)) {
              path += this.canonicalIssuer.getId(related);
            } else {
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              }
              path += issuerCopy.getId(related);
            }
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          for (const related of recursionList) {
            const result = await this.hashNDegreeQuads(related, issuerCopy);
            path += issuerCopy.getId(related);
            path += `<${result.hash}>`;
            issuerCopy = result.issuer;
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        }
        md.update(chosenPath);
        issuer = chosenIssuer;
      }
      return { hash: await md.digest(), issuer };
    }
    modifyFirstDegreeComponent(id, component) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      return {
        termType: "BlankNode",
        value: component.value === id ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return `<${quad.predicate.value}>`;
    }
    async createHashToRelated(id, issuer) {
      const hashToRelated = new Map;
      const quads = this.blankNodeInfo.get(id).quads;
      let i = 0;
      for (const quad of quads) {
        if (++i % 100 === 0) {
          await this._yield();
        }
        await Promise.all([
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.subject,
            position: "s",
            id,
            issuer,
            hashToRelated
          }),
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.object,
            position: "o",
            id,
            issuer,
            hashToRelated
          }),
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.graph,
            position: "g",
            id,
            issuer,
            hashToRelated
          })
        ]);
      }
      return hashToRelated;
    }
    async _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
      const hash = await this.hashFirstDegreeQuads(id);
      const idList = hashToBlankNodes.get(hash);
      if (!idList) {
        hashToBlankNodes.set(hash, [id]);
      } else {
        idList.push(id);
      }
    }
    _addBlankNodeQuadInfo({ quad, component }) {
      if (component.termType !== "BlankNode") {
        return;
      }
      const id = component.value;
      const info = this.blankNodeInfo.get(id);
      if (info) {
        info.quads.add(quad);
      } else {
        this.blankNodeInfo.set(id, { quads: new Set([quad]), hash: null });
      }
    }
    async _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
      if (!(component.termType === "BlankNode" && component.value !== id)) {
        return;
      }
      const related = component.value;
      const hash = await this.hashRelatedBlankNode(related, quad, issuer, position);
      const entries = hashToRelated.get(hash);
      if (entries) {
        entries.push(related);
      } else {
        hashToRelated.set(hash, [related]);
      }
    }
    _componentWithCanonicalId(component) {
      if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
        return {
          termType: "BlankNode",
          value: this.canonicalIssuer.getId(component.value)
        };
      }
      return component;
    }
    async _yield() {
      return new Promise((resolve) => setImmediate(resolve));
    }
  };
  function _stringHashCompare(a, b) {
    return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
  }
});

// node_modules/rdf-canonize/lib/URGNA2012.js
var require_URGNA2012 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var MessageDigest = require_MessageDigest_browser();
  var URDNA2015 = require_URDNA2015();
  module.exports = class URDNA2012 extends URDNA2015 {
    constructor() {
      super();
      this.name = "URGNA2012";
      this.createMessageDigest = () => new MessageDigest("sha1");
    }
    modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      if (key === "graph") {
        return {
          termType: "BlankNode",
          value: "_:g"
        };
      }
      return {
        termType: "BlankNode",
        value: component.value === id ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return quad.predicate.value;
    }
    async createHashToRelated(id, issuer) {
      const hashToRelated = new Map;
      const quads = this.blankNodeInfo.get(id).quads;
      let i = 0;
      for (const quad of quads) {
        let position;
        let related;
        if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
          related = quad.subject.value;
          position = "p";
        } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
          related = quad.object.value;
          position = "r";
        } else {
          continue;
        }
        if (++i % 100 === 0) {
          await this._yield();
        }
        const hash = await this.hashRelatedBlankNode(related, quad, issuer, position);
        const entries = hashToRelated.get(hash);
        if (entries) {
          entries.push(related);
        } else {
          hashToRelated.set(hash, [related]);
        }
      }
      return hashToRelated;
    }
  };
});

// node_modules/rdf-canonize/lib/URDNA2015Sync.js
var require_URDNA2015Sync = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var IdentifierIssuer = require_IdentifierIssuer();
  var MessageDigest = require_MessageDigest_browser();
  var Permuter = require_Permuter();
  var NQuads = require_NQuads();
  module.exports = class URDNA2015Sync {
    constructor({
      createMessageDigest = () => new MessageDigest("sha256"),
      canonicalIdMap = new Map,
      maxDeepIterations = Infinity
    } = {}) {
      this.name = "URDNA2015";
      this.blankNodeInfo = new Map;
      this.canonicalIssuer = new IdentifierIssuer("_:c14n", canonicalIdMap);
      this.createMessageDigest = createMessageDigest;
      this.maxDeepIterations = maxDeepIterations;
      this.quads = null;
      this.deepIterations = null;
    }
    main(dataset) {
      this.deepIterations = new Map;
      this.quads = dataset;
      for (const quad of dataset) {
        this._addBlankNodeQuadInfo({ quad, component: quad.subject });
        this._addBlankNodeQuadInfo({ quad, component: quad.object });
        this._addBlankNodeQuadInfo({ quad, component: quad.graph });
      }
      const hashToBlankNodes = new Map;
      const nonNormalized = [...this.blankNodeInfo.keys()];
      for (const id of nonNormalized) {
        this._hashAndTrackBlankNode({ id, hashToBlankNodes });
      }
      const hashes = [...hashToBlankNodes.keys()].sort();
      const nonUnique = [];
      for (const hash of hashes) {
        const idList = hashToBlankNodes.get(hash);
        if (idList.length > 1) {
          nonUnique.push(idList);
          continue;
        }
        const id = idList[0];
        this.canonicalIssuer.getId(id);
      }
      for (const idList of nonUnique) {
        const hashPathList = [];
        for (const id of idList) {
          if (this.canonicalIssuer.hasId(id)) {
            continue;
          }
          const issuer = new IdentifierIssuer("_:b");
          issuer.getId(id);
          const result = this.hashNDegreeQuads(id, issuer);
          hashPathList.push(result);
        }
        hashPathList.sort(_stringHashCompare);
        for (const result of hashPathList) {
          const oldIds = result.issuer.getOldIds();
          for (const id of oldIds) {
            this.canonicalIssuer.getId(id);
          }
        }
      }
      const normalized = [];
      for (const quad of this.quads) {
        const nQuad = NQuads.serializeQuadComponents(this._componentWithCanonicalId({ component: quad.subject }), quad.predicate, this._componentWithCanonicalId({ component: quad.object }), this._componentWithCanonicalId({ component: quad.graph }));
        normalized.push(nQuad);
      }
      normalized.sort();
      return normalized.join("");
    }
    hashFirstDegreeQuads(id) {
      const nquads = [];
      const info = this.blankNodeInfo.get(id);
      const quads = info.quads;
      for (const quad of quads) {
        const copy = {
          subject: null,
          predicate: quad.predicate,
          object: null,
          graph: null
        };
        copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, "subject");
        copy.object = this.modifyFirstDegreeComponent(id, quad.object, "object");
        copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, "graph");
        nquads.push(NQuads.serializeQuad(copy));
      }
      nquads.sort();
      const md = this.createMessageDigest();
      for (const nquad of nquads) {
        md.update(nquad);
      }
      info.hash = md.digest();
      return info.hash;
    }
    hashRelatedBlankNode(related, quad, issuer, position) {
      let id;
      if (this.canonicalIssuer.hasId(related)) {
        id = this.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id = issuer.getId(related);
      } else {
        id = this.blankNodeInfo.get(related).hash;
      }
      const md = this.createMessageDigest();
      md.update(position);
      if (position !== "g") {
        md.update(this.getRelatedPredicate(quad));
      }
      md.update(id);
      return md.digest();
    }
    hashNDegreeQuads(id, issuer) {
      const deepIterations = this.deepIterations.get(id) || 0;
      if (deepIterations > this.maxDeepIterations) {
        throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
      }
      this.deepIterations.set(id, deepIterations + 1);
      const md = this.createMessageDigest();
      const hashToRelated = this.createHashToRelated(id, issuer);
      const hashes = [...hashToRelated.keys()].sort();
      for (const hash of hashes) {
        md.update(hash);
        let chosenPath = "";
        let chosenIssuer;
        const permuter = new Permuter(hashToRelated.get(hash));
        while (permuter.hasNext()) {
          const permutation = permuter.next();
          let issuerCopy = issuer.clone();
          let path = "";
          const recursionList = [];
          let nextPermutation = false;
          for (const related of permutation) {
            if (this.canonicalIssuer.hasId(related)) {
              path += this.canonicalIssuer.getId(related);
            } else {
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              }
              path += issuerCopy.getId(related);
            }
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          for (const related of recursionList) {
            const result = this.hashNDegreeQuads(related, issuerCopy);
            path += issuerCopy.getId(related);
            path += `<${result.hash}>`;
            issuerCopy = result.issuer;
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        }
        md.update(chosenPath);
        issuer = chosenIssuer;
      }
      return { hash: md.digest(), issuer };
    }
    modifyFirstDegreeComponent(id, component) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      return {
        termType: "BlankNode",
        value: component.value === id ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return `<${quad.predicate.value}>`;
    }
    createHashToRelated(id, issuer) {
      const hashToRelated = new Map;
      const quads = this.blankNodeInfo.get(id).quads;
      for (const quad of quads) {
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.subject,
          position: "s",
          id,
          issuer,
          hashToRelated
        });
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.object,
          position: "o",
          id,
          issuer,
          hashToRelated
        });
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.graph,
          position: "g",
          id,
          issuer,
          hashToRelated
        });
      }
      return hashToRelated;
    }
    _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
      const hash = this.hashFirstDegreeQuads(id);
      const idList = hashToBlankNodes.get(hash);
      if (!idList) {
        hashToBlankNodes.set(hash, [id]);
      } else {
        idList.push(id);
      }
    }
    _addBlankNodeQuadInfo({ quad, component }) {
      if (component.termType !== "BlankNode") {
        return;
      }
      const id = component.value;
      const info = this.blankNodeInfo.get(id);
      if (info) {
        info.quads.add(quad);
      } else {
        this.blankNodeInfo.set(id, { quads: new Set([quad]), hash: null });
      }
    }
    _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
      if (!(component.termType === "BlankNode" && component.value !== id)) {
        return;
      }
      const related = component.value;
      const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
      const entries = hashToRelated.get(hash);
      if (entries) {
        entries.push(related);
      } else {
        hashToRelated.set(hash, [related]);
      }
    }
    _componentWithCanonicalId({ component }) {
      if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
        return {
          termType: "BlankNode",
          value: this.canonicalIssuer.getId(component.value)
        };
      }
      return component;
    }
  };
  function _stringHashCompare(a, b) {
    return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
  }
});

// node_modules/rdf-canonize/lib/URGNA2012Sync.js
var require_URGNA2012Sync = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
   */
  var MessageDigest = require_MessageDigest_browser();
  var URDNA2015Sync = require_URDNA2015Sync();
  module.exports = class URDNA2012Sync extends URDNA2015Sync {
    constructor() {
      super();
      this.name = "URGNA2012";
      this.createMessageDigest = () => new MessageDigest("sha1");
    }
    modifyFirstDegreeComponent(id, component, key) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      if (key === "graph") {
        return {
          termType: "BlankNode",
          value: "_:g"
        };
      }
      return {
        termType: "BlankNode",
        value: component.value === id ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return quad.predicate.value;
    }
    createHashToRelated(id, issuer) {
      const hashToRelated = new Map;
      const quads = this.blankNodeInfo.get(id).quads;
      for (const quad of quads) {
        let position;
        let related;
        if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
          related = quad.subject.value;
          position = "p";
        } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
          related = quad.object.value;
          position = "r";
        } else {
          continue;
        }
        const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
        const entries = hashToRelated.get(hash);
        if (entries) {
          entries.push(related);
        } else {
          hashToRelated.set(hash, [related]);
        }
      }
      return hashToRelated;
    }
  };
});

// node_modules/rdf-canonize/lib/index.js
var require_lib = __commonJS((exports) => {
  var URDNA2015 = require_URDNA2015();
  var URGNA2012 = require_URGNA2012();
  var URDNA2015Sync = require_URDNA2015Sync();
  var URGNA2012Sync = require_URGNA2012Sync();
  var rdfCanonizeNative;
  try {
    rdfCanonizeNative = (()=>{throw new Error("Cannot require module "+"rdf-canonize-native");})();
  } catch (e) {
  }
  function _inputToDataset(input) {
    if (!Array.isArray(input)) {
      return exports.NQuads.legacyDatasetToQuads(input);
    }
    return input;
  }
  exports.NQuads = require_NQuads();
  exports.IdentifierIssuer = require_IdentifierIssuer();
  exports._rdfCanonizeNative = function(api) {
    if (api) {
      rdfCanonizeNative = api;
    }
    return rdfCanonizeNative;
  };
  exports.canonize = async function(input, options) {
    const dataset = _inputToDataset(input, options);
    if (options.useNative) {
      if (!rdfCanonizeNative) {
        throw new Error("rdf-canonize-native not available");
      }
      if (options.createMessageDigest) {
        throw new Error('"createMessageDigest" cannot be used with "useNative".');
      }
      return new Promise((resolve, reject) => rdfCanonizeNative.canonize(dataset, options, (err, canonical) => err ? reject(err) : resolve(canonical)));
    }
    if (options.algorithm === "URDNA2015") {
      return new URDNA2015(options).main(dataset);
    }
    if (options.algorithm === "URGNA2012") {
      if (options.createMessageDigest) {
        throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
      }
      return new URGNA2012(options).main(dataset);
    }
    if (!("algorithm" in options)) {
      throw new Error("No RDF Dataset Canonicalization algorithm specified.");
    }
    throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
  };
  exports._canonizeSync = function(input, options) {
    const dataset = _inputToDataset(input, options);
    if (options.useNative) {
      if (!rdfCanonizeNative) {
        throw new Error("rdf-canonize-native not available");
      }
      if (options.createMessageDigest) {
        throw new Error('"createMessageDigest" cannot be used with "useNative".');
      }
      return rdfCanonizeNative.canonizeSync(dataset, options);
    }
    if (options.algorithm === "URDNA2015") {
      return new URDNA2015Sync(options).main(dataset);
    }
    if (options.algorithm === "URGNA2012") {
      if (options.createMessageDigest) {
        throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
      }
      return new URGNA2012Sync(options).main(dataset);
    }
    if (!("algorithm" in options)) {
      throw new Error("No RDF Dataset Canonicalization algorithm specified.");
    }
    throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
  };
});

// node_modules/jsonld/lib/types.js
var require_types = __commonJS((exports, module) => {
  var api = {};
  module.exports = api;
  api.isArray = Array.isArray;
  api.isBoolean = (v) => typeof v === "boolean" || Object.prototype.toString.call(v) === "[object Boolean]";
  api.isDouble = (v) => api.isNumber(v) && (String(v).indexOf(".") !== -1 || Math.abs(v) >= 1000000000000000000000);
  api.isEmptyObject = (v) => api.isObject(v) && Object.keys(v).length === 0;
  api.isNumber = (v) => typeof v === "number" || Object.prototype.toString.call(v) === "[object Number]";
  api.isNumeric = (v) => !isNaN(parseFloat(v)) && isFinite(v);
  api.isObject = (v) => Object.prototype.toString.call(v) === "[object Object]";
  api.isString = (v) => typeof v === "string" || Object.prototype.toString.call(v) === "[object String]";
  api.isUndefined = (v) => typeof v === "undefined";
});

// node_modules/jsonld/lib/graphTypes.js
var require_graphTypes = __commonJS((exports, module) => {
  var types = require_types();
  var api = {};
  module.exports = api;
  api.isSubject = (v) => {
    if (types.isObject(v) && !(("@value" in v) || ("@set" in v) || ("@list" in v))) {
      const keyCount = Object.keys(v).length;
      return keyCount > 1 || !("@id" in v);
    }
    return false;
  };
  api.isSubjectReference = (v) => types.isObject(v) && Object.keys(v).length === 1 && ("@id" in v);
  api.isValue = (v) => types.isObject(v) && ("@value" in v);
  api.isList = (v) => types.isObject(v) && ("@list" in v);
  api.isGraph = (v) => {
    return types.isObject(v) && "@graph" in v && Object.keys(v).filter((key) => key !== "@id" && key !== "@index").length === 1;
  };
  api.isSimpleGraph = (v) => {
    return api.isGraph(v) && !("@id" in v);
  };
  api.isBlankNode = (v) => {
    if (types.isObject(v)) {
      if ("@id" in v) {
        const id = v["@id"];
        return !types.isString(id) || id.indexOf("_:") === 0;
      }
      return Object.keys(v).length === 0 || !(("@value" in v) || ("@set" in v) || ("@list" in v));
    }
    return false;
  };
});

// node_modules/jsonld/lib/JsonLdError.js
var require_JsonLdError = __commonJS((exports, module) => {
  module.exports = class JsonLdError extends Error {
    constructor(message = "An unspecified JSON-LD error occurred.", name = "jsonld.Error", details = {}) {
      super(message);
      this.name = name;
      this.message = message;
      this.details = details;
    }
  };
});

// node_modules/jsonld/lib/util.js
var require_util = __commonJS((exports, module) => {
  var graphTypes = require_graphTypes();
  var types = require_types();
  var IdentifierIssuer = require_lib().IdentifierIssuer;
  var JsonLdError = require_JsonLdError();
  var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
  var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
  var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
  var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
  var REGEX_KEYWORD = /^@[a-zA-Z]+$/;
  var DEFAULTS = {
    headers: {
      accept: "application/ld+json, application/json"
    }
  };
  var api = {};
  module.exports = api;
  api.IdentifierIssuer = IdentifierIssuer;
  api.REGEX_BCP47 = REGEX_BCP47;
  api.REGEX_KEYWORD = REGEX_KEYWORD;
  api.clone = function(value) {
    if (value && typeof value === "object") {
      let rval;
      if (types.isArray(value)) {
        rval = [];
        for (let i = 0;i < value.length; ++i) {
          rval[i] = api.clone(value[i]);
        }
      } else if (value instanceof Map) {
        rval = new Map;
        for (const [k, v] of value) {
          rval.set(k, api.clone(v));
        }
      } else if (value instanceof Set) {
        rval = new Set;
        for (const v of value) {
          rval.add(api.clone(v));
        }
      } else if (types.isObject(value)) {
        rval = {};
        for (const key in value) {
          rval[key] = api.clone(value[key]);
        }
      } else {
        rval = value.toString();
      }
      return rval;
    }
    return value;
  };
  api.asArray = function(value) {
    return Array.isArray(value) ? value : [value];
  };
  api.buildHeaders = (headers = {}) => {
    const hasAccept = Object.keys(headers).some((h) => h.toLowerCase() === "accept");
    if (hasAccept) {
      throw new RangeError('Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.');
    }
    return Object.assign({ Accept: DEFAULTS.headers.accept }, headers);
  };
  api.parseLinkHeader = (header) => {
    const rval = {};
    const entries = header.match(REGEX_LINK_HEADERS);
    for (let i = 0;i < entries.length; ++i) {
      let match = entries[i].match(REGEX_LINK_HEADER);
      if (!match) {
        continue;
      }
      const result = { target: match[1] };
      const params = match[2];
      while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
        result[match[1]] = match[2] === undefined ? match[3] : match[2];
      }
      const rel = result.rel || "";
      if (Array.isArray(rval[rel])) {
        rval[rel].push(result);
      } else if (rval.hasOwnProperty(rel)) {
        rval[rel] = [rval[rel], result];
      } else {
        rval[rel] = result;
      }
    }
    return rval;
  };
  api.validateTypeValue = (v, isFrame) => {
    if (types.isString(v)) {
      return;
    }
    if (types.isArray(v) && v.every((vv) => types.isString(vv))) {
      return;
    }
    if (isFrame && types.isObject(v)) {
      switch (Object.keys(v).length) {
        case 0:
          return;
        case 1:
          if ("@default" in v && api.asArray(v["@default"]).every((vv) => types.isString(vv))) {
            return;
          }
      }
    }
    throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of ' + "strings, an empty object, " + "or a default object.", "jsonld.SyntaxError", { code: "invalid type value", value: v });
  };
  api.hasProperty = (subject, property) => {
    if (subject.hasOwnProperty(property)) {
      const value = subject[property];
      return !types.isArray(value) || value.length > 0;
    }
    return false;
  };
  api.hasValue = (subject, property, value) => {
    if (api.hasProperty(subject, property)) {
      let val = subject[property];
      const isList = graphTypes.isList(val);
      if (types.isArray(val) || isList) {
        if (isList) {
          val = val["@list"];
        }
        for (let i = 0;i < val.length; ++i) {
          if (api.compareValues(value, val[i])) {
            return true;
          }
        }
      } else if (!types.isArray(value)) {
        return api.compareValues(value, val);
      }
    }
    return false;
  };
  api.addValue = (subject, property, value, options) => {
    options = options || {};
    if (!("propertyIsArray" in options)) {
      options.propertyIsArray = false;
    }
    if (!("valueIsArray" in options)) {
      options.valueIsArray = false;
    }
    if (!("allowDuplicate" in options)) {
      options.allowDuplicate = true;
    }
    if (!("prependValue" in options)) {
      options.prependValue = false;
    }
    if (options.valueIsArray) {
      subject[property] = value;
    } else if (types.isArray(value)) {
      if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
        subject[property] = [];
      }
      if (options.prependValue) {
        value = value.concat(subject[property]);
        subject[property] = [];
      }
      for (let i = 0;i < value.length; ++i) {
        api.addValue(subject, property, value[i], options);
      }
    } else if (subject.hasOwnProperty(property)) {
      const hasValue = !options.allowDuplicate && api.hasValue(subject, property, value);
      if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
        subject[property] = [subject[property]];
      }
      if (!hasValue) {
        if (options.prependValue) {
          subject[property].unshift(value);
        } else {
          subject[property].push(value);
        }
      }
    } else {
      subject[property] = options.propertyIsArray ? [value] : value;
    }
  };
  api.getValues = (subject, property) => [].concat(subject[property] || []);
  api.removeProperty = (subject, property) => {
    delete subject[property];
  };
  api.removeValue = (subject, property, value, options) => {
    options = options || {};
    if (!("propertyIsArray" in options)) {
      options.propertyIsArray = false;
    }
    const values = api.getValues(subject, property).filter((e) => !api.compareValues(e, value));
    if (values.length === 0) {
      api.removeProperty(subject, property);
    } else if (values.length === 1 && !options.propertyIsArray) {
      subject[property] = values[0];
    } else {
      subject[property] = values;
    }
  };
  api.relabelBlankNodes = (input, options) => {
    options = options || {};
    const issuer = options.issuer || new IdentifierIssuer("_:b");
    return _labelBlankNodes(issuer, input);
  };
  api.compareValues = (v1, v2) => {
    if (v1 === v2) {
      return true;
    }
    if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1["@value"] === v2["@value"] && v1["@type"] === v2["@type"] && v1["@language"] === v2["@language"] && v1["@index"] === v2["@index"]) {
      return true;
    }
    if (types.isObject(v1) && "@id" in v1 && types.isObject(v2) && "@id" in v2) {
      return v1["@id"] === v2["@id"];
    }
    return false;
  };
  api.compareShortestLeast = (a, b) => {
    if (a.length < b.length) {
      return -1;
    }
    if (b.length < a.length) {
      return 1;
    }
    if (a === b) {
      return 0;
    }
    return a < b ? -1 : 1;
  };
  function _labelBlankNodes(issuer, element) {
    if (types.isArray(element)) {
      for (let i = 0;i < element.length; ++i) {
        element[i] = _labelBlankNodes(issuer, element[i]);
      }
    } else if (graphTypes.isList(element)) {
      element["@list"] = _labelBlankNodes(issuer, element["@list"]);
    } else if (types.isObject(element)) {
      if (graphTypes.isBlankNode(element)) {
        element["@id"] = issuer.getId(element["@id"]);
      }
      const keys = Object.keys(element).sort();
      for (let ki = 0;ki < keys.length; ++ki) {
        const key = keys[ki];
        if (key !== "@id") {
          element[key] = _labelBlankNodes(issuer, element[key]);
        }
      }
    }
    return element;
  }
});

// node_modules/jsonld/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  var XSD = "http://www.w3.org/2001/XMLSchema#";
  module.exports = {
    LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
    LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context",
    RDF,
    RDF_LIST: RDF + "List",
    RDF_FIRST: RDF + "first",
    RDF_REST: RDF + "rest",
    RDF_NIL: RDF + "nil",
    RDF_TYPE: RDF + "type",
    RDF_PLAIN_LITERAL: RDF + "PlainLiteral",
    RDF_XML_LITERAL: RDF + "XMLLiteral",
    RDF_JSON_LITERAL: RDF + "JSON",
    RDF_OBJECT: RDF + "object",
    RDF_LANGSTRING: RDF + "langString",
    XSD,
    XSD_BOOLEAN: XSD + "boolean",
    XSD_DOUBLE: XSD + "double",
    XSD_INTEGER: XSD + "integer",
    XSD_STRING: XSD + "string"
  };
});

// node_modules/jsonld/lib/RequestQueue.js
var require_RequestQueue = __commonJS((exports, module) => {
  module.exports = class RequestQueue {
    constructor() {
      this._requests = {};
    }
    wrapLoader(loader) {
      const self2 = this;
      self2._loader = loader;
      return function() {
        return self2.add.apply(self2, arguments);
      };
    }
    async add(url) {
      let promise = this._requests[url];
      if (promise) {
        return Promise.resolve(promise);
      }
      promise = this._requests[url] = this._loader(url);
      try {
        return await promise;
      } finally {
        delete this._requests[url];
      }
    }
  };
});

// node_modules/jsonld/lib/url.js
var require_url = __commonJS((exports, module) => {
  var types = require_types();
  var api = {};
  module.exports = api;
  api.parsers = {
    simple: {
      keys: [
        "href",
        "scheme",
        "authority",
        "path",
        "query",
        "fragment"
      ],
      regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
    },
    full: {
      keys: [
        "href",
        "protocol",
        "scheme",
        "authority",
        "auth",
        "user",
        "password",
        "hostname",
        "port",
        "path",
        "directory",
        "file",
        "query",
        "fragment"
      ],
      regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  api.parse = (str, parser) => {
    const parsed = {};
    const o = api.parsers[parser || "full"];
    const m = o.regex.exec(str);
    let i = o.keys.length;
    while (i--) {
      parsed[o.keys[i]] = m[i] === undefined ? null : m[i];
    }
    if (parsed.scheme === "https" && parsed.port === "443" || parsed.scheme === "http" && parsed.port === "80") {
      parsed.href = parsed.href.replace(":" + parsed.port, "");
      parsed.authority = parsed.authority.replace(":" + parsed.port, "");
      parsed.port = null;
    }
    parsed.normalizedPath = api.removeDotSegments(parsed.path);
    return parsed;
  };
  api.prependBase = (base, iri) => {
    if (base === null) {
      return iri;
    }
    if (api.isAbsolute(iri)) {
      return iri;
    }
    if (!base || types.isString(base)) {
      base = api.parse(base || "");
    }
    const rel = api.parse(iri);
    const transform = {
      protocol: base.protocol || ""
    };
    if (rel.authority !== null) {
      transform.authority = rel.authority;
      transform.path = rel.path;
      transform.query = rel.query;
    } else {
      transform.authority = base.authority;
      if (rel.path === "") {
        transform.path = base.path;
        if (rel.query !== null) {
          transform.query = rel.query;
        } else {
          transform.query = base.query;
        }
      } else {
        if (rel.path.indexOf("/") === 0) {
          transform.path = rel.path;
        } else {
          let path = base.path;
          path = path.substr(0, path.lastIndexOf("/") + 1);
          if ((path.length > 0 || base.authority) && path.substr(-1) !== "/") {
            path += "/";
          }
          path += rel.path;
          transform.path = path;
        }
        transform.query = rel.query;
      }
    }
    if (rel.path !== "") {
      transform.path = api.removeDotSegments(transform.path);
    }
    let rval = transform.protocol;
    if (transform.authority !== null) {
      rval += "//" + transform.authority;
    }
    rval += transform.path;
    if (transform.query !== null) {
      rval += "?" + transform.query;
    }
    if (rel.fragment !== null) {
      rval += "#" + rel.fragment;
    }
    if (rval === "") {
      rval = "./";
    }
    return rval;
  };
  api.removeBase = (base, iri) => {
    if (base === null) {
      return iri;
    }
    if (!base || types.isString(base)) {
      base = api.parse(base || "");
    }
    let root = "";
    if (base.href !== "") {
      root += (base.protocol || "") + "//" + (base.authority || "");
    } else if (iri.indexOf("//")) {
      root += "//";
    }
    if (iri.indexOf(root) !== 0) {
      return iri;
    }
    const rel = api.parse(iri.substr(root.length));
    const baseSegments = base.normalizedPath.split("/");
    const iriSegments = rel.normalizedPath.split("/");
    const last = rel.fragment || rel.query ? 0 : 1;
    while (baseSegments.length > 0 && iriSegments.length > last) {
      if (baseSegments[0] !== iriSegments[0]) {
        break;
      }
      baseSegments.shift();
      iriSegments.shift();
    }
    let rval = "";
    if (baseSegments.length > 0) {
      baseSegments.pop();
      for (let i = 0;i < baseSegments.length; ++i) {
        rval += "../";
      }
    }
    rval += iriSegments.join("/");
    if (rel.query !== null) {
      rval += "?" + rel.query;
    }
    if (rel.fragment !== null) {
      rval += "#" + rel.fragment;
    }
    if (rval === "") {
      rval = "./";
    }
    return rval;
  };
  api.removeDotSegments = (path) => {
    if (path.length === 0) {
      return "";
    }
    const input = path.split("/");
    const output = [];
    while (input.length > 0) {
      const next = input.shift();
      const done = input.length === 0;
      if (next === ".") {
        if (done) {
          output.push("");
        }
        continue;
      }
      if (next === "..") {
        output.pop();
        if (done) {
          output.push("");
        }
        continue;
      }
      output.push(next);
    }
    if (path[0] === "/" && output.length > 0 && output[0] !== "") {
      output.unshift("");
    }
    if (output.length === 1 && output[0] === "") {
      return "/";
    }
    return output.join("/");
  };
  var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
  api.isAbsolute = (v) => types.isString(v) && isAbsoluteRegex.test(v);
  api.isRelative = (v) => types.isString(v);
});

// node_modules/jsonld/lib/documentLoaders/xhr.js
var require_xhr = __commonJS((exports, module) => {
  var { parseLinkHeader, buildHeaders } = require_util();
  var { LINK_HEADER_CONTEXT } = require_constants();
  var JsonLdError = require_JsonLdError();
  var RequestQueue = require_RequestQueue();
  var { prependBase } = require_url();
  var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
  module.exports = ({
    secure,
    headers = {},
    xhr
  } = { headers: {} }) => {
    headers = buildHeaders(headers);
    const queue = new RequestQueue;
    return queue.wrapLoader(loader);
    async function loader(url) {
      if (url.indexOf("http:") !== 0 && url.indexOf("https:") !== 0) {
        throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + "supported.", "jsonld.InvalidUrl", { code: "loading document failed", url });
      }
      if (secure && url.indexOf("https") !== 0) {
        throw new JsonLdError("URL could not be dereferenced; secure mode is enabled and " + `the URL's scheme is not "https".`, "jsonld.InvalidUrl", { code: "loading document failed", url });
      }
      let req;
      try {
        req = await _get(xhr, url, headers);
      } catch (e) {
        throw new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url, cause: e });
      }
      if (req.status >= 400) {
        throw new JsonLdError("URL could not be dereferenced: " + req.statusText, "jsonld.LoadDocumentError", {
          code: "loading document failed",
          url,
          httpStatusCode: req.status
        });
      }
      let doc = { contextUrl: null, documentUrl: url, document: req.response };
      let alternate = null;
      const contentType = req.getResponseHeader("Content-Type");
      let linkHeader;
      if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
        linkHeader = req.getResponseHeader("Link");
      }
      if (linkHeader && contentType !== "application/ld+json") {
        const linkHeaders = parseLinkHeader(linkHeader);
        const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];
        if (Array.isArray(linkedContext)) {
          throw new JsonLdError("URL could not be dereferenced, it has more than one " + "associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url });
        }
        if (linkedContext) {
          doc.contextUrl = linkedContext.target;
        }
        alternate = linkHeaders.alternate;
        if (alternate && alternate.type == "application/ld+json" && !(contentType || "").match(/^application\/(\w*\+)?json$/)) {
          doc = await loader(prependBase(url, alternate.target));
        }
      }
      return doc;
    }
  };
  function _get(xhr, url, headers) {
    xhr = xhr || XMLHttpRequest;
    const req = new xhr;
    return new Promise((resolve, reject) => {
      req.onload = () => resolve(req);
      req.onerror = (err) => reject(err);
      req.open("GET", url, true);
      for (const k in headers) {
        req.setRequestHeader(k, headers[k]);
      }
      req.send();
    });
  }
});

// node_modules/jsonld/lib/platform-browser.js
var require_platform_browser = __commonJS((exports, module) => {
  var xhrLoader = require_xhr();
  var api = {};
  module.exports = api;
  api.setupDocumentLoaders = function(jsonld) {
    if (typeof XMLHttpRequest !== "undefined") {
      jsonld.documentLoaders.xhr = xhrLoader;
      jsonld.useDocumentLoader("xhr");
    }
  };
  api.setupGlobals = function(jsonld) {
    if (typeof globalThis.JsonLdProcessor === "undefined") {
      Object.defineProperty(globalThis, "JsonLdProcessor", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: jsonld.JsonLdProcessor
      });
    }
  };
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1;l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/jsonld/lib/ResolvedContext.js
var require_ResolvedContext = __commonJS((exports, module) => {
  var LRU = require_lru_cache();
  var MAX_ACTIVE_CONTEXTS = 10;
  module.exports = class ResolvedContext {
    constructor({ document: document2 }) {
      this.document = document2;
      this.cache = new LRU({ max: MAX_ACTIVE_CONTEXTS });
    }
    getProcessed(activeCtx) {
      return this.cache.get(activeCtx);
    }
    setProcessed(activeCtx, processedCtx) {
      this.cache.set(activeCtx, processedCtx);
    }
  };
});

// node_modules/jsonld/lib/ContextResolver.js
var require_ContextResolver = __commonJS((exports, module) => {
  var {
    isArray: _isArray,
    isObject: _isObject2,
    isString: _isString2
  } = require_types();
  var {
    asArray: _asArray
  } = require_util();
  var { prependBase } = require_url();
  var JsonLdError = require_JsonLdError();
  var ResolvedContext = require_ResolvedContext();
  var MAX_CONTEXT_URLS = 10;
  module.exports = class ContextResolver {
    constructor({ sharedCache }) {
      this.perOpCache = new Map;
      this.sharedCache = sharedCache;
    }
    async resolve({
      activeCtx,
      context,
      documentLoader,
      base,
      cycles = new Set
    }) {
      if (context && _isObject2(context) && context["@context"]) {
        context = context["@context"];
      }
      context = _asArray(context);
      const allResolved = [];
      for (const ctx of context) {
        if (_isString2(ctx)) {
          let resolved2 = this._get(ctx);
          if (!resolved2) {
            resolved2 = await this._resolveRemoteContext({ activeCtx, url: ctx, documentLoader, base, cycles });
          }
          if (_isArray(resolved2)) {
            allResolved.push(...resolved2);
          } else {
            allResolved.push(resolved2);
          }
          continue;
        }
        if (ctx === null) {
          allResolved.push(new ResolvedContext({ document: null }));
          continue;
        }
        if (!_isObject2(ctx)) {
          _throwInvalidLocalContext(context);
        }
        const key = JSON.stringify(ctx);
        let resolved = this._get(key);
        if (!resolved) {
          resolved = new ResolvedContext({ document: ctx });
          this._cacheResolvedContext({ key, resolved, tag: "static" });
        }
        allResolved.push(resolved);
      }
      return allResolved;
    }
    _get(key) {
      let resolved = this.perOpCache.get(key);
      if (!resolved) {
        const tagMap = this.sharedCache.get(key);
        if (tagMap) {
          resolved = tagMap.get("static");
          if (resolved) {
            this.perOpCache.set(key, resolved);
          }
        }
      }
      return resolved;
    }
    _cacheResolvedContext({ key, resolved, tag }) {
      this.perOpCache.set(key, resolved);
      if (tag !== undefined) {
        let tagMap = this.sharedCache.get(key);
        if (!tagMap) {
          tagMap = new Map;
          this.sharedCache.set(key, tagMap);
        }
        tagMap.set(tag, resolved);
      }
      return resolved;
    }
    async _resolveRemoteContext({ activeCtx, url, documentLoader, base, cycles }) {
      url = prependBase(base, url);
      const { context, remoteDoc } = await this._fetchContext({ activeCtx, url, documentLoader, cycles });
      base = remoteDoc.documentUrl || url;
      _resolveContextUrls({ context, base });
      const resolved = await this.resolve({ activeCtx, context, documentLoader, base, cycles });
      this._cacheResolvedContext({ key: url, resolved, tag: remoteDoc.tag });
      return resolved;
    }
    async _fetchContext({ activeCtx, url, documentLoader, cycles }) {
      if (cycles.size > MAX_CONTEXT_URLS) {
        throw new JsonLdError("Maximum number of @context URLs exceeded.", "jsonld.ContextUrlError", {
          code: activeCtx.processingMode === "json-ld-1.0" ? "loading remote context failed" : "context overflow",
          max: MAX_CONTEXT_URLS
        });
      }
      if (cycles.has(url)) {
        throw new JsonLdError("Cyclical @context URLs detected.", "jsonld.ContextUrlError", {
          code: activeCtx.processingMode === "json-ld-1.0" ? "recursive context inclusion" : "context overflow",
          url
        });
      }
      cycles.add(url);
      let context;
      let remoteDoc;
      try {
        remoteDoc = await documentLoader(url);
        context = remoteDoc.document || null;
        if (_isString2(context)) {
          context = JSON.parse(context);
        }
      } catch (e) {
        throw new JsonLdError("Dereferencing a URL did not result in a valid JSON-LD object. " + "Possible causes are an inaccessible URL perhaps due to " + "a same-origin policy (ensure the server uses CORS if you are " + "using client-side JavaScript), too many redirects, a " + "non-JSON response, or more than one HTTP Link Header was " + "provided for a remote context.", "jsonld.InvalidUrl", { code: "loading remote context failed", url, cause: e });
      }
      if (!_isObject2(context)) {
        throw new JsonLdError("Dereferencing a URL did not result in a JSON object. The " + "response was valid JSON, but it was not a JSON object.", "jsonld.InvalidUrl", { code: "invalid remote context", url });
      }
      if (!("@context" in context)) {
        context = { "@context": {} };
      } else {
        context = { "@context": context["@context"] };
      }
      if (remoteDoc.contextUrl) {
        if (!_isArray(context["@context"])) {
          context["@context"] = [context["@context"]];
        }
        context["@context"].push(remoteDoc.contextUrl);
      }
      return { context, remoteDoc };
    }
  };
  function _throwInvalidLocalContext(ctx) {
    throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", {
      code: "invalid local context",
      context: ctx
    });
  }
  function _resolveContextUrls({ context, base }) {
    if (!context) {
      return;
    }
    const ctx = context["@context"];
    if (_isString2(ctx)) {
      context["@context"] = prependBase(base, ctx);
      return;
    }
    if (_isArray(ctx)) {
      for (let i = 0;i < ctx.length; ++i) {
        const element = ctx[i];
        if (_isString2(element)) {
          ctx[i] = prependBase(base, element);
          continue;
        }
        if (_isObject2(element)) {
          _resolveContextUrls({ context: { "@context": element }, base });
        }
      }
      return;
    }
    if (!_isObject2(ctx)) {
      return;
    }
    for (const term in ctx) {
      _resolveContextUrls({ context: ctx[term], base });
    }
  }
});

// node_modules/jsonld/lib/NQuads.js
var require_NQuads2 = __commonJS((exports, module) => {
  module.exports = require_lib().NQuads;
});

// node_modules/jsonld/lib/events.js
var require_events = __commonJS((exports, module) => {
  var JsonLdError = require_JsonLdError();
  var {
    isArray: _isArray
  } = require_types();
  var {
    asArray: _asArray
  } = require_util();
  var api = {};
  module.exports = api;
  api.defaultEventHandler = null;
  api.setupEventHandler = ({ options = {} }) => {
    const eventHandler = [].concat(options.safe ? api.safeEventHandler : [], options.eventHandler ? _asArray(options.eventHandler) : [], api.defaultEventHandler ? api.defaultEventHandler : []);
    return eventHandler.length === 0 ? null : eventHandler;
  };
  api.handleEvent = ({
    event,
    options
  }) => {
    _handle({ event, handlers: options.eventHandler });
  };
  function _handle({ event, handlers }) {
    let doNext = true;
    for (let i = 0;doNext && i < handlers.length; ++i) {
      doNext = false;
      const handler = handlers[i];
      if (_isArray(handler)) {
        doNext = _handle({ event, handlers: handler });
      } else if (typeof handler === "function") {
        handler({ event, next: () => {
          doNext = true;
        } });
      } else if (typeof handler === "object") {
        if (event.code in handler) {
          handler[event.code]({ event, next: () => {
            doNext = true;
          } });
        } else {
          doNext = true;
        }
      } else {
        throw new JsonLdError("Invalid event handler.", "jsonld.InvalidEventHandler", { event });
      }
    }
    return doNext;
  }
  var _notSafeEventCodes = new Set([
    "empty object",
    "free-floating scalar",
    "invalid @language value",
    "invalid property",
    "null @id value",
    "null @value value",
    "object with only @id",
    "object with only @language",
    "object with only @list",
    "object with only @value",
    "relative @id reference",
    "relative @type reference",
    "relative @vocab reference",
    "reserved @id value",
    "reserved @reverse value",
    "reserved term",
    "blank node predicate",
    "relative graph reference",
    "relative object reference",
    "relative predicate reference",
    "relative subject reference",
    "rdfDirection not set"
  ]);
  api.safeEventHandler = function safeEventHandler({ event, next }) {
    if (event.level === "warning" && _notSafeEventCodes.has(event.code)) {
      throw new JsonLdError("Safe mode validation error.", "jsonld.ValidationError", { event });
    }
    next();
  };
  api.logEventHandler = function logEventHandler({ event, next }) {
    console.log(`EVENT: ${event.message}`, { event });
    next();
  };
  api.logWarningEventHandler = function logWarningEventHandler({ event, next }) {
    if (event.level === "warning") {
      console.warn(`WARNING: ${event.message}`, { event });
    }
    next();
  };
  api.unhandledEventHandler = function unhandledEventHandler({ event }) {
    throw new JsonLdError("No handler for event.", "jsonld.UnhandledEvent", { event });
  };
  api.setDefaultEventHandler = function({ eventHandler } = {}) {
    api.defaultEventHandler = eventHandler ? _asArray(eventHandler) : null;
  };
});

// node_modules/jsonld/lib/context.js
var require_context = __commonJS((exports, module) => {
  var util = require_util();
  var JsonLdError = require_JsonLdError();
  var {
    isArray: _isArray,
    isObject: _isObject2,
    isString: _isString2,
    isUndefined: _isUndefined
  } = require_types();
  var {
    isAbsolute: _isAbsoluteIri,
    isRelative: _isRelativeIri,
    prependBase
  } = require_url();
  var {
    handleEvent: _handleEvent
  } = require_events();
  var {
    REGEX_BCP47,
    REGEX_KEYWORD,
    asArray: _asArray,
    compareShortestLeast: _compareShortestLeast
  } = require_util();
  var INITIAL_CONTEXT_CACHE = new Map;
  var INITIAL_CONTEXT_CACHE_MAX_SIZE = 1e4;
  var api = {};
  module.exports = api;
  api.process = async ({
    activeCtx,
    localCtx,
    options,
    propagate = true,
    overrideProtected = false,
    cycles = new Set
  }) => {
    if (_isObject2(localCtx) && "@context" in localCtx && _isArray(localCtx["@context"])) {
      localCtx = localCtx["@context"];
    }
    const ctxs = _asArray(localCtx);
    if (ctxs.length === 0) {
      return activeCtx;
    }
    const events = [];
    const eventCaptureHandler = [
      ({ event, next }) => {
        events.push(event);
        next();
      }
    ];
    if (options.eventHandler) {
      eventCaptureHandler.push(options.eventHandler);
    }
    const originalOptions = options;
    options = { ...options, eventHandler: eventCaptureHandler };
    const resolved = await options.contextResolver.resolve({
      activeCtx,
      context: localCtx,
      documentLoader: options.documentLoader,
      base: options.base
    });
    if (_isObject2(resolved[0].document) && typeof resolved[0].document["@propagate"] === "boolean") {
      propagate = resolved[0].document["@propagate"];
    }
    let rval = activeCtx;
    if (!propagate && !rval.previousContext) {
      rval = rval.clone();
      rval.previousContext = activeCtx;
    }
    for (const resolvedContext of resolved) {
      let { document: ctx } = resolvedContext;
      activeCtx = rval;
      if (ctx === null) {
        if (!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {
          throw new JsonLdError("Tried to nullify a context with protected terms outside of " + "a term definition.", "jsonld.SyntaxError", { code: "invalid context nullification" });
        }
        rval = activeCtx = api.getInitialContext(options).clone();
        continue;
      }
      const processed = resolvedContext.getProcessed(activeCtx);
      if (processed) {
        if (originalOptions.eventHandler) {
          for (const event of processed.events) {
            _handleEvent({ event, options: originalOptions });
          }
        }
        rval = activeCtx = processed.context;
        continue;
      }
      if (_isObject2(ctx) && "@context" in ctx) {
        ctx = ctx["@context"];
      }
      if (!_isObject2(ctx)) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", { code: "invalid local context", context: ctx });
      }
      rval = rval.clone();
      const defined = new Map;
      if ("@version" in ctx) {
        if (ctx["@version"] !== 1.1) {
          throw new JsonLdError("Unsupported JSON-LD version: " + ctx["@version"], "jsonld.UnsupportedVersion", { code: "invalid @version value", context: ctx });
        }
        if (activeCtx.processingMode && activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError("@version: " + ctx["@version"] + " not compatible with " + activeCtx.processingMode, "jsonld.ProcessingModeConflict", { code: "processing mode conflict", context: ctx });
        }
        rval.processingMode = "json-ld-1.1";
        rval["@version"] = ctx["@version"];
        defined.set("@version", true);
      }
      rval.processingMode = rval.processingMode || activeCtx.processingMode;
      if ("@base" in ctx) {
        let base = ctx["@base"];
        if (base === null || _isAbsoluteIri(base)) {
        } else if (_isRelativeIri(base)) {
          base = prependBase(rval["@base"], base);
        } else {
          throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a ' + "@context must be an absolute IRI, a relative IRI, or null.", "jsonld.SyntaxError", { code: "invalid base IRI", context: ctx });
        }
        rval["@base"] = base;
        defined.set("@base", true);
      }
      if ("@vocab" in ctx) {
        const value = ctx["@vocab"];
        if (value === null) {
          delete rval["@vocab"];
        } else if (!_isString2(value)) {
          throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + "@context must be a string or null.", "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
        } else if (!_isAbsoluteIri(value) && api.processingMode(rval, 1)) {
          throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + "@context must be an absolute IRI.", "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
        } else {
          const vocab = _expandIri(rval, value, { vocab: true, base: true }, undefined, undefined, options);
          if (!_isAbsoluteIri(vocab)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative @vocab reference",
                  level: "warning",
                  message: "Relative @vocab reference found.",
                  details: {
                    vocab
                  }
                },
                options
              });
            }
          }
          rval["@vocab"] = vocab;
        }
        defined.set("@vocab", true);
      }
      if ("@language" in ctx) {
        const value = ctx["@language"];
        if (value === null) {
          delete rval["@language"];
        } else if (!_isString2(value)) {
          throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a ' + "@context must be a string or null.", "jsonld.SyntaxError", { code: "invalid default language", context: ctx });
        } else {
          if (!value.match(REGEX_BCP47)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language: value
                  }
                },
                options
              });
            }
          }
          rval["@language"] = value.toLowerCase();
        }
        defined.set("@language", true);
      }
      if ("@direction" in ctx) {
        const value = ctx["@direction"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError("Invalid JSON-LD syntax; @direction not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context member", context: ctx });
        }
        if (value === null) {
          delete rval["@direction"];
        } else if (value !== "ltr" && value !== "rtl") {
          throw new JsonLdError('Invalid JSON-LD syntax; the value of "@direction" in a ' + '@context must be null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: ctx });
        } else {
          rval["@direction"] = value;
        }
        defined.set("@direction", true);
      }
      if ("@propagate" in ctx) {
        const value = ctx["@propagate"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError("Invalid JSON-LD syntax; @propagate not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: ctx });
        }
        if (typeof value !== "boolean") {
          throw new JsonLdError("Invalid JSON-LD syntax; @propagate value must be a boolean.", "jsonld.SyntaxError", { code: "invalid @propagate value", context: localCtx });
        }
        defined.set("@propagate", true);
      }
      if ("@import" in ctx) {
        const value = ctx["@import"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError("Invalid JSON-LD syntax; @import not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: ctx });
        }
        if (!_isString2(value)) {
          throw new JsonLdError("Invalid JSON-LD syntax; @import must be a string.", "jsonld.SyntaxError", { code: "invalid @import value", context: localCtx });
        }
        const resolvedImport = await options.contextResolver.resolve({
          activeCtx,
          context: value,
          documentLoader: options.documentLoader,
          base: options.base
        });
        if (resolvedImport.length !== 1) {
          throw new JsonLdError("Invalid JSON-LD syntax; @import must reference a single context.", "jsonld.SyntaxError", { code: "invalid remote context", context: localCtx });
        }
        const processedImport = resolvedImport[0].getProcessed(activeCtx);
        if (processedImport) {
          ctx = processedImport;
        } else {
          const importCtx = resolvedImport[0].document;
          if ("@import" in importCtx) {
            throw new JsonLdError("Invalid JSON-LD syntax: " + "imported context must not include @import.", "jsonld.SyntaxError", { code: "invalid context entry", context: localCtx });
          }
          for (const key in importCtx) {
            if (!ctx.hasOwnProperty(key)) {
              ctx[key] = importCtx[key];
            }
          }
          resolvedImport[0].setProcessed(activeCtx, ctx);
        }
        defined.set("@import", true);
      }
      defined.set("@protected", ctx["@protected"] || false);
      for (const key in ctx) {
        api.createTermDefinition({
          activeCtx: rval,
          localCtx: ctx,
          term: key,
          defined,
          options,
          overrideProtected
        });
        if (_isObject2(ctx[key]) && "@context" in ctx[key]) {
          const keyCtx = ctx[key]["@context"];
          let process2 = true;
          if (_isString2(keyCtx)) {
            const url = prependBase(options.base, keyCtx);
            if (cycles.has(url)) {
              process2 = false;
            } else {
              cycles.add(url);
            }
          }
          if (process2) {
            try {
              await api.process({
                activeCtx: rval.clone(),
                localCtx: ctx[key]["@context"],
                overrideProtected: true,
                options,
                cycles
              });
            } catch (e) {
              throw new JsonLdError("Invalid JSON-LD syntax; invalid scoped context.", "jsonld.SyntaxError", {
                code: "invalid scoped context",
                context: ctx[key]["@context"],
                term: key
              });
            }
          }
        }
      }
      resolvedContext.setProcessed(activeCtx, {
        context: rval,
        events
      });
    }
    return rval;
  };
  api.createTermDefinition = ({
    activeCtx,
    localCtx,
    term,
    defined,
    options,
    overrideProtected = false
  }) => {
    if (defined.has(term)) {
      if (defined.get(term)) {
        return;
      }
      throw new JsonLdError("Cyclical context definition detected.", "jsonld.CyclicalContext", { code: "cyclic IRI mapping", context: localCtx, term });
    }
    defined.set(term, false);
    let value;
    if (localCtx.hasOwnProperty(term)) {
      value = localCtx[term];
    }
    if (term === "@type" && _isObject2(value) && (value["@container"] || "@set") === "@set" && api.processingMode(activeCtx, 1.1)) {
      const validKeys2 = ["@container", "@id", "@protected"];
      const keys = Object.keys(value);
      if (keys.length === 0 || keys.some((k) => !validKeys2.includes(k))) {
        throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
      }
    } else if (api.isKeyword(term)) {
      throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
    } else if (term.match(REGEX_KEYWORD)) {
      if (options.eventHandler) {
        _handleEvent({
          event: {
            type: ["JsonLdEvent"],
            code: "reserved term",
            level: "warning",
            message: 'Terms beginning with "@" are ' + "reserved for future use and dropped.",
            details: {
              term
            }
          },
          options
        });
      }
      return;
    } else if (term === "") {
      throw new JsonLdError("Invalid JSON-LD syntax; a term cannot be an empty string.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
    }
    const previousMapping = activeCtx.mappings.get(term);
    if (activeCtx.mappings.has(term)) {
      activeCtx.mappings.delete(term);
    }
    let simpleTerm = false;
    if (_isString2(value) || value === null) {
      simpleTerm = true;
      value = { "@id": value };
    }
    if (!_isObject2(value)) {
      throw new JsonLdError("Invalid JSON-LD syntax; @context term values must be " + "strings or objects.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
    }
    const mapping = {};
    activeCtx.mappings.set(term, mapping);
    mapping.reverse = false;
    const validKeys = ["@container", "@id", "@language", "@reverse", "@type"];
    if (api.processingMode(activeCtx, 1.1)) {
      validKeys.push("@context", "@direction", "@index", "@nest", "@prefix", "@protected");
    }
    for (const kw in value) {
      if (!validKeys.includes(kw)) {
        throw new JsonLdError("Invalid JSON-LD syntax; a term definition must not contain " + kw, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
      }
    }
    const colon = term.indexOf(":");
    mapping._termHasColon = colon > 0;
    if ("@reverse" in value) {
      if ("@id" in value) {
        throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not " + "contain @id.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
      }
      if ("@nest" in value) {
        throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not " + "contain @nest.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
      }
      const reverse = value["@reverse"];
      if (!_isString2(reverse)) {
        throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
      }
      if (reverse.match(REGEX_KEYWORD)) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @reverse value",
              level: "warning",
              message: '@reverse values beginning with "@" are ' + "reserved for future use and dropped.",
              details: {
                reverse
              }
            },
            options
          });
        }
        if (previousMapping) {
          activeCtx.mappings.set(term, previousMapping);
        } else {
          activeCtx.mappings.delete(term);
        }
        return;
      }
      const id2 = _expandIri(activeCtx, reverse, { vocab: true, base: false }, localCtx, defined, options);
      if (!_isAbsoluteIri(id2)) {
        throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be an " + "absolute IRI or a blank node identifier.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
      }
      mapping["@id"] = id2;
      mapping.reverse = true;
    } else if ("@id" in value) {
      let id2 = value["@id"];
      if (id2 && !_isString2(id2)) {
        throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an array " + "of strings or a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
      }
      if (id2 === null) {
        mapping["@id"] = null;
      } else if (!api.isKeyword(id2) && id2.match(REGEX_KEYWORD)) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @id value",
              level: "warning",
              message: '@id values beginning with "@" are ' + "reserved for future use and dropped.",
              details: {
                id: id2
              }
            },
            options
          });
        }
        if (previousMapping) {
          activeCtx.mappings.set(term, previousMapping);
        } else {
          activeCtx.mappings.delete(term);
        }
        return;
      } else if (id2 !== term) {
        id2 = _expandIri(activeCtx, id2, { vocab: true, base: false }, localCtx, defined, options);
        if (!_isAbsoluteIri(id2) && !api.isKeyword(id2)) {
          throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an " + "absolute IRI, a blank node identifier, or a keyword.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
        }
        if (term.match(/(?::[^:])|\//)) {
          const termDefined = new Map(defined).set(term, true);
          const termIri = _expandIri(activeCtx, term, { vocab: true, base: false }, localCtx, termDefined, options);
          if (termIri !== id2) {
            throw new JsonLdError("Invalid JSON-LD syntax; term in form of IRI must " + "expand to definition.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
        }
        mapping["@id"] = id2;
        mapping._prefix = simpleTerm && !mapping._termHasColon && id2.match(/[:\/\?#\[\]@]$/) !== null;
      }
    }
    if (!("@id" in mapping)) {
      if (mapping._termHasColon) {
        const prefix = term.substr(0, colon);
        if (localCtx.hasOwnProperty(prefix)) {
          api.createTermDefinition({
            activeCtx,
            localCtx,
            term: prefix,
            defined,
            options
          });
        }
        if (activeCtx.mappings.has(prefix)) {
          const suffix = term.substr(colon + 1);
          mapping["@id"] = activeCtx.mappings.get(prefix)["@id"] + suffix;
        } else {
          mapping["@id"] = term;
        }
      } else if (term === "@type") {
        mapping["@id"] = term;
      } else {
        if (!("@vocab" in activeCtx)) {
          throw new JsonLdError("Invalid JSON-LD syntax; @context terms must define an @id.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx, term });
        }
        mapping["@id"] = activeCtx["@vocab"] + term;
      }
    }
    if (value["@protected"] === true || defined.get("@protected") === true && value["@protected"] !== false) {
      activeCtx.protected[term] = true;
      mapping.protected = true;
    }
    defined.set(term, true);
    if ("@type" in value) {
      let type = value["@type"];
      if (!_isString2(type)) {
        throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be a string.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
      }
      if (type === "@json" || type === "@none") {
        if (api.processingMode(activeCtx, 1)) {
          throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must not be " + `"${type}" in JSON-LD 1.0 mode.`, "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
        }
      } else if (type !== "@id" && type !== "@vocab") {
        type = _expandIri(activeCtx, type, { vocab: true, base: false }, localCtx, defined, options);
        if (!_isAbsoluteIri(type)) {
          throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an " + "absolute IRI.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
        }
        if (type.indexOf("_:") === 0) {
          throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an IRI, " + "not a blank node identifier.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
        }
      }
      mapping["@type"] = type;
    }
    if ("@container" in value) {
      const container = _isString2(value["@container"]) ? [value["@container"]] : value["@container"] || [];
      const validContainers = ["@list", "@set", "@index", "@language"];
      let isValid = true;
      const hasSet = container.includes("@set");
      if (api.processingMode(activeCtx, 1.1)) {
        validContainers.push("@graph", "@id", "@type");
        if (container.includes("@list")) {
          if (container.length !== 1) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @list must " + "have no other values", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
          }
        } else if (container.includes("@graph")) {
          if (container.some((key) => key !== "@graph" && key !== "@id" && key !== "@index" && key !== "@set")) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @graph must " + "have no other values other than @id, @index, and @set", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
          }
        } else {
          isValid &= container.length <= (hasSet ? 2 : 1);
        }
        if (container.includes("@type")) {
          mapping["@type"] = mapping["@type"] || "@id";
          if (!["@id", "@vocab"].includes(mapping["@type"])) {
            throw new JsonLdError("Invalid JSON-LD syntax; container: @type requires @type to be " + "@id or @vocab.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
          }
        }
      } else {
        isValid &= !_isArray(value["@container"]);
        isValid &= container.length <= 1;
      }
      isValid &= container.every((c) => validContainers.includes(c));
      isValid &= !(hasSet && container.includes("@list"));
      if (!isValid) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context @container value must be " + "one of the following: " + validContainers.join(", "), "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
      }
      if (mapping.reverse && !container.every((c) => ["@index", "@set"].includes(c))) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context @container value for a @reverse " + "type definition must be @index or @set.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
      }
      mapping["@container"] = container;
    }
    if ("@index" in value) {
      if (!("@container" in value) || !mapping["@container"].includes("@index")) {
        throw new JsonLdError("Invalid JSON-LD syntax; @index without @index in @container: " + `"${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
      }
      if (!_isString2(value["@index"]) || value["@index"].indexOf("@") === 0) {
        throw new JsonLdError("Invalid JSON-LD syntax; @index must expand to an IRI: " + `"${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
      }
      mapping["@index"] = value["@index"];
    }
    if ("@context" in value) {
      mapping["@context"] = value["@context"];
    }
    if ("@language" in value && !("@type" in value)) {
      let language = value["@language"];
      if (language !== null && !_isString2(language)) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context @language value must be " + "a string or null.", "jsonld.SyntaxError", { code: "invalid language mapping", context: localCtx });
      }
      if (language !== null) {
        language = language.toLowerCase();
      }
      mapping["@language"] = language;
    }
    if ("@prefix" in value) {
      if (term.match(/:|\//)) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
      }
      if (api.isKeyword(mapping["@id"])) {
        throw new JsonLdError("Invalid JSON-LD syntax; keywords may not be used as prefixes", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
      }
      if (typeof value["@prefix"] === "boolean") {
        mapping._prefix = value["@prefix"] === true;
      } else {
        throw new JsonLdError("Invalid JSON-LD syntax; @context value for @prefix must be boolean", "jsonld.SyntaxError", { code: "invalid @prefix value", context: localCtx });
      }
    }
    if ("@direction" in value) {
      const direction = value["@direction"];
      if (direction !== null && direction !== "ltr" && direction !== "rtl") {
        throw new JsonLdError("Invalid JSON-LD syntax; @direction value must be " + 'null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: localCtx });
      }
      mapping["@direction"] = direction;
    }
    if ("@nest" in value) {
      const nest = value["@nest"];
      if (!_isString2(nest) || nest !== "@nest" && nest.indexOf("@") === 0) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context @nest value must be " + "a string which is not a keyword other than @nest.", "jsonld.SyntaxError", { code: "invalid @nest value", context: localCtx });
      }
      mapping["@nest"] = nest;
    }
    const id = mapping["@id"];
    if (id === "@context" || id === "@preserve") {
      throw new JsonLdError("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.", "jsonld.SyntaxError", { code: "invalid keyword alias", context: localCtx });
    }
    if (previousMapping && previousMapping.protected && !overrideProtected) {
      activeCtx.protected[term] = true;
      mapping.protected = true;
      if (!_deepCompare(previousMapping, mapping)) {
        throw new JsonLdError("Invalid JSON-LD syntax; tried to redefine a protected term.", "jsonld.SyntaxError", { code: "protected term redefinition", context: localCtx, term });
      }
    }
  };
  api.expandIri = (activeCtx, value, relativeTo, options) => {
    return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);
  };
  function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
    if (value === null || !_isString2(value) || api.isKeyword(value)) {
      return value;
    }
    if (value.match(REGEX_KEYWORD)) {
      return null;
    }
    if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
      api.createTermDefinition({
        activeCtx,
        localCtx,
        term: value,
        defined,
        options
      });
    }
    relativeTo = relativeTo || {};
    if (relativeTo.vocab) {
      const mapping = activeCtx.mappings.get(value);
      if (mapping === null) {
        return null;
      }
      if (_isObject2(mapping) && "@id" in mapping) {
        return mapping["@id"];
      }
    }
    const colon = value.indexOf(":");
    if (colon > 0) {
      const prefix = value.substr(0, colon);
      const suffix = value.substr(colon + 1);
      if (prefix === "_" || suffix.indexOf("//") === 0) {
        return value;
      }
      if (localCtx && localCtx.hasOwnProperty(prefix)) {
        api.createTermDefinition({
          activeCtx,
          localCtx,
          term: prefix,
          defined,
          options
        });
      }
      const mapping = activeCtx.mappings.get(prefix);
      if (mapping && mapping._prefix) {
        return mapping["@id"] + suffix;
      }
      if (_isAbsoluteIri(value)) {
        return value;
      }
    }
    if (relativeTo.vocab && "@vocab" in activeCtx) {
      const prependedResult = activeCtx["@vocab"] + value;
      value = prependedResult;
    } else if (relativeTo.base) {
      let prependedResult;
      let base;
      if ("@base" in activeCtx) {
        if (activeCtx["@base"]) {
          base = prependBase(options.base, activeCtx["@base"]);
          prependedResult = prependBase(base, value);
        } else {
          base = activeCtx["@base"];
          prependedResult = value;
        }
      } else {
        base = options.base;
        prependedResult = prependBase(options.base, value);
      }
      value = prependedResult;
    }
    return value;
  }
  api.getInitialContext = (options) => {
    const key = JSON.stringify({ processingMode: options.processingMode });
    const cached = INITIAL_CONTEXT_CACHE.get(key);
    if (cached) {
      return cached;
    }
    const initialContext = {
      processingMode: options.processingMode,
      mappings: new Map,
      inverse: null,
      getInverse: _createInverseContext,
      clone: _cloneActiveContext,
      revertToPreviousContext: _revertToPreviousContext,
      protected: {}
    };
    if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
      INITIAL_CONTEXT_CACHE.clear();
    }
    INITIAL_CONTEXT_CACHE.set(key, initialContext);
    return initialContext;
    function _createInverseContext() {
      const activeCtx = this;
      if (activeCtx.inverse) {
        return activeCtx.inverse;
      }
      const inverse = activeCtx.inverse = {};
      const fastCurieMap = activeCtx.fastCurieMap = {};
      const irisToTerms = {};
      const defaultLanguage = (activeCtx["@language"] || "@none").toLowerCase();
      const defaultDirection = activeCtx["@direction"];
      const mappings = activeCtx.mappings;
      const terms = [...mappings.keys()].sort(_compareShortestLeast);
      for (const term of terms) {
        const mapping = mappings.get(term);
        if (mapping === null) {
          continue;
        }
        let container = mapping["@container"] || "@none";
        container = [].concat(container).sort().join("");
        if (mapping["@id"] === null) {
          continue;
        }
        const ids = _asArray(mapping["@id"]);
        for (const iri of ids) {
          let entry = inverse[iri];
          const isKeyword = api.isKeyword(iri);
          if (!entry) {
            inverse[iri] = entry = {};
            if (!isKeyword && !mapping._termHasColon) {
              irisToTerms[iri] = [term];
              const fastCurieEntry = { iri, terms: irisToTerms[iri] };
              if (iri[0] in fastCurieMap) {
                fastCurieMap[iri[0]].push(fastCurieEntry);
              } else {
                fastCurieMap[iri[0]] = [fastCurieEntry];
              }
            }
          } else if (!isKeyword && !mapping._termHasColon) {
            irisToTerms[iri].push(term);
          }
          if (!entry[container]) {
            entry[container] = {
              "@language": {},
              "@type": {},
              "@any": {}
            };
          }
          entry = entry[container];
          _addPreferredTerm(term, entry["@any"], "@none");
          if (mapping.reverse) {
            _addPreferredTerm(term, entry["@type"], "@reverse");
          } else if (mapping["@type"] === "@none") {
            _addPreferredTerm(term, entry["@any"], "@none");
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          } else if ("@type" in mapping) {
            _addPreferredTerm(term, entry["@type"], mapping["@type"]);
          } else if ("@language" in mapping && "@direction" in mapping) {
            const language = mapping["@language"];
            const direction = mapping["@direction"];
            if (language && direction) {
              _addPreferredTerm(term, entry["@language"], `${language}_${direction}`.toLowerCase());
            } else if (language) {
              _addPreferredTerm(term, entry["@language"], language.toLowerCase());
            } else if (direction) {
              _addPreferredTerm(term, entry["@language"], `_${direction}`);
            } else {
              _addPreferredTerm(term, entry["@language"], "@null");
            }
          } else if ("@language" in mapping) {
            _addPreferredTerm(term, entry["@language"], (mapping["@language"] || "@null").toLowerCase());
          } else if ("@direction" in mapping) {
            if (mapping["@direction"]) {
              _addPreferredTerm(term, entry["@language"], `_${mapping["@direction"]}`);
            } else {
              _addPreferredTerm(term, entry["@language"], "@none");
            }
          } else if (defaultDirection) {
            _addPreferredTerm(term, entry["@language"], `_${defaultDirection}`);
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          } else {
            _addPreferredTerm(term, entry["@language"], defaultLanguage);
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          }
        }
      }
      for (const key2 in fastCurieMap) {
        _buildIriMap(fastCurieMap, key2, 1);
      }
      return inverse;
    }
    function _buildIriMap(iriMap, key2, idx) {
      const entries = iriMap[key2];
      const next = iriMap[key2] = {};
      let iri;
      let letter;
      for (const entry of entries) {
        iri = entry.iri;
        if (idx >= iri.length) {
          letter = "";
        } else {
          letter = iri[idx];
        }
        if (letter in next) {
          next[letter].push(entry);
        } else {
          next[letter] = [entry];
        }
      }
      for (const key3 in next) {
        if (key3 === "") {
          continue;
        }
        _buildIriMap(next, key3, idx + 1);
      }
    }
    function _addPreferredTerm(term, entry, typeOrLanguageValue) {
      if (!entry.hasOwnProperty(typeOrLanguageValue)) {
        entry[typeOrLanguageValue] = term;
      }
    }
    function _cloneActiveContext() {
      const child = {};
      child.mappings = util.clone(this.mappings);
      child.clone = this.clone;
      child.inverse = null;
      child.getInverse = this.getInverse;
      child.protected = util.clone(this.protected);
      if (this.previousContext) {
        child.previousContext = this.previousContext.clone();
      }
      child.revertToPreviousContext = this.revertToPreviousContext;
      if ("@base" in this) {
        child["@base"] = this["@base"];
      }
      if ("@language" in this) {
        child["@language"] = this["@language"];
      }
      if ("@vocab" in this) {
        child["@vocab"] = this["@vocab"];
      }
      return child;
    }
    function _revertToPreviousContext() {
      if (!this.previousContext) {
        return this;
      }
      return this.previousContext.clone();
    }
  };
  api.getContextValue = (ctx, key, type) => {
    if (key === null) {
      if (type === "@context") {
        return;
      }
      return null;
    }
    if (ctx.mappings.has(key)) {
      const entry = ctx.mappings.get(key);
      if (_isUndefined(type)) {
        return entry;
      }
      if (entry.hasOwnProperty(type)) {
        return entry[type];
      }
    }
    if (type === "@language" && type in ctx) {
      return ctx[type];
    }
    if (type === "@direction" && type in ctx) {
      return ctx[type];
    }
    if (type === "@context") {
      return;
    }
    return null;
  };
  api.processingMode = (activeCtx, version) => {
    if (version.toString() >= "1.1") {
      return !activeCtx.processingMode || activeCtx.processingMode >= "json-ld-" + version.toString();
    } else {
      return activeCtx.processingMode === "json-ld-1.0";
    }
  };
  api.isKeyword = (v) => {
    if (!_isString2(v) || v[0] !== "@") {
      return false;
    }
    switch (v) {
      case "@base":
      case "@container":
      case "@context":
      case "@default":
      case "@direction":
      case "@embed":
      case "@explicit":
      case "@graph":
      case "@id":
      case "@included":
      case "@index":
      case "@json":
      case "@language":
      case "@list":
      case "@nest":
      case "@none":
      case "@omitDefault":
      case "@prefix":
      case "@preserve":
      case "@protected":
      case "@requireAll":
      case "@reverse":
      case "@set":
      case "@type":
      case "@value":
      case "@version":
      case "@vocab":
        return true;
    }
    return false;
  };
  function _deepCompare(x1, x2) {
    if (!(x1 && typeof x1 === "object") || !(x2 && typeof x2 === "object")) {
      return x1 === x2;
    }
    const x1Array = Array.isArray(x1);
    if (x1Array !== Array.isArray(x2)) {
      return false;
    }
    if (x1Array) {
      if (x1.length !== x2.length) {
        return false;
      }
      for (let i = 0;i < x1.length; ++i) {
        if (!_deepCompare(x1[i], x2[i])) {
          return false;
        }
      }
      return true;
    }
    const k1s = Object.keys(x1);
    const k2s = Object.keys(x2);
    if (k1s.length !== k2s.length) {
      return false;
    }
    for (const k1 in x1) {
      let v1 = x1[k1];
      let v2 = x2[k1];
      if (k1 === "@container") {
        if (Array.isArray(v1) && Array.isArray(v2)) {
          v1 = v1.slice().sort();
          v2 = v2.slice().sort();
        }
      }
      if (!_deepCompare(v1, v2)) {
        return false;
      }
    }
    return true;
  }
});

// node_modules/jsonld/lib/expand.js
var require_expand = __commonJS((exports, module) => {
  var JsonLdError = require_JsonLdError();
  var {
    isArray: _isArray,
    isObject: _isObject2,
    isEmptyObject: _isEmptyObject,
    isString: _isString2,
    isUndefined: _isUndefined
  } = require_types();
  var {
    isList: _isList,
    isValue: _isValue,
    isGraph: _isGraph,
    isSubject: _isSubject
  } = require_graphTypes();
  var {
    expandIri: _expandIri,
    getContextValue: _getContextValue,
    isKeyword: _isKeyword,
    process: _processContext,
    processingMode: _processingMode
  } = require_context();
  var {
    isAbsolute: _isAbsoluteIri
  } = require_url();
  var {
    REGEX_BCP47,
    REGEX_KEYWORD,
    addValue: _addValue,
    asArray: _asArray,
    getValues: _getValues,
    validateTypeValue: _validateTypeValue
  } = require_util();
  var {
    handleEvent: _handleEvent
  } = require_events();
  var api = {};
  module.exports = api;
  api.expand = async ({
    activeCtx,
    activeProperty = null,
    element,
    options = {},
    insideList = false,
    insideIndex = false,
    typeScopedContext = null
  }) => {
    if (element === null || element === undefined) {
      return null;
    }
    if (activeProperty === "@default") {
      options = Object.assign({}, options, { isFrame: false });
    }
    if (!_isArray(element) && !_isObject2(element)) {
      if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, { vocab: true }, options) === "@graph")) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "free-floating scalar",
              level: "warning",
              message: "Dropping free-floating scalar not in a list.",
              details: {
                value: element
              }
            },
            options
          });
        }
        return null;
      }
      return _expandValue({ activeCtx, activeProperty, value: element, options });
    }
    if (_isArray(element)) {
      let rval2 = [];
      const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
      insideList = insideList || container.includes("@list");
      for (let i = 0;i < element.length; ++i) {
        let e = await api.expand({
          activeCtx,
          activeProperty,
          element: element[i],
          options,
          insideIndex,
          typeScopedContext
        });
        if (insideList && _isArray(e)) {
          e = { "@list": e };
        }
        if (e === null) {
          continue;
        }
        if (_isArray(e)) {
          rval2 = rval2.concat(e);
        } else {
          rval2.push(e);
        }
      }
      return rval2;
    }
    const expandedActiveProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
    const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, "@context");
    typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
    let keys = Object.keys(element).sort();
    let mustRevert = !insideIndex;
    if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes("@context")) {
      for (const key of keys) {
        const expandedProperty = _expandIri(typeScopedContext, key, { vocab: true }, options);
        if (expandedProperty === "@value") {
          mustRevert = false;
          activeCtx = typeScopedContext;
          break;
        }
        if (expandedProperty === "@id" && keys.length === 1) {
          mustRevert = false;
          break;
        }
      }
    }
    if (mustRevert) {
      activeCtx = activeCtx.revertToPreviousContext();
    }
    if (!_isUndefined(propertyScopedCtx)) {
      activeCtx = await _processContext({
        activeCtx,
        localCtx: propertyScopedCtx,
        propagate: true,
        overrideProtected: true,
        options
      });
    }
    if ("@context" in element) {
      activeCtx = await _processContext({ activeCtx, localCtx: element["@context"], options });
    }
    typeScopedContext = activeCtx;
    let typeKey = null;
    for (const key of keys) {
      const expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
      if (expandedProperty === "@type") {
        typeKey = typeKey || key;
        const value = element[key];
        const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
        for (const type of types) {
          const ctx = _getContextValue(typeScopedContext, type, "@context");
          if (!_isUndefined(ctx)) {
            activeCtx = await _processContext({
              activeCtx,
              localCtx: ctx,
              options,
              propagate: false
            });
          }
        }
      }
    }
    let rval = {};
    await _expandObject({
      activeCtx,
      activeProperty,
      expandedActiveProperty,
      element,
      expandedParent: rval,
      options,
      insideList,
      typeKey,
      typeScopedContext
    });
    keys = Object.keys(rval);
    let count = keys.length;
    if ("@value" in rval) {
      if ("@type" in rval && (("@language" in rval) || ("@direction" in rval))) {
        throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not ' + 'contain both "@type" and either "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
      }
      let validCount = count - 1;
      if ("@type" in rval) {
        validCount -= 1;
      }
      if ("@index" in rval) {
        validCount -= 1;
      }
      if ("@language" in rval) {
        validCount -= 1;
      }
      if ("@direction" in rval) {
        validCount -= 1;
      }
      if (validCount !== 0) {
        throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only ' + 'have an "@index" property and either "@type" ' + 'or either or both "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
      }
      const values = rval["@value"] === null ? [] : _asArray(rval["@value"]);
      const types = _getValues(rval, "@type");
      if (_processingMode(activeCtx, 1.1) && types.includes("@json") && types.length === 1) {
      } else if (values.length === 0) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "null @value value",
              level: "warning",
              message: "Dropping null @value value.",
              details: {
                value: rval
              }
            },
            options
          });
        }
        rval = null;
      } else if (!values.every((v) => _isString2(v) || _isEmptyObject(v)) && "@language" in rval) {
        throw new JsonLdError("Invalid JSON-LD syntax; only strings may be language-tagged.", "jsonld.SyntaxError", { code: "invalid language-tagged value", element: rval });
      } else if (!types.every((t) => _isAbsoluteIri(t) && !(_isString2(t) && t.indexOf("_:") === 0) || _isEmptyObject(t))) {
        throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" ' + 'must have an absolute IRI for the value of "@type".', "jsonld.SyntaxError", { code: "invalid typed value", element: rval });
      }
    } else if ("@type" in rval && !_isArray(rval["@type"])) {
      rval["@type"] = [rval["@type"]];
    } else if ("@set" in rval || "@list" in rval) {
      if (count > 1 && !(count === 2 && ("@index" in rval))) {
        throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" ' + 'or "@list", then it can have at most one other property that is ' + '"@index".', "jsonld.SyntaxError", { code: "invalid set or list object", element: rval });
      }
      if ("@set" in rval) {
        rval = rval["@set"];
        keys = Object.keys(rval);
        count = keys.length;
      }
    } else if (count === 1 && "@language" in rval) {
      if (options.eventHandler) {
        _handleEvent({
          event: {
            type: ["JsonLdEvent"],
            code: "object with only @language",
            level: "warning",
            message: "Dropping object with only @language.",
            details: {
              value: rval
            }
          },
          options
        });
      }
      rval = null;
    }
    if (_isObject2(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === "@graph" || (_getContextValue(activeCtx, activeProperty, "@container") || []).includes("@graph"))) {
      rval = _dropUnsafeObject({ value: rval, count, options });
    }
    return rval;
  };
  function _dropUnsafeObject({
    value,
    count,
    options
  }) {
    if (count === 0 || "@value" in value || "@list" in value || count === 1 && "@id" in value) {
      if (options.eventHandler) {
        let code;
        let message;
        if (count === 0) {
          code = "empty object";
          message = "Dropping empty object.";
        } else if ("@value" in value) {
          code = "object with only @value";
          message = "Dropping object with only @value.";
        } else if ("@list" in value) {
          code = "object with only @list";
          message = "Dropping object with only @list.";
        } else if (count === 1 && "@id" in value) {
          code = "object with only @id";
          message = "Dropping object with only @id.";
        }
        _handleEvent({
          event: {
            type: ["JsonLdEvent"],
            code,
            level: "warning",
            message,
            details: {
              value
            }
          },
          options
        });
      }
      return null;
    }
    return value;
  }
  async function _expandObject({
    activeCtx,
    activeProperty,
    expandedActiveProperty,
    element,
    expandedParent,
    options = {},
    insideList,
    typeKey,
    typeScopedContext
  }) {
    const keys = Object.keys(element).sort();
    const nests = [];
    let unexpandedValue;
    const isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], { vocab: true }, {
      ...options,
      typeExpansion: true
    }) === "@json";
    for (const key of keys) {
      let value = element[key];
      let expandedValue;
      if (key === "@context") {
        continue;
      }
      const expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
      if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "invalid property",
              level: "warning",
              message: "Dropping property that did not expand into an " + "absolute IRI or keyword.",
              details: {
                property: key,
                expandedProperty
              }
            },
            options
          });
        }
        continue;
      }
      if (_isKeyword(expandedProperty)) {
        if (expandedActiveProperty === "@reverse") {
          throw new JsonLdError("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse " + "property.", "jsonld.SyntaxError", { code: "invalid reverse property map", value });
        }
        if (expandedProperty in expandedParent && expandedProperty !== "@included" && expandedProperty !== "@type") {
          throw new JsonLdError("Invalid JSON-LD syntax; colliding keywords detected.", "jsonld.SyntaxError", { code: "colliding keywords", keyword: expandedProperty });
        }
      }
      if (expandedProperty === "@id") {
        if (!_isString2(value)) {
          if (!options.isFrame) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', "jsonld.SyntaxError", { code: "invalid @id value", value });
          }
          if (_isObject2(value)) {
            if (!_isEmptyObject(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + "of strings, if framing", "jsonld.SyntaxError", { code: "invalid @id value", value });
            }
          } else if (_isArray(value)) {
            if (!value.every((v) => _isString2(v))) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + "of strings, if framing", "jsonld.SyntaxError", { code: "invalid @id value", value });
            }
          } else {
            throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array ' + "of strings, if framing", "jsonld.SyntaxError", { code: "invalid @id value", value });
          }
        }
        _addValue(expandedParent, "@id", _asArray(value).map((v) => {
          if (_isString2(v)) {
            const ve = _expandIri(activeCtx, v, { base: true }, options);
            if (options.eventHandler) {
              if (ve === null) {
                if (v === null) {
                  _handleEvent({
                    event: {
                      type: ["JsonLdEvent"],
                      code: "null @id value",
                      level: "warning",
                      message: "Null @id found.",
                      details: {
                        id: v
                      }
                    },
                    options
                  });
                } else {
                  _handleEvent({
                    event: {
                      type: ["JsonLdEvent"],
                      code: "reserved @id value",
                      level: "warning",
                      message: "Reserved @id found.",
                      details: {
                        id: v
                      }
                    },
                    options
                  });
                }
              } else if (!_isAbsoluteIri(ve)) {
                _handleEvent({
                  event: {
                    type: ["JsonLdEvent"],
                    code: "relative @id reference",
                    level: "warning",
                    message: "Relative @id reference found.",
                    details: {
                      id: v,
                      expandedId: ve
                    }
                  },
                  options
                });
              }
            }
            return ve;
          }
          return v;
        }), { propertyIsArray: options.isFrame });
        continue;
      }
      if (expandedProperty === "@type") {
        if (_isObject2(value)) {
          value = Object.fromEntries(Object.entries(value).map(([k, v]) => [
            _expandIri(typeScopedContext, k, { vocab: true }),
            _asArray(v).map((vv) => _expandIri(typeScopedContext, vv, { base: true, vocab: true }, { ...options, typeExpansion: true }))
          ]));
        }
        _validateTypeValue(value, options.isFrame);
        _addValue(expandedParent, "@type", _asArray(value).map((v) => {
          if (_isString2(v)) {
            const ve = _expandIri(typeScopedContext, v, { base: true, vocab: true }, { ...options, typeExpansion: true });
            if (ve !== "@json" && !_isAbsoluteIri(ve)) {
              if (options.eventHandler) {
                _handleEvent({
                  event: {
                    type: ["JsonLdEvent"],
                    code: "relative @type reference",
                    level: "warning",
                    message: "Relative @type reference found.",
                    details: {
                      type: v
                    }
                  },
                  options
                });
              }
            }
            return ve;
          }
          return v;
        }), { propertyIsArray: !!options.isFrame });
        continue;
      }
      if (expandedProperty === "@included" && _processingMode(activeCtx, 1.1)) {
        const includedResult = _asArray(await api.expand({
          activeCtx,
          activeProperty,
          element: value,
          options
        }));
        if (!includedResult.every((v) => _isSubject(v))) {
          throw new JsonLdError("Invalid JSON-LD syntax; " + "values of @included must expand to node objects.", "jsonld.SyntaxError", { code: "invalid @included value", value });
        }
        _addValue(expandedParent, "@included", includedResult, { propertyIsArray: true });
        continue;
      }
      if (expandedProperty === "@graph" && !(_isObject2(value) || _isArray(value))) {
        throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an ' + "object or an array.", "jsonld.SyntaxError", { code: "invalid @graph value", value });
      }
      if (expandedProperty === "@value") {
        unexpandedValue = value;
        if (isJsonType && _processingMode(activeCtx, 1.1)) {
          expandedParent["@value"] = value;
        } else {
          _addValue(expandedParent, "@value", value, { propertyIsArray: options.isFrame });
        }
        continue;
      }
      if (expandedProperty === "@language") {
        if (value === null) {
          continue;
        }
        if (!_isString2(value) && !options.isFrame) {
          throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', "jsonld.SyntaxError", { code: "invalid language-tagged string", value });
        }
        value = _asArray(value).map((v) => _isString2(v) ? v.toLowerCase() : v);
        for (const language of value) {
          if (_isString2(language) && !language.match(REGEX_BCP47)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language
                  }
                },
                options
              });
            }
          }
        }
        _addValue(expandedParent, "@language", value, { propertyIsArray: options.isFrame });
        continue;
      }
      if (expandedProperty === "@direction") {
        if (!_isString2(value) && !options.isFrame) {
          throw new JsonLdError('Invalid JSON-LD syntax; "@direction" value must be a string.', "jsonld.SyntaxError", { code: "invalid base direction", value });
        }
        value = _asArray(value);
        for (const dir of value) {
          if (_isString2(dir) && dir !== "ltr" && dir !== "rtl") {
            throw new JsonLdError('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", value });
          }
        }
        _addValue(expandedParent, "@direction", value, { propertyIsArray: options.isFrame });
        continue;
      }
      if (expandedProperty === "@index") {
        if (!_isString2(value)) {
          throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', "jsonld.SyntaxError", { code: "invalid @index value", value });
        }
        _addValue(expandedParent, "@index", value);
        continue;
      }
      if (expandedProperty === "@reverse") {
        if (!_isObject2(value)) {
          throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', "jsonld.SyntaxError", { code: "invalid @reverse value", value });
        }
        expandedValue = await api.expand({
          activeCtx,
          activeProperty: "@reverse",
          element: value,
          options
        });
        if ("@reverse" in expandedValue) {
          for (const property in expandedValue["@reverse"]) {
            _addValue(expandedParent, property, expandedValue["@reverse"][property], { propertyIsArray: true });
          }
        }
        let reverseMap = expandedParent["@reverse"] || null;
        for (const property in expandedValue) {
          if (property === "@reverse") {
            continue;
          }
          if (reverseMap === null) {
            reverseMap = expandedParent["@reverse"] = {};
          }
          _addValue(reverseMap, property, [], { propertyIsArray: true });
          const items = expandedValue[property];
          for (let ii = 0;ii < items.length; ++ii) {
            const item = items[ii];
            if (_isValue(item) || _isList(item)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + "@value or an @list.", "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
            }
            _addValue(reverseMap, property, item, { propertyIsArray: true });
          }
        }
        continue;
      }
      if (expandedProperty === "@nest") {
        nests.push(key);
        continue;
      }
      let termCtx = activeCtx;
      const ctx = _getContextValue(activeCtx, key, "@context");
      if (!_isUndefined(ctx)) {
        termCtx = await _processContext({
          activeCtx,
          localCtx: ctx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      const container = _getContextValue(activeCtx, key, "@container") || [];
      if (container.includes("@language") && _isObject2(value)) {
        const direction = _getContextValue(termCtx, key, "@direction");
        expandedValue = _expandLanguageMap(termCtx, value, direction, options);
      } else if (container.includes("@index") && _isObject2(value)) {
        const asGraph = container.includes("@graph");
        const indexKey = _getContextValue(termCtx, key, "@index") || "@index";
        const propertyIndex = indexKey !== "@index" && _expandIri(activeCtx, indexKey, { vocab: true }, options);
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx,
          options,
          activeProperty: key,
          value,
          asGraph,
          indexKey,
          propertyIndex
        });
      } else if (container.includes("@id") && _isObject2(value)) {
        const asGraph = container.includes("@graph");
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx,
          options,
          activeProperty: key,
          value,
          asGraph,
          indexKey: "@id"
        });
      } else if (container.includes("@type") && _isObject2(value)) {
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx.revertToPreviousContext(),
          options,
          activeProperty: key,
          value,
          asGraph: false,
          indexKey: "@type"
        });
      } else {
        const isList = expandedProperty === "@list";
        if (isList || expandedProperty === "@set") {
          let nextActiveProperty = activeProperty;
          if (isList && expandedActiveProperty === "@graph") {
            nextActiveProperty = null;
          }
          expandedValue = await api.expand({
            activeCtx: termCtx,
            activeProperty: nextActiveProperty,
            element: value,
            options,
            insideList: isList
          });
        } else if (_getContextValue(activeCtx, key, "@type") === "@json") {
          expandedValue = {
            "@type": "@json",
            "@value": value
          };
        } else {
          expandedValue = await api.expand({
            activeCtx: termCtx,
            activeProperty: key,
            element: value,
            options,
            insideList: false
          });
        }
      }
      if (expandedValue === null && expandedProperty !== "@value") {
        continue;
      }
      if (expandedProperty !== "@list" && !_isList(expandedValue) && container.includes("@list")) {
        expandedValue = { "@list": _asArray(expandedValue) };
      }
      if (container.includes("@graph") && !container.some((key2) => key2 === "@id" || key2 === "@index")) {
        expandedValue = _asArray(expandedValue);
        if (!options.isFrame) {
          expandedValue = expandedValue.filter((v) => {
            const count = Object.keys(v).length;
            return _dropUnsafeObject({ value: v, count, options }) !== null;
          });
        }
        if (expandedValue.length === 0) {
          continue;
        }
        expandedValue = expandedValue.map((v) => ({ "@graph": _asArray(v) }));
      }
      if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {
        const reverseMap = expandedParent["@reverse"] = expandedParent["@reverse"] || {};
        expandedValue = _asArray(expandedValue);
        for (let ii = 0;ii < expandedValue.length; ++ii) {
          const item = expandedValue[ii];
          if (_isValue(item) || _isList(item)) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + "@value or an @list.", "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
          }
          _addValue(reverseMap, expandedProperty, item, { propertyIsArray: true });
        }
        continue;
      }
      _addValue(expandedParent, expandedProperty, expandedValue, {
        propertyIsArray: true
      });
    }
    if ("@value" in expandedParent) {
      if (expandedParent["@type"] === "@json" && _processingMode(activeCtx, 1.1)) {
      } else if ((_isObject2(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {
        throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an ' + "object or an array.", "jsonld.SyntaxError", { code: "invalid value object value", value: unexpandedValue });
      }
    }
    for (const key of nests) {
      const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
      for (const nv of nestedValues) {
        if (!_isObject2(nv) || Object.keys(nv).some((k) => _expandIri(activeCtx, k, { vocab: true }, options) === "@value")) {
          throw new JsonLdError("Invalid JSON-LD syntax; nested value must be a node object.", "jsonld.SyntaxError", { code: "invalid @nest value", value: nv });
        }
        await _expandObject({
          activeCtx,
          activeProperty,
          expandedActiveProperty,
          element: nv,
          expandedParent,
          options,
          insideList,
          typeScopedContext,
          typeKey
        });
      }
    }
  }
  function _expandValue({ activeCtx, activeProperty, value, options }) {
    if (value === null || value === undefined) {
      return null;
    }
    const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
    if (expandedProperty === "@id") {
      return _expandIri(activeCtx, value, { base: true }, options);
    } else if (expandedProperty === "@type") {
      return _expandIri(activeCtx, value, { vocab: true, base: true }, { ...options, typeExpansion: true });
    }
    const type = _getContextValue(activeCtx, activeProperty, "@type");
    if ((type === "@id" || expandedProperty === "@graph") && _isString2(value)) {
      const expandedValue = _expandIri(activeCtx, value, { base: true }, options);
      if (expandedValue === null && value.match(REGEX_KEYWORD)) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @id value",
              level: "warning",
              message: "Reserved @id found.",
              details: {
                id: activeProperty
              }
            },
            options
          });
        }
      }
      return { "@id": expandedValue };
    }
    if (type === "@vocab" && _isString2(value)) {
      return {
        "@id": _expandIri(activeCtx, value, { vocab: true, base: true }, options)
      };
    }
    if (_isKeyword(expandedProperty)) {
      return value;
    }
    const rval = {};
    if (type && !["@id", "@vocab", "@none"].includes(type)) {
      rval["@type"] = type;
    } else if (_isString2(value)) {
      const language = _getContextValue(activeCtx, activeProperty, "@language");
      if (language !== null) {
        rval["@language"] = language;
      }
      const direction = _getContextValue(activeCtx, activeProperty, "@direction");
      if (direction !== null) {
        rval["@direction"] = direction;
      }
    }
    if (!["boolean", "number", "string"].includes(typeof value)) {
      value = value.toString();
    }
    rval["@value"] = value;
    return rval;
  }
  function _expandLanguageMap(activeCtx, languageMap, direction, options) {
    const rval = [];
    const keys = Object.keys(languageMap).sort();
    for (const key of keys) {
      const expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
      let val = languageMap[key];
      if (!_isArray(val)) {
        val = [val];
      }
      for (const item of val) {
        if (item === null) {
          continue;
        }
        if (!_isString2(item)) {
          throw new JsonLdError("Invalid JSON-LD syntax; language map values must be strings.", "jsonld.SyntaxError", { code: "invalid language map value", languageMap });
        }
        const val2 = { "@value": item };
        if (expandedKey !== "@none") {
          if (!key.match(REGEX_BCP47)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language: key
                  }
                },
                options
              });
            }
          }
          val2["@language"] = key.toLowerCase();
        }
        if (direction) {
          val2["@direction"] = direction;
        }
        rval.push(val2);
      }
    }
    return rval;
  }
  async function _expandIndexMap({
    activeCtx,
    options,
    activeProperty,
    value,
    asGraph,
    indexKey,
    propertyIndex
  }) {
    const rval = [];
    const keys = Object.keys(value).sort();
    const isTypeIndex = indexKey === "@type";
    for (let key of keys) {
      if (isTypeIndex) {
        const ctx = _getContextValue(activeCtx, key, "@context");
        if (!_isUndefined(ctx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: ctx,
            propagate: false,
            options
          });
        }
      }
      let val = value[key];
      if (!_isArray(val)) {
        val = [val];
      }
      val = await api.expand({
        activeCtx,
        activeProperty,
        element: val,
        options,
        insideList: false,
        insideIndex: true
      });
      let expandedKey;
      if (propertyIndex) {
        if (key === "@none") {
          expandedKey = "@none";
        } else {
          expandedKey = _expandValue({ activeCtx, activeProperty: indexKey, value: key, options });
        }
      } else {
        expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
      }
      if (indexKey === "@id") {
        key = _expandIri(activeCtx, key, { base: true }, options);
      } else if (isTypeIndex) {
        key = expandedKey;
      }
      for (let item of val) {
        if (asGraph && !_isGraph(item)) {
          item = { "@graph": [item] };
        }
        if (indexKey === "@type") {
          if (expandedKey === "@none") {
          } else if (item["@type"]) {
            item["@type"] = [key].concat(item["@type"]);
          } else {
            item["@type"] = [key];
          }
        } else if (_isValue(item) && !["@language", "@type", "@index"].includes(indexKey)) {
          throw new JsonLdError("Invalid JSON-LD syntax; Attempt to add illegal key to value " + `object: "${indexKey}".`, "jsonld.SyntaxError", { code: "invalid value object", value: item });
        } else if (propertyIndex) {
          if (expandedKey !== "@none") {
            _addValue(item, propertyIndex, expandedKey, {
              propertyIsArray: true,
              prependValue: true
            });
          }
        } else if (expandedKey !== "@none" && !(indexKey in item)) {
          item[indexKey] = key;
        }
        rval.push(item);
      }
    }
    return rval;
  }
});

// node_modules/jsonld/lib/nodeMap.js
var require_nodeMap = __commonJS((exports, module) => {
  var { isKeyword } = require_context();
  var graphTypes = require_graphTypes();
  var types = require_types();
  var util = require_util();
  var JsonLdError = require_JsonLdError();
  var api = {};
  module.exports = api;
  api.createMergedNodeMap = (input, options) => {
    options = options || {};
    const issuer = options.issuer || new util.IdentifierIssuer("_:b");
    const graphs = { "@default": {} };
    api.createNodeMap(input, graphs, "@default", issuer);
    return api.mergeNodeMaps(graphs);
  };
  api.createNodeMap = (input, graphs, graph, issuer, name, list) => {
    if (types.isArray(input)) {
      for (const node of input) {
        api.createNodeMap(node, graphs, graph, issuer, undefined, list);
      }
      return;
    }
    if (!types.isObject(input)) {
      if (list) {
        list.push(input);
      }
      return;
    }
    if (graphTypes.isValue(input)) {
      if ("@type" in input) {
        let type = input["@type"];
        if (type.indexOf("_:") === 0) {
          input["@type"] = type = issuer.getId(type);
        }
      }
      if (list) {
        list.push(input);
      }
      return;
    } else if (list && graphTypes.isList(input)) {
      const _list = [];
      api.createNodeMap(input["@list"], graphs, graph, issuer, name, _list);
      list.push({ "@list": _list });
      return;
    }
    if ("@type" in input) {
      const types2 = input["@type"];
      for (const type of types2) {
        if (type.indexOf("_:") === 0) {
          issuer.getId(type);
        }
      }
    }
    if (types.isUndefined(name)) {
      name = graphTypes.isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"];
    }
    if (list) {
      list.push({ "@id": name });
    }
    const subjects = graphs[graph];
    const subject = subjects[name] = subjects[name] || {};
    subject["@id"] = name;
    const properties = Object.keys(input).sort();
    for (let property of properties) {
      if (property === "@id") {
        continue;
      }
      if (property === "@reverse") {
        const referencedNode = { "@id": name };
        const reverseMap = input["@reverse"];
        for (const reverseProperty in reverseMap) {
          const items = reverseMap[reverseProperty];
          for (const item of items) {
            let itemName = item["@id"];
            if (graphTypes.isBlankNode(item)) {
              itemName = issuer.getId(itemName);
            }
            api.createNodeMap(item, graphs, graph, issuer, itemName);
            util.addValue(subjects[itemName], reverseProperty, referencedNode, { propertyIsArray: true, allowDuplicate: false });
          }
        }
        continue;
      }
      if (property === "@graph") {
        if (!(name in graphs)) {
          graphs[name] = {};
        }
        api.createNodeMap(input[property], graphs, name, issuer);
        continue;
      }
      if (property === "@included") {
        api.createNodeMap(input[property], graphs, graph, issuer);
        continue;
      }
      if (property !== "@type" && isKeyword(property)) {
        if (property === "@index" && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
          throw new JsonLdError("Invalid JSON-LD syntax; conflicting @index property detected.", "jsonld.SyntaxError", { code: "conflicting indexes", subject });
        }
        subject[property] = input[property];
        continue;
      }
      const objects = input[property];
      if (property.indexOf("_:") === 0) {
        property = issuer.getId(property);
      }
      if (objects.length === 0) {
        util.addValue(subject, property, [], { propertyIsArray: true });
        continue;
      }
      for (let o of objects) {
        if (property === "@type") {
          o = o.indexOf("_:") === 0 ? issuer.getId(o) : o;
        }
        if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
          if ("@id" in o && !o["@id"]) {
            continue;
          }
          const id = graphTypes.isBlankNode(o) ? issuer.getId(o["@id"]) : o["@id"];
          util.addValue(subject, property, { "@id": id }, { propertyIsArray: true, allowDuplicate: false });
          api.createNodeMap(o, graphs, graph, issuer, id);
        } else if (graphTypes.isValue(o)) {
          util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
        } else if (graphTypes.isList(o)) {
          const _list = [];
          api.createNodeMap(o["@list"], graphs, graph, issuer, name, _list);
          o = { "@list": _list };
          util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
        } else {
          api.createNodeMap(o, graphs, graph, issuer, name);
          util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
        }
      }
    }
  };
  api.mergeNodeMapGraphs = (graphs) => {
    const merged = {};
    for (const name of Object.keys(graphs).sort()) {
      for (const id of Object.keys(graphs[name]).sort()) {
        const node = graphs[name][id];
        if (!(id in merged)) {
          merged[id] = { "@id": id };
        }
        const mergedNode = merged[id];
        for (const property of Object.keys(node).sort()) {
          if (isKeyword(property) && property !== "@type") {
            mergedNode[property] = util.clone(node[property]);
          } else {
            for (const value of node[property]) {
              util.addValue(mergedNode, property, util.clone(value), { propertyIsArray: true, allowDuplicate: false });
            }
          }
        }
      }
    }
    return merged;
  };
  api.mergeNodeMaps = (graphs) => {
    const defaultGraph = graphs["@default"];
    const graphNames = Object.keys(graphs).sort();
    for (const graphName of graphNames) {
      if (graphName === "@default") {
        continue;
      }
      const nodeMap = graphs[graphName];
      let subject = defaultGraph[graphName];
      if (!subject) {
        defaultGraph[graphName] = subject = {
          "@id": graphName,
          "@graph": []
        };
      } else if (!("@graph" in subject)) {
        subject["@graph"] = [];
      }
      const graph = subject["@graph"];
      for (const id of Object.keys(nodeMap).sort()) {
        const node = nodeMap[id];
        if (!graphTypes.isSubjectReference(node)) {
          graph.push(node);
        }
      }
    }
    return defaultGraph;
  };
});

// node_modules/jsonld/lib/flatten.js
var require_flatten = __commonJS((exports, module) => {
  var {
    isSubjectReference: _isSubjectReference
  } = require_graphTypes();
  var {
    createMergedNodeMap: _createMergedNodeMap
  } = require_nodeMap();
  var api = {};
  module.exports = api;
  api.flatten = (input) => {
    const defaultGraph = _createMergedNodeMap(input);
    const flattened = [];
    const keys = Object.keys(defaultGraph).sort();
    for (let ki = 0;ki < keys.length; ++ki) {
      const node = defaultGraph[keys[ki]];
      if (!_isSubjectReference(node)) {
        flattened.push(node);
      }
    }
    return flattened;
  };
});

// node_modules/jsonld/lib/fromRdf.js
var require_fromRdf = __commonJS((exports, module) => {
  var JsonLdError = require_JsonLdError();
  var graphTypes = require_graphTypes();
  var types = require_types();
  var {
    REGEX_BCP47,
    addValue: _addValue
  } = require_util();
  var {
    handleEvent: _handleEvent
  } = require_events();
  var {
    RDF_LIST,
    RDF_FIRST,
    RDF_REST,
    RDF_NIL,
    RDF_TYPE,
    RDF_JSON_LITERAL,
    XSD_BOOLEAN,
    XSD_DOUBLE,
    XSD_INTEGER,
    XSD_STRING
  } = require_constants();
  var api = {};
  module.exports = api;
  api.fromRDF = async (dataset, options) => {
    const {
      useRdfType = false,
      useNativeTypes = false,
      rdfDirection = null
    } = options;
    const defaultGraph = {};
    const graphMap = { "@default": defaultGraph };
    const referencedOnce = {};
    if (rdfDirection) {
      if (rdfDirection === "compound-literal") {
        throw new JsonLdError("Unsupported rdfDirection value.", "jsonld.InvalidRdfDirection", { value: rdfDirection });
      } else if (rdfDirection !== "i18n-datatype") {
        throw new JsonLdError("Unknown rdfDirection value.", "jsonld.InvalidRdfDirection", { value: rdfDirection });
      }
    }
    for (const quad of dataset) {
      const name = quad.graph.termType === "DefaultGraph" ? "@default" : quad.graph.value;
      if (!(name in graphMap)) {
        graphMap[name] = {};
      }
      if (name !== "@default" && !(name in defaultGraph)) {
        defaultGraph[name] = { "@id": name };
      }
      const nodeMap = graphMap[name];
      const s = quad.subject.value;
      const p = quad.predicate.value;
      const o = quad.object;
      if (!(s in nodeMap)) {
        nodeMap[s] = { "@id": s };
      }
      const node = nodeMap[s];
      const objectIsNode = o.termType.endsWith("Node");
      if (objectIsNode && !(o.value in nodeMap)) {
        nodeMap[o.value] = { "@id": o.value };
      }
      if (p === RDF_TYPE && !useRdfType && objectIsNode) {
        _addValue(node, "@type", o.value, { propertyIsArray: true });
        continue;
      }
      const value = _RDFToObject(o, useNativeTypes, rdfDirection, options);
      _addValue(node, p, value, { propertyIsArray: true });
      if (objectIsNode) {
        if (o.value === RDF_NIL) {
          const object = nodeMap[o.value];
          if (!("usages" in object)) {
            object.usages = [];
          }
          object.usages.push({
            node,
            property: p,
            value
          });
        } else if (o.value in referencedOnce) {
          referencedOnce[o.value] = false;
        } else {
          referencedOnce[o.value] = {
            node,
            property: p,
            value
          };
        }
      }
    }
    for (const name in graphMap) {
      const graphObject = graphMap[name];
      if (!(RDF_NIL in graphObject)) {
        continue;
      }
      const nil = graphObject[RDF_NIL];
      if (!nil.usages) {
        continue;
      }
      for (let usage of nil.usages) {
        let node = usage.node;
        let property = usage.property;
        let head = usage.value;
        const list = [];
        const listNodes = [];
        let nodeKeyCount = Object.keys(node).length;
        while (property === RDF_REST && types.isObject(referencedOnce[node["@id"]]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node["@type"]) && node["@type"].length === 1 && node["@type"][0] === RDF_LIST)) {
          list.push(node[RDF_FIRST][0]);
          listNodes.push(node["@id"]);
          usage = referencedOnce[node["@id"]];
          node = usage.node;
          property = usage.property;
          head = usage.value;
          nodeKeyCount = Object.keys(node).length;
          if (!graphTypes.isBlankNode(node)) {
            break;
          }
        }
        delete head["@id"];
        head["@list"] = list.reverse();
        for (const listNode of listNodes) {
          delete graphObject[listNode];
        }
      }
      delete nil.usages;
    }
    const result = [];
    const subjects = Object.keys(defaultGraph).sort();
    for (const subject of subjects) {
      const node = defaultGraph[subject];
      if (subject in graphMap) {
        const graph = node["@graph"] = [];
        const graphObject = graphMap[subject];
        const graphSubjects = Object.keys(graphObject).sort();
        for (const graphSubject of graphSubjects) {
          const node2 = graphObject[graphSubject];
          if (!graphTypes.isSubjectReference(node2)) {
            graph.push(node2);
          }
        }
      }
      if (!graphTypes.isSubjectReference(node)) {
        result.push(node);
      }
    }
    return result;
  };
  function _RDFToObject(o, useNativeTypes, rdfDirection, options) {
    if (o.termType.endsWith("Node")) {
      return { "@id": o.value };
    }
    const rval = { "@value": o.value };
    if (o.language) {
      if (!o.language.match(REGEX_BCP47)) {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "invalid @language value",
              level: "warning",
              message: "@language value must be valid BCP47.",
              details: {
                language: o.language
              }
            },
            options
          });
        }
      }
      rval["@language"] = o.language;
    } else {
      let type = o.datatype.value;
      if (!type) {
        type = XSD_STRING;
      }
      if (type === RDF_JSON_LITERAL) {
        type = "@json";
        try {
          rval["@value"] = JSON.parse(rval["@value"]);
        } catch (e) {
          throw new JsonLdError("JSON literal could not be parsed.", "jsonld.InvalidJsonLiteral", { code: "invalid JSON literal", value: rval["@value"], cause: e });
        }
      }
      if (useNativeTypes) {
        if (type === XSD_BOOLEAN) {
          if (rval["@value"] === "true") {
            rval["@value"] = true;
          } else if (rval["@value"] === "false") {
            rval["@value"] = false;
          }
        } else if (types.isNumeric(rval["@value"])) {
          if (type === XSD_INTEGER) {
            const i = parseInt(rval["@value"], 10);
            if (i.toFixed(0) === rval["@value"]) {
              rval["@value"] = i;
            }
          } else if (type === XSD_DOUBLE) {
            rval["@value"] = parseFloat(rval["@value"]);
          }
        }
        if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
          rval["@type"] = type;
        }
      } else if (rdfDirection === "i18n-datatype" && type.startsWith("https://www.w3.org/ns/i18n#")) {
        const [, language, direction] = type.split(/[#_]/);
        if (language.length > 0) {
          rval["@language"] = language;
          if (!language.match(REGEX_BCP47)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language
                  }
                },
                options
              });
            }
          }
        }
        rval["@direction"] = direction;
      } else if (type !== XSD_STRING) {
        rval["@type"] = type;
      }
    }
    return rval;
  }
});

// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS((exports, module) => {
  module.exports = function serialize(object) {
    if (object === null || typeof object !== "object" || object.toJSON != null) {
      return JSON.stringify(object);
    }
    if (Array.isArray(object)) {
      return "[" + object.reduce((t, cv, ci) => {
        const comma = ci === 0 ? "" : ",";
        const value = cv === undefined || typeof cv === "symbol" ? null : cv;
        return t + comma + serialize(value);
      }, "") + "]";
    }
    return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
      if (object[cv] === undefined || typeof object[cv] === "symbol") {
        return t;
      }
      const comma = t.length === 0 ? "" : ",";
      return t + comma + serialize(cv) + ":" + serialize(object[cv]);
    }, "") + "}";
  };
});

// node_modules/jsonld/lib/toRdf.js
var require_toRdf = __commonJS((exports, module) => {
  var { createNodeMap } = require_nodeMap();
  var { isKeyword } = require_context();
  var graphTypes = require_graphTypes();
  var jsonCanonicalize = require_canonicalize();
  var JsonLdError = require_JsonLdError();
  var types = require_types();
  var util = require_util();
  var {
    handleEvent: _handleEvent
  } = require_events();
  var {
    RDF_FIRST,
    RDF_REST,
    RDF_NIL,
    RDF_TYPE,
    RDF_JSON_LITERAL,
    RDF_LANGSTRING,
    XSD_BOOLEAN,
    XSD_DOUBLE,
    XSD_INTEGER,
    XSD_STRING
  } = require_constants();
  var {
    isAbsolute: _isAbsoluteIri
  } = require_url();
  var api = {};
  module.exports = api;
  api.toRDF = (input, options) => {
    const issuer = new util.IdentifierIssuer("_:b");
    const nodeMap = { "@default": {} };
    createNodeMap(input, nodeMap, "@default", issuer);
    const dataset = [];
    const graphNames = Object.keys(nodeMap).sort();
    for (const graphName of graphNames) {
      let graphTerm;
      if (graphName === "@default") {
        graphTerm = { termType: "DefaultGraph", value: "" };
      } else if (_isAbsoluteIri(graphName)) {
        if (graphName.startsWith("_:")) {
          graphTerm = { termType: "BlankNode" };
        } else {
          graphTerm = { termType: "NamedNode" };
        }
        graphTerm.value = graphName;
      } else {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "relative graph reference",
              level: "warning",
              message: "Relative graph reference found.",
              details: {
                graph: graphName
              }
            },
            options
          });
        }
        continue;
      }
      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
    }
    return dataset;
  };
  function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
    const ids = Object.keys(graph).sort();
    for (const id of ids) {
      const node = graph[id];
      const properties = Object.keys(node).sort();
      for (let property of properties) {
        const items = node[property];
        if (property === "@type") {
          property = RDF_TYPE;
        } else if (isKeyword(property)) {
          continue;
        }
        for (const item of items) {
          const subject = {
            termType: id.startsWith("_:") ? "BlankNode" : "NamedNode",
            value: id
          };
          if (!_isAbsoluteIri(id)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative subject reference",
                  level: "warning",
                  message: "Relative subject reference found.",
                  details: {
                    subject: id
                  }
                },
                options
              });
            }
            continue;
          }
          const predicate = {
            termType: property.startsWith("_:") ? "BlankNode" : "NamedNode",
            value: property
          };
          if (!_isAbsoluteIri(property)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative predicate reference",
                  level: "warning",
                  message: "Relative predicate reference found.",
                  details: {
                    predicate: property
                  }
                },
                options
              });
            }
            continue;
          }
          if (predicate.termType === "BlankNode" && !options.produceGeneralizedRdf) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "blank node predicate",
                  level: "warning",
                  message: "Dropping blank node predicate.",
                  details: {
                    property: issuer.getOldIds().find((key) => issuer.getId(key) === property)
                  }
                },
                options
              });
            }
            continue;
          }
          const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection, options);
          if (object) {
            dataset.push({
              subject,
              predicate,
              object,
              graph: graphTerm
            });
          }
        }
      }
    }
  }
  function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {
    const first = { termType: "NamedNode", value: RDF_FIRST };
    const rest = { termType: "NamedNode", value: RDF_REST };
    const nil = { termType: "NamedNode", value: RDF_NIL };
    const last = list.pop();
    const result = last ? { termType: "BlankNode", value: issuer.getId() } : nil;
    let subject = result;
    for (const item of list) {
      const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection, options);
      const next = { termType: "BlankNode", value: issuer.getId() };
      dataset.push({
        subject,
        predicate: first,
        object,
        graph: graphTerm
      });
      dataset.push({
        subject,
        predicate: rest,
        object: next,
        graph: graphTerm
      });
      subject = next;
    }
    if (last) {
      const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection, options);
      dataset.push({
        subject,
        predicate: first,
        object,
        graph: graphTerm
      });
      dataset.push({
        subject,
        predicate: rest,
        object: nil,
        graph: graphTerm
      });
    }
    return result;
  }
  function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection, options) {
    const object = {};
    if (graphTypes.isValue(item)) {
      object.termType = "Literal";
      object.value = undefined;
      object.datatype = {
        termType: "NamedNode"
      };
      let value = item["@value"];
      const datatype = item["@type"] || null;
      if (datatype === "@json") {
        object.value = jsonCanonicalize(value);
        object.datatype.value = RDF_JSON_LITERAL;
      } else if (types.isBoolean(value)) {
        object.value = value.toString();
        object.datatype.value = datatype || XSD_BOOLEAN;
      } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
        if (!types.isDouble(value)) {
          value = parseFloat(value);
        }
        object.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
        object.datatype.value = datatype || XSD_DOUBLE;
      } else if (types.isNumber(value)) {
        object.value = value.toFixed(0);
        object.datatype.value = datatype || XSD_INTEGER;
      } else if ("@direction" in item && rdfDirection === "i18n-datatype") {
        const language = (item["@language"] || "").toLowerCase();
        const direction = item["@direction"];
        const datatype2 = `https://www.w3.org/ns/i18n#${language}_${direction}`;
        object.datatype.value = datatype2;
        object.value = value;
      } else if ("@direction" in item && rdfDirection === "compound-literal") {
        throw new JsonLdError("Unsupported rdfDirection value.", "jsonld.InvalidRdfDirection", { value: rdfDirection });
      } else if ("@direction" in item && rdfDirection) {
        throw new JsonLdError("Unknown rdfDirection value.", "jsonld.InvalidRdfDirection", { value: rdfDirection });
      } else if ("@language" in item) {
        if ("@direction" in item && !rdfDirection) {
          if (options.eventHandler) {
            _handleEvent({
              event: {
                type: ["JsonLdEvent"],
                code: "rdfDirection not set",
                level: "warning",
                message: "rdfDirection not set for @direction.",
                details: {
                  object: object.value
                }
              },
              options
            });
          }
        }
        object.value = value;
        object.datatype.value = datatype || RDF_LANGSTRING;
        object.language = item["@language"];
      } else {
        if ("@direction" in item && !rdfDirection) {
          if (options.eventHandler) {
            _handleEvent({
              event: {
                type: ["JsonLdEvent"],
                code: "rdfDirection not set",
                level: "warning",
                message: "rdfDirection not set for @direction.",
                details: {
                  object: object.value
                }
              },
              options
            });
          }
        }
        object.value = value;
        object.datatype.value = datatype || XSD_STRING;
      }
    } else if (graphTypes.isList(item)) {
      const _list = _listToRDF(item["@list"], issuer, dataset, graphTerm, rdfDirection, options);
      object.termType = _list.termType;
      object.value = _list.value;
    } else {
      const id = types.isObject(item) ? item["@id"] : item;
      object.termType = id.startsWith("_:") ? "BlankNode" : "NamedNode";
      object.value = id;
    }
    if (object.termType === "NamedNode" && !_isAbsoluteIri(object.value)) {
      if (options.eventHandler) {
        _handleEvent({
          event: {
            type: ["JsonLdEvent"],
            code: "relative object reference",
            level: "warning",
            message: "Relative object reference found.",
            details: {
              object: object.value
            }
          },
          options
        });
      }
      return null;
    }
    return object;
  }
});

// node_modules/jsonld/lib/frame.js
var require_frame = __commonJS((exports, module) => {
  var { isKeyword } = require_context();
  var graphTypes = require_graphTypes();
  var types = require_types();
  var util = require_util();
  var url = require_url();
  var JsonLdError = require_JsonLdError();
  var {
    createNodeMap: _createNodeMap,
    mergeNodeMapGraphs: _mergeNodeMapGraphs
  } = require_nodeMap();
  var api = {};
  module.exports = api;
  api.frameMergedOrDefault = (input, frame, options) => {
    const state = {
      options,
      embedded: false,
      graph: "@default",
      graphMap: { "@default": {} },
      subjectStack: [],
      link: {},
      bnodeMap: {}
    };
    const issuer = new util.IdentifierIssuer("_:b");
    _createNodeMap(input, state.graphMap, "@default", issuer);
    if (options.merged) {
      state.graphMap["@merged"] = _mergeNodeMapGraphs(state.graphMap);
      state.graph = "@merged";
    }
    state.subjects = state.graphMap[state.graph];
    const framed = [];
    api.frame(state, Object.keys(state.subjects).sort(), frame, framed);
    if (options.pruneBlankNodeIdentifiers) {
      options.bnodesToClear = Object.keys(state.bnodeMap).filter((id) => state.bnodeMap[id].length === 1);
    }
    options.link = {};
    return _cleanupPreserve(framed, options);
  };
  api.frame = (state, subjects, frame, parent, property = null) => {
    _validateFrame(frame);
    frame = frame[0];
    const options = state.options;
    const flags = {
      embed: _getFrameFlag(frame, options, "embed"),
      explicit: _getFrameFlag(frame, options, "explicit"),
      requireAll: _getFrameFlag(frame, options, "requireAll")
    };
    if (!state.link.hasOwnProperty(state.graph)) {
      state.link[state.graph] = {};
    }
    const link = state.link[state.graph];
    const matches = _filterSubjects(state, subjects, frame, flags);
    const ids = Object.keys(matches).sort();
    for (const id of ids) {
      const subject = matches[id];
      if (property === null) {
        state.uniqueEmbeds = { [state.graph]: {} };
      } else {
        state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
      }
      if (flags.embed === "@link" && id in link) {
        _addFrameOutput(parent, property, link[id]);
        continue;
      }
      const output = { "@id": id };
      if (id.indexOf("_:") === 0) {
        util.addValue(state.bnodeMap, id, output, { propertyIsArray: true });
      }
      link[id] = output;
      if ((flags.embed === "@first" || flags.embed === "@last") && state.is11) {
        throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame });
      }
      if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        continue;
      }
      if (state.embedded && (flags.embed === "@never" || _createsCircularReference(subject, state.graph, state.subjectStack))) {
        _addFrameOutput(parent, property, output);
        continue;
      }
      if (state.embedded && (flags.embed == "@first" || flags.embed == "@once") && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
        _addFrameOutput(parent, property, output);
        continue;
      }
      if (flags.embed === "@last") {
        if (id in state.uniqueEmbeds[state.graph]) {
          _removeEmbed(state, id);
        }
      }
      state.uniqueEmbeds[state.graph][id] = { parent, property };
      state.subjectStack.push({ subject, graph: state.graph });
      if (id in state.graphMap) {
        let recurse = false;
        let subframe = null;
        if (!("@graph" in frame)) {
          recurse = state.graph !== "@merged";
          subframe = {};
        } else {
          subframe = frame["@graph"][0];
          recurse = !(id === "@merged" || id === "@default");
          if (!types.isObject(subframe)) {
            subframe = {};
          }
        }
        if (recurse) {
          api.frame({ ...state, graph: id, embedded: false }, Object.keys(state.graphMap[id]).sort(), [subframe], output, "@graph");
        }
      }
      if ("@included" in frame) {
        api.frame({ ...state, embedded: false }, subjects, frame["@included"], output, "@included");
      }
      for (const prop of Object.keys(subject).sort()) {
        if (isKeyword(prop)) {
          output[prop] = util.clone(subject[prop]);
          if (prop === "@type") {
            for (const type of subject["@type"]) {
              if (type.indexOf("_:") === 0) {
                util.addValue(state.bnodeMap, type, output, { propertyIsArray: true });
              }
            }
          }
          continue;
        }
        if (flags.explicit && !(prop in frame)) {
          continue;
        }
        for (const o of subject[prop]) {
          const subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags);
          if (graphTypes.isList(o)) {
            const subframe2 = frame[prop] && frame[prop][0] && frame[prop][0]["@list"] ? frame[prop][0]["@list"] : _createImplicitFrame(flags);
            const list = { "@list": [] };
            _addFrameOutput(output, prop, list);
            const src = o["@list"];
            for (const oo of src) {
              if (graphTypes.isSubjectReference(oo)) {
                api.frame({ ...state, embedded: true }, [oo["@id"]], subframe2, list, "@list");
              } else {
                _addFrameOutput(list, "@list", util.clone(oo));
              }
            }
          } else if (graphTypes.isSubjectReference(o)) {
            api.frame({ ...state, embedded: true }, [o["@id"]], subframe, output, prop);
          } else if (_valueMatch(subframe[0], o)) {
            _addFrameOutput(output, prop, util.clone(o));
          }
        }
      }
      for (const prop of Object.keys(frame).sort()) {
        if (prop === "@type") {
          if (!types.isObject(frame[prop][0]) || !("@default" in frame[prop][0])) {
            continue;
          }
        } else if (isKeyword(prop)) {
          continue;
        }
        const next = frame[prop][0] || {};
        const omitDefaultOn = _getFrameFlag(next, options, "omitDefault");
        if (!omitDefaultOn && !(prop in output)) {
          let preserve = "@null";
          if ("@default" in next) {
            preserve = util.clone(next["@default"]);
          }
          if (!types.isArray(preserve)) {
            preserve = [preserve];
          }
          output[prop] = [{ "@preserve": preserve }];
        }
      }
      for (const reverseProp of Object.keys(frame["@reverse"] || {}).sort()) {
        const subframe = frame["@reverse"][reverseProp];
        for (const subject2 of Object.keys(state.subjects)) {
          const nodeValues = util.getValues(state.subjects[subject2], reverseProp);
          if (nodeValues.some((v) => v["@id"] === id)) {
            output["@reverse"] = output["@reverse"] || {};
            util.addValue(output["@reverse"], reverseProp, [], { propertyIsArray: true });
            api.frame({ ...state, embedded: true }, [subject2], subframe, output["@reverse"][reverseProp], property);
          }
        }
      }
      _addFrameOutput(parent, property, output);
      state.subjectStack.pop();
    }
  };
  api.cleanupNull = (input, options) => {
    if (types.isArray(input)) {
      const noNulls = input.map((v) => api.cleanupNull(v, options));
      return noNulls.filter((v) => v);
    }
    if (input === "@null") {
      return null;
    }
    if (types.isObject(input)) {
      if ("@id" in input) {
        const id = input["@id"];
        if (options.link.hasOwnProperty(id)) {
          const idx = options.link[id].indexOf(input);
          if (idx !== -1) {
            return options.link[id][idx];
          }
          options.link[id].push(input);
        } else {
          options.link[id] = [input];
        }
      }
      for (const key in input) {
        input[key] = api.cleanupNull(input[key], options);
      }
    }
    return input;
  };
  function _createImplicitFrame(flags) {
    const frame = {};
    for (const key in flags) {
      if (flags[key] !== undefined) {
        frame["@" + key] = [flags[key]];
      }
    }
    return [frame];
  }
  function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
    for (let i = subjectStack.length - 1;i >= 0; --i) {
      const subject = subjectStack[i];
      if (subject.graph === graph && subject.subject["@id"] === subjectToEmbed["@id"]) {
        return true;
      }
    }
    return false;
  }
  function _getFrameFlag(frame, options, name) {
    const flag = "@" + name;
    let rval = flag in frame ? frame[flag][0] : options[name];
    if (name === "embed") {
      if (rval === true) {
        rval = "@once";
      } else if (rval === false) {
        rval = "@never";
      } else if (rval !== "@always" && rval !== "@never" && rval !== "@link" && rval !== "@first" && rval !== "@last" && rval !== "@once") {
        throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame });
      }
    }
    return rval;
  }
  function _validateFrame(frame) {
    if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
      throw new JsonLdError("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.", "jsonld.SyntaxError", { frame });
    }
    if ("@id" in frame[0]) {
      for (const id of util.asArray(frame[0]["@id"])) {
        if (!(types.isObject(id) || url.isAbsolute(id)) || types.isString(id) && id.indexOf("_:") === 0) {
          throw new JsonLdError("Invalid JSON-LD syntax; invalid @id in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame });
        }
      }
    }
    if ("@type" in frame[0]) {
      for (const type of util.asArray(frame[0]["@type"])) {
        if (!(types.isObject(type) || url.isAbsolute(type) || type === "@json") || types.isString(type) && type.indexOf("_:") === 0) {
          throw new JsonLdError("Invalid JSON-LD syntax; invalid @type in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame });
        }
      }
    }
  }
  function _filterSubjects(state, subjects, frame, flags) {
    const rval = {};
    for (const id of subjects) {
      const subject = state.graphMap[state.graph][id];
      if (_filterSubject(state, subject, frame, flags)) {
        rval[id] = subject;
      }
    }
    return rval;
  }
  function _filterSubject(state, subject, frame, flags) {
    let wildcard = true;
    let matchesSome = false;
    for (const key in frame) {
      let matchThis = false;
      const nodeValues = util.getValues(subject, key);
      const isEmpty = util.getValues(frame, key).length === 0;
      if (key === "@id") {
        if (types.isEmptyObject(frame["@id"][0] || {})) {
          matchThis = true;
        } else if (frame["@id"].length >= 0) {
          matchThis = frame["@id"].includes(nodeValues[0]);
        }
        if (!flags.requireAll) {
          return matchThis;
        }
      } else if (key === "@type") {
        wildcard = false;
        if (isEmpty) {
          if (nodeValues.length > 0) {
            return false;
          }
          matchThis = true;
        } else if (frame["@type"].length === 1 && types.isEmptyObject(frame["@type"][0])) {
          matchThis = nodeValues.length > 0;
        } else {
          for (const type of frame["@type"]) {
            if (types.isObject(type) && "@default" in type) {
              matchThis = true;
            } else {
              matchThis = matchThis || nodeValues.some((tt) => tt === type);
            }
          }
        }
        if (!flags.requireAll) {
          return matchThis;
        }
      } else if (isKeyword(key)) {
        continue;
      } else {
        const thisFrame = util.getValues(frame, key)[0];
        let hasDefault = false;
        if (thisFrame) {
          _validateFrame([thisFrame]);
          hasDefault = "@default" in thisFrame;
        }
        wildcard = false;
        if (nodeValues.length === 0 && hasDefault) {
          continue;
        }
        if (nodeValues.length > 0 && isEmpty) {
          return false;
        }
        if (thisFrame === undefined) {
          if (nodeValues.length > 0) {
            return false;
          }
          matchThis = true;
        } else {
          if (graphTypes.isList(thisFrame)) {
            const listValue = thisFrame["@list"][0];
            if (graphTypes.isList(nodeValues[0])) {
              const nodeListValues = nodeValues[0]["@list"];
              if (graphTypes.isValue(listValue)) {
                matchThis = nodeListValues.some((lv) => _valueMatch(listValue, lv));
              } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                matchThis = nodeListValues.some((lv) => _nodeMatch(state, listValue, lv, flags));
              }
            }
          } else if (graphTypes.isValue(thisFrame)) {
            matchThis = nodeValues.some((nv) => _valueMatch(thisFrame, nv));
          } else if (graphTypes.isSubjectReference(thisFrame)) {
            matchThis = nodeValues.some((nv) => _nodeMatch(state, thisFrame, nv, flags));
          } else if (types.isObject(thisFrame)) {
            matchThis = nodeValues.length > 0;
          } else {
            matchThis = false;
          }
        }
      }
      if (!matchThis && flags.requireAll) {
        return false;
      }
      matchesSome = matchesSome || matchThis;
    }
    return wildcard || matchesSome;
  }
  function _removeEmbed(state, id) {
    const embeds = state.uniqueEmbeds[state.graph];
    const embed = embeds[id];
    const parent = embed.parent;
    const property = embed.property;
    const subject = { "@id": id };
    if (types.isArray(parent)) {
      for (let i = 0;i < parent.length; ++i) {
        if (util.compareValues(parent[i], subject)) {
          parent[i] = subject;
          break;
        }
      }
    } else {
      const useArray = types.isArray(parent[property]);
      util.removeValue(parent, property, subject, { propertyIsArray: useArray });
      util.addValue(parent, property, subject, { propertyIsArray: useArray });
    }
    const removeDependents = (id2) => {
      const ids = Object.keys(embeds);
      for (const next of ids) {
        if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent["@id"] === id2) {
          delete embeds[next];
          removeDependents(next);
        }
      }
    };
    removeDependents(id);
  }
  function _cleanupPreserve(input, options) {
    if (types.isArray(input)) {
      return input.map((value) => _cleanupPreserve(value, options));
    }
    if (types.isObject(input)) {
      if ("@preserve" in input) {
        return input["@preserve"][0];
      }
      if (graphTypes.isValue(input)) {
        return input;
      }
      if (graphTypes.isList(input)) {
        input["@list"] = _cleanupPreserve(input["@list"], options);
        return input;
      }
      if ("@id" in input) {
        const id = input["@id"];
        if (options.link.hasOwnProperty(id)) {
          const idx = options.link[id].indexOf(input);
          if (idx !== -1) {
            return options.link[id][idx];
          }
          options.link[id].push(input);
        } else {
          options.link[id] = [input];
        }
      }
      for (const prop in input) {
        if (prop === "@id" && options.bnodesToClear.includes(input[prop])) {
          delete input["@id"];
          continue;
        }
        input[prop] = _cleanupPreserve(input[prop], options);
      }
    }
    return input;
  }
  function _addFrameOutput(parent, property, output) {
    if (types.isObject(parent)) {
      util.addValue(parent, property, output, { propertyIsArray: true });
    } else {
      parent.push(output);
    }
  }
  function _nodeMatch(state, pattern, value, flags) {
    if (!("@id" in value)) {
      return false;
    }
    const nodeObject = state.subjects[value["@id"]];
    return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
  }
  function _valueMatch(pattern, value) {
    const v1 = value["@value"];
    const t1 = value["@type"];
    const l1 = value["@language"];
    const v2 = pattern["@value"] ? types.isArray(pattern["@value"]) ? pattern["@value"] : [pattern["@value"]] : [];
    const t2 = pattern["@type"] ? types.isArray(pattern["@type"]) ? pattern["@type"] : [pattern["@type"]] : [];
    const l2 = pattern["@language"] ? types.isArray(pattern["@language"]) ? pattern["@language"] : [pattern["@language"]] : [];
    if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
      return true;
    }
    if (!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {
      return false;
    }
    if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
      return false;
    }
    if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
      return false;
    }
    return true;
  }
});

// node_modules/jsonld/lib/compact.js
var require_compact = __commonJS((exports, module) => {
  var JsonLdError = require_JsonLdError();
  var {
    isArray: _isArray,
    isObject: _isObject2,
    isString: _isString2,
    isUndefined: _isUndefined
  } = require_types();
  var {
    isList: _isList,
    isValue: _isValue,
    isGraph: _isGraph,
    isSimpleGraph: _isSimpleGraph,
    isSubjectReference: _isSubjectReference
  } = require_graphTypes();
  var {
    expandIri: _expandIri,
    getContextValue: _getContextValue,
    isKeyword: _isKeyword,
    process: _processContext,
    processingMode: _processingMode
  } = require_context();
  var {
    removeBase: _removeBase,
    prependBase: _prependBase
  } = require_url();
  var {
    REGEX_KEYWORD,
    addValue: _addValue,
    asArray: _asArray,
    compareShortestLeast: _compareShortestLeast
  } = require_util();
  var api = {};
  module.exports = api;
  api.compact = async ({
    activeCtx,
    activeProperty = null,
    element,
    options = {}
  }) => {
    if (_isArray(element)) {
      let rval = [];
      for (let i = 0;i < element.length; ++i) {
        const compacted = await api.compact({
          activeCtx,
          activeProperty,
          element: element[i],
          options
        });
        if (compacted === null) {
          continue;
        }
        rval.push(compacted);
      }
      if (options.compactArrays && rval.length === 1) {
        const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
        if (container.length === 0) {
          rval = rval[0];
        }
      }
      return rval;
    }
    const ctx = _getContextValue(activeCtx, activeProperty, "@context");
    if (!_isUndefined(ctx)) {
      activeCtx = await _processContext({
        activeCtx,
        localCtx: ctx,
        propagate: true,
        overrideProtected: true,
        options
      });
    }
    if (_isObject2(element)) {
      if (options.link && "@id" in element && options.link.hasOwnProperty(element["@id"])) {
        const linked = options.link[element["@id"]];
        for (let i = 0;i < linked.length; ++i) {
          if (linked[i].expanded === element) {
            return linked[i].compacted;
          }
        }
      }
      if (_isValue(element) || _isSubjectReference(element)) {
        const rval2 = api.compactValue({ activeCtx, activeProperty, value: element, options });
        if (options.link && _isSubjectReference(element)) {
          if (!options.link.hasOwnProperty(element["@id"])) {
            options.link[element["@id"]] = [];
          }
          options.link[element["@id"]].push({ expanded: element, compacted: rval2 });
        }
        return rval2;
      }
      if (_isList(element)) {
        const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
        if (container.includes("@list")) {
          return api.compact({
            activeCtx,
            activeProperty,
            element: element["@list"],
            options
          });
        }
      }
      const insideReverse = activeProperty === "@reverse";
      const rval = {};
      const inputCtx = activeCtx;
      if (!_isValue(element) && !_isSubjectReference(element)) {
        activeCtx = activeCtx.revertToPreviousContext();
      }
      const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, "@context");
      if (!_isUndefined(propertyScopedCtx)) {
        activeCtx = await _processContext({
          activeCtx,
          localCtx: propertyScopedCtx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      if (options.link && "@id" in element) {
        if (!options.link.hasOwnProperty(element["@id"])) {
          options.link[element["@id"]] = [];
        }
        options.link[element["@id"]].push({ expanded: element, compacted: rval });
      }
      let types = element["@type"] || [];
      if (types.length > 1) {
        types = Array.from(types).sort();
      }
      const typeContext = activeCtx;
      for (const type of types) {
        const compactedType = api.compactIri({ activeCtx: typeContext, iri: type, relativeTo: { vocab: true } });
        const ctx2 = _getContextValue(inputCtx, compactedType, "@context");
        if (!_isUndefined(ctx2)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: ctx2,
            options,
            propagate: false
          });
        }
      }
      const keys = Object.keys(element).sort();
      for (const expandedProperty of keys) {
        const expandedValue = element[expandedProperty];
        if (expandedProperty === "@id") {
          let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
            activeCtx,
            iri: expandedIri,
            relativeTo: { vocab: false },
            base: options.base
          }));
          if (compactedValue.length === 1) {
            compactedValue = compactedValue[0];
          }
          const alias = api.compactIri({ activeCtx, iri: "@id", relativeTo: { vocab: true } });
          rval[alias] = compactedValue;
          continue;
        }
        if (expandedProperty === "@type") {
          let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
            activeCtx: inputCtx,
            iri: expandedIri,
            relativeTo: { vocab: true }
          }));
          if (compactedValue.length === 1) {
            compactedValue = compactedValue[0];
          }
          const alias = api.compactIri({ activeCtx, iri: "@type", relativeTo: { vocab: true } });
          const container = _getContextValue(activeCtx, alias, "@container") || [];
          const typeAsSet = container.includes("@set") && _processingMode(activeCtx, 1.1);
          const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;
          _addValue(rval, alias, compactedValue, { propertyIsArray: isArray });
          continue;
        }
        if (expandedProperty === "@reverse") {
          const compactedValue = await api.compact({
            activeCtx,
            activeProperty: "@reverse",
            element: expandedValue,
            options
          });
          for (const compactedProperty in compactedValue) {
            if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
              const value = compactedValue[compactedProperty];
              const container = _getContextValue(activeCtx, compactedProperty, "@container") || [];
              const useArray = container.includes("@set") || !options.compactArrays;
              _addValue(rval, compactedProperty, value, { propertyIsArray: useArray });
              delete compactedValue[compactedProperty];
            }
          }
          if (Object.keys(compactedValue).length > 0) {
            const alias = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              relativeTo: { vocab: true }
            });
            _addValue(rval, alias, compactedValue);
          }
          continue;
        }
        if (expandedProperty === "@preserve") {
          const compactedValue = await api.compact({
            activeCtx,
            activeProperty,
            element: expandedValue,
            options
          });
          if (!(_isArray(compactedValue) && compactedValue.length === 0)) {
            _addValue(rval, expandedProperty, compactedValue);
          }
          continue;
        }
        if (expandedProperty === "@index") {
          const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
          if (container.includes("@index")) {
            continue;
          }
          const alias = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            relativeTo: { vocab: true }
          });
          _addValue(rval, alias, expandedValue);
          continue;
        }
        if (expandedProperty !== "@graph" && expandedProperty !== "@list" && expandedProperty !== "@included" && _isKeyword(expandedProperty)) {
          const alias = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            relativeTo: { vocab: true }
          });
          _addValue(rval, alias, expandedValue);
          continue;
        }
        if (!_isArray(expandedValue)) {
          throw new JsonLdError("JSON-LD expansion error; expanded value must be an array.", "jsonld.SyntaxError");
        }
        if (expandedValue.length === 0) {
          const itemActiveProperty = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            value: expandedValue,
            relativeTo: { vocab: true },
            reverse: insideReverse
          });
          const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
          let nestResult = rval;
          if (nestProperty) {
            _checkNestProperty(activeCtx, nestProperty, options);
            if (!_isObject2(rval[nestProperty])) {
              rval[nestProperty] = {};
            }
            nestResult = rval[nestProperty];
          }
          _addValue(nestResult, itemActiveProperty, expandedValue, {
            propertyIsArray: true
          });
        }
        for (const expandedItem of expandedValue) {
          const itemActiveProperty = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            value: expandedItem,
            relativeTo: { vocab: true },
            reverse: insideReverse
          });
          const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
          let nestResult = rval;
          if (nestProperty) {
            _checkNestProperty(activeCtx, nestProperty, options);
            if (!_isObject2(rval[nestProperty])) {
              rval[nestProperty] = {};
            }
            nestResult = rval[nestProperty];
          }
          const container = _getContextValue(activeCtx, itemActiveProperty, "@container") || [];
          const isGraph = _isGraph(expandedItem);
          const isList = _isList(expandedItem);
          let inner;
          if (isList) {
            inner = expandedItem["@list"];
          } else if (isGraph) {
            inner = expandedItem["@graph"];
          }
          let compactedItem = await api.compact({
            activeCtx,
            activeProperty: itemActiveProperty,
            element: isList || isGraph ? inner : expandedItem,
            options
          });
          if (isList) {
            if (!_isArray(compactedItem)) {
              compactedItem = [compactedItem];
            }
            if (!container.includes("@list")) {
              compactedItem = {
                [api.compactIri({
                  activeCtx,
                  iri: "@list",
                  relativeTo: { vocab: true }
                })]: compactedItem
              };
              if ("@index" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@index",
                  relativeTo: { vocab: true }
                })] = expandedItem["@index"];
              }
            } else {
              _addValue(nestResult, itemActiveProperty, compactedItem, {
                valueIsArray: true,
                allowDuplicate: true
              });
              continue;
            }
          }
          if (isGraph) {
            if (container.includes("@graph") && (container.includes("@id") || container.includes("@index") && _isSimpleGraph(expandedItem))) {
              let mapObject;
              if (nestResult.hasOwnProperty(itemActiveProperty)) {
                mapObject = nestResult[itemActiveProperty];
              } else {
                nestResult[itemActiveProperty] = mapObject = {};
              }
              const key = (container.includes("@id") ? expandedItem["@id"] : expandedItem["@index"]) || api.compactIri({
                activeCtx,
                iri: "@none",
                relativeTo: { vocab: true }
              });
              _addValue(mapObject, key, compactedItem, {
                propertyIsArray: !options.compactArrays || container.includes("@set")
              });
            } else if (container.includes("@graph") && _isSimpleGraph(expandedItem)) {
              if (_isArray(compactedItem) && compactedItem.length > 1) {
                compactedItem = { "@included": compactedItem };
              }
              _addValue(nestResult, itemActiveProperty, compactedItem, {
                propertyIsArray: !options.compactArrays || container.includes("@set")
              });
            } else {
              if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                compactedItem = compactedItem[0];
              }
              compactedItem = {
                [api.compactIri({
                  activeCtx,
                  iri: "@graph",
                  relativeTo: { vocab: true }
                })]: compactedItem
              };
              if ("@id" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@id",
                  relativeTo: { vocab: true }
                })] = expandedItem["@id"];
              }
              if ("@index" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@index",
                  relativeTo: { vocab: true }
                })] = expandedItem["@index"];
              }
              _addValue(nestResult, itemActiveProperty, compactedItem, {
                propertyIsArray: !options.compactArrays || container.includes("@set")
              });
            }
          } else if (container.includes("@language") || container.includes("@index") || container.includes("@id") || container.includes("@type")) {
            let mapObject;
            if (nestResult.hasOwnProperty(itemActiveProperty)) {
              mapObject = nestResult[itemActiveProperty];
            } else {
              nestResult[itemActiveProperty] = mapObject = {};
            }
            let key;
            if (container.includes("@language")) {
              if (_isValue(compactedItem)) {
                compactedItem = compactedItem["@value"];
              }
              key = expandedItem["@language"];
            } else if (container.includes("@index")) {
              const indexKey = _getContextValue(activeCtx, itemActiveProperty, "@index") || "@index";
              const containerKey = api.compactIri({ activeCtx, iri: indexKey, relativeTo: { vocab: true } });
              if (indexKey === "@index") {
                key = expandedItem["@index"];
                delete compactedItem[containerKey];
              } else {
                let others;
                [key, ...others] = _asArray(compactedItem[indexKey] || []);
                if (!_isString2(key)) {
                  key = null;
                } else {
                  switch (others.length) {
                    case 0:
                      delete compactedItem[indexKey];
                      break;
                    case 1:
                      compactedItem[indexKey] = others[0];
                      break;
                    default:
                      compactedItem[indexKey] = others;
                      break;
                  }
                }
              }
            } else if (container.includes("@id")) {
              const idKey = api.compactIri({
                activeCtx,
                iri: "@id",
                relativeTo: { vocab: true }
              });
              key = compactedItem[idKey];
              delete compactedItem[idKey];
            } else if (container.includes("@type")) {
              const typeKey = api.compactIri({
                activeCtx,
                iri: "@type",
                relativeTo: { vocab: true }
              });
              let types2;
              [key, ...types2] = _asArray(compactedItem[typeKey] || []);
              switch (types2.length) {
                case 0:
                  delete compactedItem[typeKey];
                  break;
                case 1:
                  compactedItem[typeKey] = types2[0];
                  break;
                default:
                  compactedItem[typeKey] = types2;
                  break;
              }
              if (Object.keys(compactedItem).length === 1 && "@id" in expandedItem) {
                compactedItem = await api.compact({
                  activeCtx,
                  activeProperty: itemActiveProperty,
                  element: { "@id": expandedItem["@id"] },
                  options
                });
              }
            }
            if (!key) {
              key = api.compactIri({
                activeCtx,
                iri: "@none",
                relativeTo: { vocab: true }
              });
            }
            _addValue(mapObject, key, compactedItem, {
              propertyIsArray: container.includes("@set")
            });
          } else {
            const isArray = !options.compactArrays || container.includes("@set") || container.includes("@list") || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === "@list" || expandedProperty === "@graph";
            _addValue(nestResult, itemActiveProperty, compactedItem, { propertyIsArray: isArray });
          }
        }
      }
      return rval;
    }
    return element;
  };
  api.compactIri = ({
    activeCtx,
    iri,
    value = null,
    relativeTo = { vocab: false },
    reverse = false,
    base = null
  }) => {
    if (iri === null) {
      return iri;
    }
    if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
      activeCtx = activeCtx.previousContext;
    }
    const inverseCtx = activeCtx.getInverse();
    if (_isKeyword(iri) && iri in inverseCtx && "@none" in inverseCtx[iri] && "@type" in inverseCtx[iri]["@none"] && "@none" in inverseCtx[iri]["@none"]["@type"]) {
      return inverseCtx[iri]["@none"]["@type"]["@none"];
    }
    if (relativeTo.vocab && iri in inverseCtx) {
      const defaultLanguage = activeCtx["@language"] || "@none";
      const containers = [];
      if (_isObject2(value) && "@index" in value && !("@graph" in value)) {
        containers.push("@index", "@index@set");
      }
      if (_isObject2(value) && "@preserve" in value) {
        value = value["@preserve"][0];
      }
      if (_isGraph(value)) {
        if ("@index" in value) {
          containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
        }
        if ("@id" in value) {
          containers.push("@graph@id", "@graph@id@set");
        }
        containers.push("@graph", "@graph@set", "@set");
        if (!("@index" in value)) {
          containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
        }
        if (!("@id" in value)) {
          containers.push("@graph@id", "@graph@id@set");
        }
      } else if (_isObject2(value) && !_isValue(value)) {
        containers.push("@id", "@id@set", "@type", "@set@type");
      }
      let typeOrLanguage = "@language";
      let typeOrLanguageValue = "@null";
      if (reverse) {
        typeOrLanguage = "@type";
        typeOrLanguageValue = "@reverse";
        containers.push("@set");
      } else if (_isList(value)) {
        if (!("@index" in value)) {
          containers.push("@list");
        }
        const list = value["@list"];
        if (list.length === 0) {
          typeOrLanguage = "@any";
          typeOrLanguageValue = "@none";
        } else {
          let commonLanguage = list.length === 0 ? defaultLanguage : null;
          let commonType = null;
          for (let i = 0;i < list.length; ++i) {
            const item = list[i];
            let itemLanguage = "@none";
            let itemType = "@none";
            if (_isValue(item)) {
              if ("@direction" in item) {
                const lang = (item["@language"] || "").toLowerCase();
                const dir = item["@direction"];
                itemLanguage = `${lang}_${dir}`;
              } else if ("@language" in item) {
                itemLanguage = item["@language"].toLowerCase();
              } else if ("@type" in item) {
                itemType = item["@type"];
              } else {
                itemLanguage = "@null";
              }
            } else {
              itemType = "@id";
            }
            if (commonLanguage === null) {
              commonLanguage = itemLanguage;
            } else if (itemLanguage !== commonLanguage && _isValue(item)) {
              commonLanguage = "@none";
            }
            if (commonType === null) {
              commonType = itemType;
            } else if (itemType !== commonType) {
              commonType = "@none";
            }
            if (commonLanguage === "@none" && commonType === "@none") {
              break;
            }
          }
          commonLanguage = commonLanguage || "@none";
          commonType = commonType || "@none";
          if (commonType !== "@none") {
            typeOrLanguage = "@type";
            typeOrLanguageValue = commonType;
          } else {
            typeOrLanguageValue = commonLanguage;
          }
        }
      } else {
        if (_isValue(value)) {
          if ("@language" in value && !("@index" in value)) {
            containers.push("@language", "@language@set");
            typeOrLanguageValue = value["@language"];
            const dir = value["@direction"];
            if (dir) {
              typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;
            }
          } else if ("@direction" in value && !("@index" in value)) {
            typeOrLanguageValue = `_${value["@direction"]}`;
          } else if ("@type" in value) {
            typeOrLanguage = "@type";
            typeOrLanguageValue = value["@type"];
          }
        } else {
          typeOrLanguage = "@type";
          typeOrLanguageValue = "@id";
        }
        containers.push("@set");
      }
      containers.push("@none");
      if (_isObject2(value) && !("@index" in value)) {
        containers.push("@index", "@index@set");
      }
      if (_isValue(value) && Object.keys(value).length === 1) {
        containers.push("@language", "@language@set");
      }
      const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);
      if (term !== null) {
        return term;
      }
    }
    if (relativeTo.vocab) {
      if ("@vocab" in activeCtx) {
        const vocab = activeCtx["@vocab"];
        if (iri.indexOf(vocab) === 0 && iri !== vocab) {
          const suffix = iri.substr(vocab.length);
          if (!activeCtx.mappings.has(suffix)) {
            return suffix;
          }
        }
      }
    }
    let choice = null;
    const partialMatches = [];
    let iriMap = activeCtx.fastCurieMap;
    const maxPartialLength = iri.length - 1;
    for (let i = 0;i < maxPartialLength && iri[i] in iriMap; ++i) {
      iriMap = iriMap[iri[i]];
      if ("" in iriMap) {
        partialMatches.push(iriMap[""][0]);
      }
    }
    for (let i = partialMatches.length - 1;i >= 0; --i) {
      const entry = partialMatches[i];
      const terms = entry.terms;
      for (const term of terms) {
        const curie = term + ":" + iri.substr(entry.iri.length);
        const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)["@id"] === iri);
        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
          choice = curie;
        }
      }
    }
    if (choice !== null) {
      return choice;
    }
    for (const [term, td] of activeCtx.mappings) {
      if (td && td._prefix && iri.startsWith(term + ":")) {
        throw new JsonLdError(`Absolute IRI "${iri}" confused with prefix "${term}".`, "jsonld.SyntaxError", { code: "IRI confused with prefix", context: activeCtx });
      }
    }
    if (!relativeTo.vocab) {
      if ("@base" in activeCtx) {
        if (!activeCtx["@base"]) {
          return iri;
        } else {
          const _iri = _removeBase(_prependBase(base, activeCtx["@base"]), iri);
          return REGEX_KEYWORD.test(_iri) ? `./${_iri}` : _iri;
        }
      } else {
        return _removeBase(base, iri);
      }
    }
    return iri;
  };
  api.compactValue = ({ activeCtx, activeProperty, value, options }) => {
    if (_isValue(value)) {
      const type2 = _getContextValue(activeCtx, activeProperty, "@type");
      const language = _getContextValue(activeCtx, activeProperty, "@language");
      const direction = _getContextValue(activeCtx, activeProperty, "@direction");
      const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
      const preserveIndex = "@index" in value && !container.includes("@index");
      if (!preserveIndex && type2 !== "@none") {
        if (value["@type"] === type2) {
          return value["@value"];
        }
        if ("@language" in value && value["@language"] === language && "@direction" in value && value["@direction"] === direction) {
          return value["@value"];
        }
        if ("@language" in value && value["@language"] === language) {
          return value["@value"];
        }
        if ("@direction" in value && value["@direction"] === direction) {
          return value["@value"];
        }
      }
      const keyCount = Object.keys(value).length;
      const isValueOnlyKey = keyCount === 1 || keyCount === 2 && "@index" in value && !preserveIndex;
      const hasDefaultLanguage = "@language" in activeCtx;
      const isValueString = _isString2(value["@value"]);
      const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)["@language"] === null;
      if (isValueOnlyKey && type2 !== "@none" && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
        return value["@value"];
      }
      const rval = {};
      if (preserveIndex) {
        rval[api.compactIri({
          activeCtx,
          iri: "@index",
          relativeTo: { vocab: true }
        })] = value["@index"];
      }
      if ("@type" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@type",
          relativeTo: { vocab: true }
        })] = api.compactIri({ activeCtx, iri: value["@type"], relativeTo: { vocab: true } });
      } else if ("@language" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@language",
          relativeTo: { vocab: true }
        })] = value["@language"];
      }
      if ("@direction" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@direction",
          relativeTo: { vocab: true }
        })] = value["@direction"];
      }
      rval[api.compactIri({
        activeCtx,
        iri: "@value",
        relativeTo: { vocab: true }
      })] = value["@value"];
      return rval;
    }
    const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
    const type = _getContextValue(activeCtx, activeProperty, "@type");
    const compacted = api.compactIri({
      activeCtx,
      iri: value["@id"],
      relativeTo: { vocab: type === "@vocab" },
      base: options.base
    });
    if (type === "@id" || type === "@vocab" || expandedProperty === "@graph") {
      return compacted;
    }
    return {
      [api.compactIri({
        activeCtx,
        iri: "@id",
        relativeTo: { vocab: true }
      })]: compacted
    };
  };
  function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
    if (typeOrLanguageValue === null) {
      typeOrLanguageValue = "@null";
    }
    const prefs = [];
    if ((typeOrLanguageValue === "@id" || typeOrLanguageValue === "@reverse") && _isObject2(value) && "@id" in value) {
      if (typeOrLanguageValue === "@reverse") {
        prefs.push("@reverse");
      }
      const term = api.compactIri({ activeCtx, iri: value["@id"], relativeTo: { vocab: true } });
      if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)["@id"] === value["@id"]) {
        prefs.push.apply(prefs, ["@vocab", "@id"]);
      } else {
        prefs.push.apply(prefs, ["@id", "@vocab"]);
      }
    } else {
      prefs.push(typeOrLanguageValue);
      const langDir = prefs.find((el) => el.includes("_"));
      if (langDir) {
        prefs.push(langDir.replace(/^[^_]+_/, "_"));
      }
    }
    prefs.push("@none");
    const containerMap = activeCtx.inverse[iri];
    for (const container of containers) {
      if (!(container in containerMap)) {
        continue;
      }
      const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
      for (const pref of prefs) {
        if (!(pref in typeOrLanguageValueMap)) {
          continue;
        }
        return typeOrLanguageValueMap[pref];
      }
    }
    return null;
  }
  function _checkNestProperty(activeCtx, nestProperty, options) {
    if (_expandIri(activeCtx, nestProperty, { vocab: true }, options) !== "@nest") {
      throw new JsonLdError("JSON-LD compact error; nested property must have an @nest value " + "resolving to @nest.", "jsonld.SyntaxError", { code: "invalid @nest value" });
    }
  }
});

// node_modules/jsonld/lib/JsonLdProcessor.js
var require_JsonLdProcessor = __commonJS((exports, module) => {
  module.exports = (jsonld) => {
    class JsonLdProcessor {
      toString() {
        return "[object JsonLdProcessor]";
      }
    }
    Object.defineProperty(JsonLdProcessor, "prototype", {
      writable: false,
      enumerable: false
    });
    Object.defineProperty(JsonLdProcessor.prototype, "constructor", {
      writable: true,
      enumerable: false,
      configurable: true,
      value: JsonLdProcessor
    });
    JsonLdProcessor.compact = function(input, ctx) {
      if (arguments.length < 2) {
        return Promise.reject(new TypeError("Could not compact, too few arguments."));
      }
      return jsonld.compact(input, ctx);
    };
    JsonLdProcessor.expand = function(input) {
      if (arguments.length < 1) {
        return Promise.reject(new TypeError("Could not expand, too few arguments."));
      }
      return jsonld.expand(input);
    };
    JsonLdProcessor.flatten = function(input) {
      if (arguments.length < 1) {
        return Promise.reject(new TypeError("Could not flatten, too few arguments."));
      }
      return jsonld.flatten(input);
    };
    return JsonLdProcessor;
  };
});

// node_modules/jsonld/lib/jsonld.js
var require_jsonld = __commonJS((exports, module) => {
  var canonize = require_lib();
  var platform = require_platform_browser();
  var util = require_util();
  var ContextResolver = require_ContextResolver();
  var IdentifierIssuer = util.IdentifierIssuer;
  var JsonLdError = require_JsonLdError();
  var LRU = require_lru_cache();
  var NQuads = require_NQuads2();
  var { expand: _expand } = require_expand();
  var { flatten: _flatten } = require_flatten();
  var { fromRDF: _fromRDF } = require_fromRdf();
  var { toRDF: _toRDF } = require_toRdf();
  var {
    frameMergedOrDefault: _frameMergedOrDefault,
    cleanupNull: _cleanupNull
  } = require_frame();
  var {
    isArray: _isArray,
    isObject: _isObject2,
    isString: _isString2
  } = require_types();
  var {
    isSubjectReference: _isSubjectReference
  } = require_graphTypes();
  var {
    expandIri: _expandIri,
    getInitialContext: _getInitialContext,
    process: _processContext,
    processingMode: _processingMode
  } = require_context();
  var {
    compact: _compact,
    compactIri: _compactIri
  } = require_compact();
  var {
    createNodeMap: _createNodeMap,
    createMergedNodeMap: _createMergedNodeMap,
    mergeNodeMaps: _mergeNodeMaps
  } = require_nodeMap();
  var {
    logEventHandler: _logEventHandler,
    logWarningEventHandler: _logWarningEventHandler,
    safeEventHandler: _safeEventHandler,
    setDefaultEventHandler: _setDefaultEventHandler,
    setupEventHandler: _setupEventHandler,
    strictEventHandler: _strictEventHandler,
    unhandledEventHandler: _unhandledEventHandler
  } = require_events();
  var wrapper = function(jsonld) {
    const _rdfParsers = {};
    const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;
    const _resolvedContextCache = new LRU({ max: RESOLVED_CONTEXT_CACHE_MAX_SIZE });
    jsonld.compact = async function(input, ctx, options) {
      if (arguments.length < 2) {
        throw new TypeError("Could not compact, too few arguments.");
      }
      if (ctx === null) {
        throw new JsonLdError("The compaction context must not be null.", "jsonld.CompactError", { code: "invalid local context" });
      }
      if (input === null) {
        return null;
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : "",
        compactArrays: true,
        compactToRelative: true,
        graph: false,
        skipExpansion: false,
        link: false,
        issuer: new IdentifierIssuer("_:b"),
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      if (options.link) {
        options.skipExpansion = true;
      }
      if (!options.compactToRelative) {
        delete options.base;
      }
      let expanded;
      if (options.skipExpansion) {
        expanded = input;
      } else {
        expanded = await jsonld.expand(input, options);
      }
      const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options);
      let compacted = await _compact({
        activeCtx,
        element: expanded,
        options
      });
      if (options.compactArrays && !options.graph && _isArray(compacted)) {
        if (compacted.length === 1) {
          compacted = compacted[0];
        } else if (compacted.length === 0) {
          compacted = {};
        }
      } else if (options.graph && _isObject2(compacted)) {
        compacted = [compacted];
      }
      if (_isObject2(ctx) && "@context" in ctx) {
        ctx = ctx["@context"];
      }
      ctx = util.clone(ctx);
      if (!_isArray(ctx)) {
        ctx = [ctx];
      }
      const tmp = ctx;
      ctx = [];
      for (let i = 0;i < tmp.length; ++i) {
        if (!_isObject2(tmp[i]) || Object.keys(tmp[i]).length > 0) {
          ctx.push(tmp[i]);
        }
      }
      const hasContext = ctx.length > 0;
      if (ctx.length === 1) {
        ctx = ctx[0];
      }
      if (_isArray(compacted)) {
        const graphAlias = _compactIri({
          activeCtx,
          iri: "@graph",
          relativeTo: { vocab: true }
        });
        const graph = compacted;
        compacted = {};
        if (hasContext) {
          compacted["@context"] = ctx;
        }
        compacted[graphAlias] = graph;
      } else if (_isObject2(compacted) && hasContext) {
        const graph = compacted;
        compacted = { "@context": ctx };
        for (const key in graph) {
          compacted[key] = graph[key];
        }
      }
      return compacted;
    };
    jsonld.expand = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not expand, too few arguments.");
      }
      options = _setDefaults(options, {
        keepFreeFloatingNodes: false,
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      const toResolve = {};
      const contextsToProcess = [];
      if ("expandContext" in options) {
        const expandContext = util.clone(options.expandContext);
        if (_isObject2(expandContext) && "@context" in expandContext) {
          toResolve.expandContext = expandContext;
        } else {
          toResolve.expandContext = { "@context": expandContext };
        }
        contextsToProcess.push(toResolve.expandContext);
      }
      let defaultBase;
      if (!_isString2(input)) {
        toResolve.input = util.clone(input);
      } else {
        const remoteDoc = await jsonld.get(input, options);
        defaultBase = remoteDoc.documentUrl;
        toResolve.input = remoteDoc.document;
        if (remoteDoc.contextUrl) {
          toResolve.remoteContext = { "@context": remoteDoc.contextUrl };
          contextsToProcess.push(toResolve.remoteContext);
        }
      }
      if (!("base" in options)) {
        options.base = defaultBase || "";
      }
      let activeCtx = _getInitialContext(options);
      for (const localCtx of contextsToProcess) {
        activeCtx = await _processContext({ activeCtx, localCtx, options });
      }
      let expanded = await _expand({
        activeCtx,
        element: toResolve.input,
        options
      });
      if (_isObject2(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
        expanded = expanded["@graph"];
      } else if (expanded === null) {
        expanded = [];
      }
      if (!_isArray(expanded)) {
        expanded = [expanded];
      }
      return expanded;
    };
    jsonld.flatten = async function(input, ctx, options) {
      if (arguments.length < 1) {
        return new TypeError("Could not flatten, too few arguments.");
      }
      if (typeof ctx === "function") {
        ctx = null;
      } else {
        ctx = ctx || null;
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : "",
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      const expanded = await jsonld.expand(input, options);
      const flattened = _flatten(expanded);
      if (ctx === null) {
        return flattened;
      }
      options.graph = true;
      options.skipExpansion = true;
      const compacted = await jsonld.compact(flattened, ctx, options);
      return compacted;
    };
    jsonld.frame = async function(input, frame, options) {
      if (arguments.length < 2) {
        throw new TypeError("Could not frame, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : "",
        embed: "@once",
        explicit: false,
        requireAll: false,
        omitDefault: false,
        bnodesToClear: [],
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      if (_isString2(frame)) {
        const remoteDoc = await jsonld.get(frame, options);
        frame = remoteDoc.document;
        if (remoteDoc.contextUrl) {
          let ctx = frame["@context"];
          if (!ctx) {
            ctx = remoteDoc.contextUrl;
          } else if (_isArray(ctx)) {
            ctx.push(remoteDoc.contextUrl);
          } else {
            ctx = [ctx, remoteDoc.contextUrl];
          }
          frame["@context"] = ctx;
        }
      }
      const frameContext = frame ? frame["@context"] || {} : {};
      const activeCtx = await jsonld.processContext(_getInitialContext(options), frameContext, options);
      if (!options.hasOwnProperty("omitGraph")) {
        options.omitGraph = _processingMode(activeCtx, 1.1);
      }
      if (!options.hasOwnProperty("pruneBlankNodeIdentifiers")) {
        options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
      }
      const expanded = await jsonld.expand(input, options);
      const opts = { ...options };
      opts.isFrame = true;
      opts.keepFreeFloatingNodes = true;
      const expandedFrame = await jsonld.expand(frame, opts);
      const frameKeys = Object.keys(frame).map((key) => _expandIri(activeCtx, key, { vocab: true }));
      opts.merged = !frameKeys.includes("@graph");
      opts.is11 = _processingMode(activeCtx, 1.1);
      const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
      opts.graph = !options.omitGraph;
      opts.skipExpansion = true;
      opts.link = {};
      opts.framing = true;
      let compacted = await jsonld.compact(framed, frameContext, opts);
      opts.link = {};
      compacted = _cleanupNull(compacted, opts);
      return compacted;
    };
    jsonld.link = async function(input, ctx, options) {
      const frame = {};
      if (ctx) {
        frame["@context"] = ctx;
      }
      frame["@embed"] = "@link";
      return jsonld.frame(input, frame, options);
    };
    jsonld.normalize = jsonld.canonize = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not canonize, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : null,
        algorithm: "URDNA2015",
        skipExpansion: false,
        safe: true,
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      if ("inputFormat" in options) {
        if (options.inputFormat !== "application/n-quads" && options.inputFormat !== "application/nquads") {
          throw new JsonLdError("Unknown canonicalization input format.", "jsonld.CanonizeError");
        }
        const parsedInput = NQuads.parse(input);
        return canonize.canonize(parsedInput, options);
      }
      const opts = { ...options };
      delete opts.format;
      opts.produceGeneralizedRdf = false;
      const dataset = await jsonld.toRDF(input, opts);
      return canonize.canonize(dataset, options);
    };
    jsonld.fromRDF = async function(dataset, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not convert from RDF, too few arguments.");
      }
      options = _setDefaults(options, {
        format: _isString2(dataset) ? "application/n-quads" : undefined
      });
      const { format } = options;
      let { rdfParser } = options;
      if (format) {
        rdfParser = rdfParser || _rdfParsers[format];
        if (!rdfParser) {
          throw new JsonLdError("Unknown input format.", "jsonld.UnknownFormat", { format });
        }
      } else {
        rdfParser = () => dataset;
      }
      const parsedDataset = await rdfParser(dataset);
      return _fromRDF(parsedDataset, options);
    };
    jsonld.toRDF = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not convert to RDF, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : "",
        skipExpansion: false,
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      let expanded;
      if (options.skipExpansion) {
        expanded = input;
      } else {
        expanded = await jsonld.expand(input, options);
      }
      const dataset = _toRDF(expanded, options);
      if (options.format) {
        if (options.format === "application/n-quads" || options.format === "application/nquads") {
          return NQuads.serialize(dataset);
        }
        throw new JsonLdError("Unknown output format.", "jsonld.UnknownFormat", { format: options.format });
      }
      return dataset;
    };
    jsonld.createNodeMap = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not create node map, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString2(input) ? input : "",
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      const expanded = await jsonld.expand(input, options);
      return _createMergedNodeMap(expanded, options);
    };
    jsonld.merge = async function(docs, ctx, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not merge, too few arguments.");
      }
      if (!_isArray(docs)) {
        throw new TypeError('Could not merge, "docs" must be an array.');
      }
      if (typeof ctx === "function") {
        ctx = null;
      } else {
        ctx = ctx || null;
      }
      options = _setDefaults(options, {
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      const expanded = await Promise.all(docs.map((doc) => {
        const opts = { ...options };
        return jsonld.expand(doc, opts);
      }));
      let mergeNodes = true;
      if ("mergeNodes" in options) {
        mergeNodes = options.mergeNodes;
      }
      const issuer = options.issuer || new IdentifierIssuer("_:b");
      const graphs = { "@default": {} };
      for (let i = 0;i < expanded.length; ++i) {
        const doc = util.relabelBlankNodes(expanded[i], {
          issuer: new IdentifierIssuer("_:b" + i + "-")
        });
        const _graphs = mergeNodes || i === 0 ? graphs : { "@default": {} };
        _createNodeMap(doc, _graphs, "@default", issuer);
        if (_graphs !== graphs) {
          for (const graphName in _graphs) {
            const _nodeMap = _graphs[graphName];
            if (!(graphName in graphs)) {
              graphs[graphName] = _nodeMap;
              continue;
            }
            const nodeMap = graphs[graphName];
            for (const key in _nodeMap) {
              if (!(key in nodeMap)) {
                nodeMap[key] = _nodeMap[key];
              }
            }
          }
        }
      }
      const defaultGraph = _mergeNodeMaps(graphs);
      const flattened = [];
      const keys = Object.keys(defaultGraph).sort();
      for (let ki = 0;ki < keys.length; ++ki) {
        const node = defaultGraph[keys[ki]];
        if (!_isSubjectReference(node)) {
          flattened.push(node);
        }
      }
      if (ctx === null) {
        return flattened;
      }
      options.graph = true;
      options.skipExpansion = true;
      const compacted = await jsonld.compact(flattened, ctx, options);
      return compacted;
    };
    Object.defineProperty(jsonld, "documentLoader", {
      get: () => jsonld._documentLoader,
      set: (v) => jsonld._documentLoader = v
    });
    jsonld.documentLoader = async (url) => {
      throw new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL " + "dereferencing not implemented.", "jsonld.LoadDocumentError", { code: "loading document failed", url });
    };
    jsonld.get = async function(url, options) {
      let load;
      if (typeof options.documentLoader === "function") {
        load = options.documentLoader;
      } else {
        load = jsonld.documentLoader;
      }
      const remoteDoc = await load(url);
      try {
        if (!remoteDoc.document) {
          throw new JsonLdError("No remote document found at the given URL.", "jsonld.NullRemoteDocument");
        }
        if (_isString2(remoteDoc.document)) {
          remoteDoc.document = JSON.parse(remoteDoc.document);
        }
      } catch (e) {
        throw new JsonLdError("Could not retrieve a JSON-LD document from the URL.", "jsonld.LoadDocumentError", {
          code: "loading document failed",
          cause: e,
          remoteDoc
        });
      }
      return remoteDoc;
    };
    jsonld.processContext = async function(activeCtx, localCtx, options) {
      options = _setDefaults(options, {
        base: "",
        contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
      });
      if (localCtx === null) {
        return _getInitialContext(options);
      }
      localCtx = util.clone(localCtx);
      if (!(_isObject2(localCtx) && ("@context" in localCtx))) {
        localCtx = { "@context": localCtx };
      }
      return _processContext({ activeCtx, localCtx, options });
    };
    jsonld.getContextValue = require_context().getContextValue;
    jsonld.documentLoaders = {};
    jsonld.useDocumentLoader = function(type) {
      if (!(type in jsonld.documentLoaders)) {
        throw new JsonLdError('Unknown document loader type: "' + type + '"', "jsonld.UnknownDocumentLoader", { type });
      }
      jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
    };
    jsonld.registerRDFParser = function(contentType, parser) {
      _rdfParsers[contentType] = parser;
    };
    jsonld.unregisterRDFParser = function(contentType) {
      delete _rdfParsers[contentType];
    };
    jsonld.registerRDFParser("application/n-quads", NQuads.parse);
    jsonld.registerRDFParser("application/nquads", NQuads.parse);
    jsonld.url = require_url();
    jsonld.logEventHandler = _logEventHandler;
    jsonld.logWarningEventHandler = _logWarningEventHandler;
    jsonld.safeEventHandler = _safeEventHandler;
    jsonld.setDefaultEventHandler = _setDefaultEventHandler;
    jsonld.strictEventHandler = _strictEventHandler;
    jsonld.unhandledEventHandler = _unhandledEventHandler;
    jsonld.util = util;
    Object.assign(jsonld, util);
    jsonld.promises = jsonld;
    jsonld.RequestQueue = require_RequestQueue();
    jsonld.JsonLdProcessor = require_JsonLdProcessor()(jsonld);
    platform.setupGlobals(jsonld);
    platform.setupDocumentLoaders(jsonld);
    function _setDefaults(options, {
      documentLoader = jsonld.documentLoader,
      ...defaults
    }) {
      if (options && "compactionMap" in options) {
        throw new JsonLdError('"compactionMap" not supported.', "jsonld.OptionsError");
      }
      if (options && "expansionMap" in options) {
        throw new JsonLdError('"expansionMap" not supported.', "jsonld.OptionsError");
      }
      return Object.assign({}, { documentLoader }, defaults, options, { eventHandler: _setupEventHandler({ options }) });
    }
    return jsonld;
  };
  var factory = function() {
    return wrapper(function() {
      return factory();
    });
  };
  wrapper(factory);
  module.exports = factory;
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS((exports, module) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise;
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => at,
  resolveObjectURL: () => lt,
  kStringMaxLength: () => K,
  isUtf8: () => pt,
  isAscii: () => ct,
  default: () => export_default,
  createObjectURL: () => ft,
  constants: () => st,
  btoa: () => ht,
  atob: () => ut,
  File: () => ot,
  Buffer: () => export_Buffer,
  Blob: () => nt
});
function lt(i) {
  throw new Error("Not implemented");
}
function at(i, r, t) {
  throw new Error("Not implemented");
}
var gr, $, mr, Ir, Fr, Ar, P = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports), Ur = (i, r) => {
  for (var t in r)
    $(i, t, { get: r[t], enumerable: true });
}, D = (i, r, t, e) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of Ir(r))
      !Ar.call(i, n) && n !== t && $(i, n, { get: () => r[n], enumerable: !(e = mr(r, n)) || e.enumerable });
  return i;
}, x = (i, r, t) => (D(i, r, "default"), t && D(t, r, "default")), O = (i, r, t) => (t = i != null ? gr(Fr(i)) : {}, D(r || !i || !i.__esModule ? $(t, "default", { value: i, enumerable: true }) : t, i)), v, rr, b, w, Br, Er, K, nt, ot, ut, ht, ft, ct = (i) => ArrayBuffer.isView(i) ? i.every((r) => r < 128) : i.split("").every((r) => r.charCodeAt(0) < 128), pt = (i) => {
  throw new Error("Not implemented");
}, st, export_Buffer, export_default;
var init_buffer = __esm(() => {
  gr = Object.create;
  $ = Object.defineProperty;
  mr = Object.getOwnPropertyDescriptor;
  Ir = Object.getOwnPropertyNames;
  Fr = Object.getPrototypeOf;
  Ar = Object.prototype.hasOwnProperty;
  v = P((L) => {
    L.byteLength = Tr;
    L.toByteArray = _r;
    L.fromByteArray = Nr;
    var d = [], B = [], Rr = typeof Uint8Array < "u" ? Uint8Array : Array, G = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (F = 0, Z = G.length;F < Z; ++F)
      d[F] = G[F], B[G.charCodeAt(F)] = F;
    var F, Z;
    B[45] = 62;
    B[95] = 63;
    function Q(i) {
      var r = i.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i.indexOf("=");
      t === -1 && (t = r);
      var e = t === r ? 0 : 4 - t % 4;
      return [t, e];
    }
    function Tr(i) {
      var r = Q(i), t = r[0], e = r[1];
      return (t + e) * 3 / 4 - e;
    }
    function Cr(i, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function _r(i) {
      var r, t = Q(i), e = t[0], n = t[1], o = new Rr(Cr(i, e, n)), u = 0, f = n > 0 ? e - 4 : e, c;
      for (c = 0;c < f; c += 4)
        r = B[i.charCodeAt(c)] << 18 | B[i.charCodeAt(c + 1)] << 12 | B[i.charCodeAt(c + 2)] << 6 | B[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
      return n === 2 && (r = B[i.charCodeAt(c)] << 2 | B[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), n === 1 && (r = B[i.charCodeAt(c)] << 10 | B[i.charCodeAt(c + 1)] << 4 | B[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Sr(i) {
      return d[i >> 18 & 63] + d[i >> 12 & 63] + d[i >> 6 & 63] + d[i & 63];
    }
    function Lr(i, r, t) {
      for (var e, n = [], o = r;o < t; o += 3)
        e = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), n.push(Sr(e));
      return n.join("");
    }
    function Nr(i) {
      for (var r, t = i.length, e = t % 3, n = [], o = 16383, u = 0, f = t - e;u < f; u += o)
        n.push(Lr(i, u, u + o > f ? f : u + o));
      return e === 1 ? (r = i[t - 1], n.push(d[r >> 2] + d[r << 4 & 63] + "==")) : e === 2 && (r = (i[t - 2] << 8) + i[t - 1], n.push(d[r >> 10] + d[r >> 4 & 63] + d[r << 2 & 63] + "=")), n.join("");
    }
  });
  rr = P((Y) => {
    Y.read = function(i, r, t, e, n) {
      var o, u, f = n * 8 - e - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? n - 1 : 0, U = t ? -1 : 1, E = i[r + p];
      for (p += U, o = E & (1 << -s) - 1, E >>= -s, s += f;s > 0; o = o * 256 + i[r + p], p += U, s -= 8)
        ;
      for (u = o & (1 << -s) - 1, o >>= -s, s += e;s > 0; u = u * 256 + i[r + p], p += U, s -= 8)
        ;
      if (o === 0)
        o = 1 - l;
      else {
        if (o === c)
          return u ? NaN : (E ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, e), o = o - l;
      }
      return (E ? -1 : 1) * u * Math.pow(2, o - e);
    };
    Y.write = function(i, r, t, e, n, o) {
      var u, f, c, l = o * 8 - n - 1, s = (1 << l) - 1, p = s >> 1, U = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = e ? 0 : o - 1, k = e ? 1 : -1, dr = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += U / c : r += U * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, n), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, n), u = 0));n >= 8; i[t + E] = f & 255, E += k, f /= 256, n -= 8)
        ;
      for (u = u << n | f, l += n;l > 0; i[t + E] = u & 255, E += k, u /= 256, l -= 8)
        ;
      i[t + E - k] |= dr * 128;
    };
  });
  b = P((_) => {
    var j = v(), T = rr(), tr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _.Buffer = h;
    _.SlowBuffer = Pr;
    _.INSPECT_MAX_BYTES = 50;
    var N = 2147483647;
    _.kMaxLength = N;
    h.TYPED_ARRAY_SUPPORT = Mr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Mr() {
      try {
        let i = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.byteOffset;
    } });
    function m(i) {
      if (i > N)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
      let r = new Uint8Array(i);
      return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
      if (typeof i == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return X(i);
      }
      return or(i, r, t);
    }
    h.poolSize = 8192;
    function or(i, r, t) {
      if (typeof i == "string")
        return kr(i, r);
      if (ArrayBuffer.isView(i))
        return Dr(i);
      if (i == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
      if (g(i, ArrayBuffer) || i && g(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (g(i, SharedArrayBuffer) || i && g(i.buffer, SharedArrayBuffer)))
        return W(i, r, t);
      if (typeof i == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let e = i.valueOf && i.valueOf();
      if (e != null && e !== i)
        return h.from(e, r, t);
      let n = $r(i);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
        return h.from(i[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
      return or(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function ur(i) {
      if (typeof i != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i < 0)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function br(i, r, t) {
      return ur(i), i <= 0 ? m(i) : r !== undefined ? typeof t == "string" ? m(i).fill(r, t) : m(i).fill(r) : m(i);
    }
    h.alloc = function(i, r, t) {
      return br(i, r, t);
    };
    function X(i) {
      return ur(i), m(i < 0 ? 0 : V(i) | 0);
    }
    h.allocUnsafe = function(i) {
      return X(i);
    };
    h.allocUnsafeSlow = function(i) {
      return X(i);
    };
    function kr(i, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = hr(i, r) | 0, e = m(t), n = e.write(i, r);
      return n !== t && (e = e.slice(0, n)), e;
    }
    function q(i) {
      let r = i.length < 0 ? 0 : V(i.length) | 0, t = m(r);
      for (let e = 0;e < r; e += 1)
        t[e] = i[e] & 255;
      return t;
    }
    function Dr(i) {
      if (g(i, Uint8Array)) {
        let r = new Uint8Array(i);
        return W(r.buffer, r.byteOffset, r.byteLength);
      }
      return q(i);
    }
    function W(i, r, t) {
      if (r < 0 || i.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let e;
      return r === undefined && t === undefined ? e = new Uint8Array(i) : t === undefined ? e = new Uint8Array(i, r) : e = new Uint8Array(i, r, t), Object.setPrototypeOf(e, h.prototype), e;
    }
    function $r(i) {
      if (h.isBuffer(i)) {
        let r = V(i.length) | 0, t = m(r);
        return t.length === 0 || i.copy(t, 0, 0, r), t;
      }
      if (i.length !== undefined)
        return typeof i.length != "number" || J(i.length) ? m(0) : q(i);
      if (i.type === "Buffer" && Array.isArray(i.data))
        return q(i.data);
    }
    function V(i) {
      if (i >= N)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N.toString(16) + " bytes");
      return i | 0;
    }
    function Pr(i) {
      return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h.prototype;
    };
    h.compare = function(r, t) {
      if (g(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), g(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let e = r.length, n = t.length;
      for (let o = 0, u = Math.min(e, n);o < u; ++o)
        if (r[o] !== t[o]) {
          e = r[o], n = t[o];
          break;
        }
      return e < n ? -1 : n < e ? 1 : 0;
    };
    h.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h.alloc(0);
      let e;
      if (t === undefined)
        for (t = 0, e = 0;e < r.length; ++e)
          t += r[e].length;
      let n = h.allocUnsafe(t), o = 0;
      for (e = 0;e < r.length; ++e) {
        let u = r[e];
        if (g(u, Uint8Array))
          o + u.length > n.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(n, o)) : Uint8Array.prototype.set.call(n, u, o);
        else if (h.isBuffer(u))
          u.copy(n, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += u.length;
      }
      return n;
    };
    function hr(i, r) {
      if (h.isBuffer(i))
        return i.length;
      if (ArrayBuffer.isView(i) || g(i, ArrayBuffer))
        return i.byteLength;
      if (typeof i != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
      let t = i.length, e = arguments.length > 2 && arguments[2] === true;
      if (!e && t === 0)
        return 0;
      let n = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return H(i).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return xr(i).length;
          default:
            if (n)
              return e ? -1 : H(i).length;
            r = ("" + r).toLowerCase(), n = true;
        }
    }
    h.byteLength = hr;
    function Or(i, r, t) {
      let e = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i || (i = "utf8");; )
        switch (i) {
          case "hex":
            return Jr(this, r, t);
          case "utf8":
          case "utf-8":
            return cr(this, r, t);
          case "ascii":
            return Vr(this, r, t);
          case "latin1":
          case "binary":
            return zr(this, r, t);
          case "base64":
            return Hr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Kr(this, r, t);
          default:
            if (e)
              throw new TypeError("Unknown encoding: " + i);
            i = (i + "").toLowerCase(), e = true;
        }
    }
    h.prototype._isBuffer = true;
    function A(i, r, t) {
      let e = i[r];
      i[r] = i[t], i[t] = e;
    }
    h.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        A(this, t, t + 1);
      return this;
    };
    h.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        A(this, t, t + 3), A(this, t + 1, t + 2);
      return this;
    };
    h.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        A(this, t, t + 7), A(this, t + 1, t + 6), A(this, t + 2, t + 5), A(this, t + 3, t + 4);
      return this;
    };
    h.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? cr(this, 0, r) : Or.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
      if (!h.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
      let r = "", t = _.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    tr && (h.prototype[tr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, e, n, o) {
      if (g(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), e === undefined && (e = r ? r.length : 0), n === undefined && (n = 0), o === undefined && (o = this.length), t < 0 || e > r.length || n < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (n >= o && t >= e)
        return 0;
      if (n >= o)
        return -1;
      if (t >= e)
        return 1;
      if (t >>>= 0, e >>>= 0, n >>>= 0, o >>>= 0, this === r)
        return 0;
      let u = o - n, f = e - t, c = Math.min(u, f), l = this.slice(n, o), s = r.slice(t, e);
      for (let p = 0;p < c; ++p)
        if (l[p] !== s[p]) {
          u = l[p], f = s[p];
          break;
        }
      return u < f ? -1 : f < u ? 1 : 0;
    };
    function fr(i, r, t, e, n) {
      if (i.length === 0)
        return -1;
      if (typeof t == "string" ? (e = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, J(t) && (t = n ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
        if (n)
          return -1;
        t = i.length - 1;
      } else if (t < 0)
        if (n)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h.from(r, e)), h.isBuffer(r))
        return r.length === 0 ? -1 : ir(i, r, t, e, n);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir(i, [r], t, e, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ir(i, r, t, e, n) {
      let o = 1, u = i.length, f = r.length;
      if (e !== undefined && (e = String(e).toLowerCase(), e === "ucs2" || e === "ucs-2" || e === "utf16le" || e === "utf-16le")) {
        if (i.length < 2 || r.length < 2)
          return -1;
        o = 2, u /= 2, f /= 2, t /= 2;
      }
      function c(s, p) {
        return o === 1 ? s[p] : s.readUInt16BE(p * o);
      }
      let l;
      if (n) {
        let s = -1;
        for (l = t;l < u; l++)
          if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
            if (s === -1 && (s = l), l - s + 1 === f)
              return s * o;
          } else
            s !== -1 && (l -= l - s), s = -1;
      } else
        for (t + f > u && (t = u - f), l = t;l >= 0; l--) {
          let s = true;
          for (let p = 0;p < f; p++)
            if (c(i, l + p) !== c(r, p)) {
              s = false;
              break;
            }
          if (s)
            return l;
        }
      return -1;
    }
    h.prototype.includes = function(r, t, e) {
      return this.indexOf(r, t, e) !== -1;
    };
    h.prototype.indexOf = function(r, t, e) {
      return fr(this, r, t, e, true);
    };
    h.prototype.lastIndexOf = function(r, t, e) {
      return fr(this, r, t, e, false);
    };
    function Gr(i, r, t, e) {
      t = Number(t) || 0;
      let n = i.length - t;
      e ? (e = Number(e), e > n && (e = n)) : e = n;
      let o = r.length;
      e > o / 2 && (e = o / 2);
      let u;
      for (u = 0;u < e; ++u) {
        let f = parseInt(r.substr(u * 2, 2), 16);
        if (J(f))
          return u;
        i[t + u] = f;
      }
      return u;
    }
    function Yr(i, r, t, e) {
      return M(H(r, i.length - t), i, t, e);
    }
    function jr(i, r, t, e) {
      return M(rt(r), i, t, e);
    }
    function qr(i, r, t, e) {
      return M(xr(r), i, t, e);
    }
    function Wr(i, r, t, e) {
      return M(tt(r, i.length - t), i, t, e);
    }
    h.prototype.write = function(r, t, e, n) {
      if (t === undefined)
        n = "utf8", e = this.length, t = 0;
      else if (e === undefined && typeof t == "string")
        n = t, e = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(e) ? (e = e >>> 0, n === undefined && (n = "utf8")) : (n = e, e = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - t;
      if ((e === undefined || e > o) && (e = o), r.length > 0 && (e < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u = false;
      for (;; )
        switch (n) {
          case "hex":
            return Gr(this, r, t, e);
          case "utf8":
          case "utf-8":
            return Yr(this, r, t, e);
          case "ascii":
          case "latin1":
          case "binary":
            return jr(this, r, t, e);
          case "base64":
            return qr(this, r, t, e);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Wr(this, r, t, e);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u = true;
        }
    };
    h.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Hr(i, r, t) {
      return r === 0 && t === i.length ? j.fromByteArray(i) : j.fromByteArray(i.slice(r, t));
    }
    function cr(i, r, t) {
      t = Math.min(i.length, t);
      let e = [], n = r;
      for (;n < t; ) {
        let o = i[n], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (n + f <= t) {
          let c, l, s, p;
          switch (f) {
            case 1:
              o < 128 && (u = o);
              break;
            case 2:
              c = i[n + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
              break;
            case 3:
              c = i[n + 1], l = i[n + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
              break;
            case 4:
              c = i[n + 1], l = i[n + 2], s = i[n + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
          }
        }
        u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, e.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), e.push(u), n += f;
      }
      return Xr(e);
    }
    var er = 4096;
    function Xr(i) {
      let r = i.length;
      if (r <= er)
        return String.fromCharCode.apply(String, i);
      let t = "", e = 0;
      for (;e < r; )
        t += String.fromCharCode.apply(String, i.slice(e, e += er));
      return t;
    }
    function Vr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n] & 127);
      return e;
    }
    function zr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n]);
      return e;
    }
    function Jr(i, r, t) {
      let e = i.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > e) && (t = e);
      let n = "";
      for (let o = r;o < t; ++o)
        n += it[i[o]];
      return n;
    }
    function Kr(i, r, t) {
      let e = i.slice(r, t), n = "";
      for (let o = 0;o < e.length - 1; o += 2)
        n += String.fromCharCode(e[o] + e[o + 1] * 256);
      return n;
    }
    h.prototype.slice = function(r, t) {
      let e = this.length;
      r = ~~r, t = t === undefined ? e : ~~t, r < 0 ? (r += e, r < 0 && (r = 0)) : r > e && (r = e), t < 0 ? (t += e, t < 0 && (t = 0)) : t > e && (t = e), t < r && (t = r);
      let n = this.subarray(r, t);
      return Object.setPrototypeOf(n, h.prototype), n;
    };
    function a(i, r, t) {
      if (i % 1 !== 0 || i < 0)
        throw new RangeError("offset is not uint");
      if (i + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        n += this[r + u] * o;
      return n;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n = this[r + --t], o = 1;
      for (;t > 0 && (o *= 256); )
        n += this[r + --t] * o;
      return n;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S(r, this.length - 8);
      let n = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + e * 2 ** 24;
      return BigInt(n) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S(r, this.length - 8);
      let n = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e;
      return (BigInt(n) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        n += this[r + u] * o;
      return o *= 128, n >= o && (n -= Math.pow(2, 8 * t)), n;
    };
    h.prototype.readIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n = t, o = 1, u = this[r + --n];
      for (;n > 0 && (o *= 256); )
        u += this[r + --n] * o;
      return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let e = this[r] | this[r + 1] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let e = this[r + 1] | this[r] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S(r, this.length - 8);
      let n = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (e << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S(r, this.length - 8);
      let n = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e);
    });
    h.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), T.read(this, r, true, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), T.read(this, r, false, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), T.read(this, r, true, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), T.read(this, r, false, 52, 8);
    };
    function y(i, r, t, e, n, o) {
      if (!h.isBuffer(i))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > n || r < o)
        throw new RangeError('"value" argument is out of bounds');
      if (t + e > i.length)
        throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f = Math.pow(2, 8 * e) - 1;
        y(this, r, t, e, f, 0);
      }
      let o = 1, u = 0;
      for (this[t] = r & 255;++u < e && (o *= 256); )
        this[t + u] = r / o & 255;
      return t + e;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f = Math.pow(2, 8 * e) - 1;
        y(this, r, t, e, f, 0);
      }
      let o = e - 1, u = 1;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        this[t + o] = r / u & 255;
      return t + e;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function pr(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function sr(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = I(function(r, t = 0) {
      return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = I(function(r, t = 0) {
      return sr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c = Math.pow(2, 8 * e - 1);
        y(this, r, t, e, c - 1, -c);
      }
      let o = 0, u = 1, f = 0;
      for (this[t] = r & 255;++o < e && (u *= 256); )
        r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
      return t + e;
    };
    h.prototype.writeIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c = Math.pow(2, 8 * e - 1);
        y(this, r, t, e, c - 1, -c);
      }
      let o = e - 1, u = 1, f = 0;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
      return t + e;
    };
    h.prototype.writeInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = I(function(r, t = 0) {
      return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = I(function(r, t = 0) {
      return sr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function lr(i, r, t, e, n, o) {
      if (t + e > i.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function ar(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T.write(i, r, t, e, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, e) {
      return ar(this, r, t, true, e);
    };
    h.prototype.writeFloatBE = function(r, t, e) {
      return ar(this, r, t, false, e);
    };
    function yr(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T.write(i, r, t, e, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, e) {
      return yr(this, r, t, true, e);
    };
    h.prototype.writeDoubleBE = function(r, t, e) {
      return yr(this, r, t, false, e);
    };
    h.prototype.copy = function(r, t, e, n) {
      if (!h.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (e || (e = 0), !n && n !== 0 && (n = this.length), t >= r.length && (t = r.length), t || (t = 0), n > 0 && n < e && (n = e), n === e || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (e < 0 || e >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), r.length - t < n - e && (n = r.length - t + e);
      let o = n - e;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e, n) : Uint8Array.prototype.set.call(r, this.subarray(e, n), t), o;
    };
    h.prototype.fill = function(r, t, e, n) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (n = t, t = 0, e = this.length) : typeof e == "string" && (n = e, e = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (r.length === 1) {
          let u = r.charCodeAt(0);
          (n === "utf8" && u < 128 || n === "latin1") && (r = u);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < e)
        throw new RangeError("Out of range index");
      if (e <= t)
        return this;
      t = t >>> 0, e = e === undefined ? this.length : e >>> 0, r || (r = 0);
      let o;
      if (typeof r == "number")
        for (o = t;o < e; ++o)
          this[o] = r;
      else {
        let u = h.isBuffer(r) ? r : h.from(r, n), f = u.length;
        if (f === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o = 0;o < e - t; ++o)
          this[o + t] = u[o % f];
      }
      return this;
    };
    var R = {};
    function z(i, r, t) {
      R[i] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
        }
        get code() {
          return i;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${i}]: ${this.message}`;
        }
      };
    }
    z("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    z("ERR_INVALID_ARG_TYPE", function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    z("ERR_OUT_OF_RANGE", function(i, r, t) {
      let e = `The value of "${i}" is out of range.`, n = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = nr(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = nr(n)), n += "n"), e += ` It must be ${r}. Received ${n}`, e;
    }, RangeError);
    function nr(i) {
      let r = "", t = i.length, e = i[0] === "-" ? 1 : 0;
      for (;t >= e + 4; t -= 3)
        r = `_${i.slice(t - 3, t)}${r}`;
      return `${i.slice(0, t)}${r}`;
    }
    function Zr(i, r, t) {
      C(r, "offset"), (i[r] === undefined || i[r + t] === undefined) && S(r, i.length - (t + 1));
    }
    function wr(i, r, t, e, n, o) {
      if (i > t || i < r) {
        let u = typeof r == "bigint" ? "n" : "", f;
        throw o > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new R.ERR_OUT_OF_RANGE("value", f, i);
      }
      Zr(e, n, o);
    }
    function C(i, r) {
      if (typeof i != "number")
        throw new R.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function S(i, r, t) {
      throw Math.floor(i) !== i ? (C(i, t), new R.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new R.ERR_BUFFER_OUT_OF_BOUNDS : new R.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Qr = /[^+/0-9A-Za-z-_]/g;
    function vr(i) {
      if (i = i.split("=")[0], i = i.trim().replace(Qr, ""), i.length < 2)
        return "";
      for (;i.length % 4 !== 0; )
        i = i + "=";
      return i;
    }
    function H(i, r) {
      r = r || 1 / 0;
      let t, e = i.length, n = null, o = [];
      for (let u = 0;u < e; ++u) {
        if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
          if (!n) {
            if (t > 56319) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (u + 1 === e) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            n = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o.push(239, 191, 189), n = t;
            continue;
          }
          t = (n - 55296 << 10 | t - 56320) + 65536;
        } else
          n && (r -= 3) > -1 && o.push(239, 191, 189);
        if (n = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function rt(i) {
      let r = [];
      for (let t = 0;t < i.length; ++t)
        r.push(i.charCodeAt(t) & 255);
      return r;
    }
    function tt(i, r) {
      let t, e, n, o = [];
      for (let u = 0;u < i.length && !((r -= 2) < 0); ++u)
        t = i.charCodeAt(u), e = t >> 8, n = t % 256, o.push(n), o.push(e);
      return o;
    }
    function xr(i) {
      return j.toByteArray(vr(i));
    }
    function M(i, r, t, e) {
      let n;
      for (n = 0;n < e && !(n + t >= r.length || n >= i.length); ++n)
        r[n + t] = i[n];
      return n;
    }
    function g(i, r) {
      return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function J(i) {
      return i !== i;
    }
    var it = function() {
      let i = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let e = t * 16;
        for (let n = 0;n < 16; ++n)
          r[e + n] = i[t] + i[n];
      }
      return r;
    }();
    function I(i) {
      return typeof BigInt > "u" ? et : i;
    }
    function et() {
      throw new Error("BigInt not supported");
    }
  });
  w = {};
  Ur(w, { Blob: () => nt, Buffer: () => Er.Buffer, File: () => ot, atob: () => ut, btoa: () => ht, constants: () => st, createObjectURL: () => ft, default: () => Br.Buffer, isAscii: () => ct, isUtf8: () => pt, kStringMaxLength: () => K, resolveObjectURL: () => lt, transcode: () => at });
  x(w, O(b()));
  Br = O(b());
  Er = O(b());
  K = 2 ** 32 - 1;
  ({ Blob: nt, File: ot, atob: ut, btoa: ht } = globalThis);
  ({ createObjectURL: ft } = URL);
  st = { __proto__: null, MAX_LENGTH: K, MAX_STRING_LENGTH: K, BYTES_PER_ELEMENT: 1 };
  export_Buffer = Er.Buffer;
  export_default = Br.Buffer;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/n3/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS((exports, module) => {
  module.exports = {
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err) {
      return Promise.reject(err);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS((exports, module) => {
  var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : undefined;
  module.exports = AbortController;
  module.exports.AbortSignal = AbortSignal;
  module.exports.default = AbortController;
});

// node:events
var exports_events = {};
__export(exports_events, {
  prototype: () => P2,
  once: () => M,
  default: () => A,
  EventEmitter: () => o
});
function x2(t) {
  console && console.warn && console.warn(t);
}
function o() {
  o.init.call(this);
}
function v2(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
function m(t) {
  return t._maxListeners === undefined ? o.defaultMaxListeners : t._maxListeners;
}
function y(t, e, n, r) {
  var i, f, s;
  if (v2(n), f = t._events, f === undefined ? (f = t._events = Object.create(null), t._eventsCount = 0) : (f.newListener !== undefined && (t.emit("newListener", e, n.listener ? n.listener : n), f = t._events), s = f[e]), s === undefined)
    s = f[e] = n, ++t._eventsCount;
  else if (typeof s == "function" ? s = f[e] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), i = m(t), i > 0 && s.length > i && !s.warned) {
    s.warned = true;
    var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, x2(u);
  }
  return t;
}
function C() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function g(t, e, n) {
  var r = { fired: false, wrapFn: undefined, target: t, type: e, listener: n }, i = C.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
function _(t, e, n) {
  var r = t._events;
  if (r === undefined)
    return [];
  var i = r[e];
  return i === undefined ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? R(i) : b2(i, i.length);
}
function w2(t) {
  var e = this._events;
  if (e !== undefined) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== undefined)
      return n.length;
  }
  return 0;
}
function b2(t, e) {
  for (var n = new Array(e), r = 0;r < e; ++r)
    n[r] = t[r];
  return n;
}
function j(t, e) {
  for (;e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function R(t) {
  for (var e = new Array(t.length), n = 0;n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function M(t, e) {
  return new Promise(function(n, r) {
    function i(s) {
      t.removeListener(e, f), r(s);
    }
    function f() {
      typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
    }
    E(t, e, f, { once: true }), e !== "error" && N(t, i, { once: true });
  });
}
function N(t, e, n) {
  typeof t.on == "function" && E(t, "error", e, n);
}
function E(t, e, n, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(f) {
      r.once && t.removeEventListener(e, i), n(f);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var a, d, l, L, h = 10, A, P2;
var init_events = __esm(() => {
  a = typeof Reflect == "object" ? Reflect : null;
  d = a && typeof a.apply == "function" ? a.apply : function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  };
  a && typeof a.ownKeys == "function" ? l = a.ownKeys : Object.getOwnPropertySymbols ? l = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : l = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  L = Number.isNaN || function(e) {
    return e !== e;
  };
  o.EventEmitter = o;
  o.prototype._events = undefined;
  o.prototype._eventsCount = 0;
  o.prototype._maxListeners = undefined;
  Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
    return h;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || L(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    h = t;
  } });
  o.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  o.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || L(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  o.prototype.getMaxListeners = function() {
    return m(this);
  };
  o.prototype.emit = function(e) {
    for (var n = [], r = 1;r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", f = this._events;
    if (f !== undefined)
      i = i && f.error === undefined;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (n.length > 0 && (s = n[0]), s instanceof Error)
        throw s;
      var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw u.context = s, u;
    }
    var c = f[e];
    if (c === undefined)
      return false;
    if (typeof c == "function")
      d(c, this, n);
    else
      for (var p = c.length, O2 = b2(c, p), r = 0;r < p; ++r)
        d(O2[r], this, n);
    return true;
  };
  o.prototype.addListener = function(e, n) {
    return y(this, e, n, false);
  };
  o.prototype.on = o.prototype.addListener;
  o.prototype.prependListener = function(e, n) {
    return y(this, e, n, true);
  };
  o.prototype.once = function(e, n) {
    return v2(n), this.on(e, g(this, e, n)), this;
  };
  o.prototype.prependOnceListener = function(e, n) {
    return v2(n), this.prependListener(e, g(this, e, n)), this;
  };
  o.prototype.removeListener = function(e, n) {
    var r, i, f, s, u;
    if (v2(n), i = this._events, i === undefined)
      return this;
    if (r = i[e], r === undefined)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (f = -1, s = r.length - 1;s >= 0; s--)
        if (r[s] === n || r[s].listener === n) {
          u = r[s].listener, f = s;
          break;
        }
      if (f < 0)
        return this;
      f === 0 ? r.shift() : j(r, f), r.length === 1 && (i[e] = r[0]), i.removeListener !== undefined && this.emit("removeListener", e, u || n);
    }
    return this;
  };
  o.prototype.off = o.prototype.removeListener;
  o.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var f = Object.keys(r), s;
      for (i = 0;i < f.length; ++i)
        s = f[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== undefined)
      for (i = n.length - 1;i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  };
  o.prototype.listeners = function(e) {
    return _(this, e, true);
  };
  o.prototype.rawListeners = function(e) {
    return _(this, e, false);
  };
  o.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : w2.call(t, e);
  };
  o.prototype.listenerCount = w2;
  o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l(this._events) : [];
  };
  A = o;
  P2 = o.prototype;
});

// node_modules/n3/node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS((exports, module) => {
  var bufferModule = (init_buffer(), __toCommonJS(exports_buffer));
  var { kResistStopPropagation, SymbolDispose } = require_primordials();
  var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
  var AbortController = globalThis.AbortController || require_browser().AbortController;
  var AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b3) {
    return b3 instanceof Blob2;
  } : function isBlob(b3) {
    return false;
  };
  var validateAbortSignal = (signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  var validateFunction = (value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  };

  class AggregateError2 extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      let message = "";
      for (let i = 0;i < errors.length; i++) {
        message += `    ${errors[i].stack}
`;
      }
      super(message);
      this.name = "AggregateError";
      this.errors = errors;
    }
  }
  module.exports = {
    AggregateError: AggregateError2,
    kEmptyObject: Object.freeze({}),
    once(callback) {
      let called = false;
      return function(...args) {
        if (called) {
          return;
        }
        called = true;
        callback.apply(this, args);
      };
    },
    createDeferredPromise: function() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return {
        promise,
        resolve,
        reject
      };
    },
    promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err) {
            return reject(err);
          }
          return resolve(...args);
        });
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        const replacement = args.shift();
        if (type === "f") {
          return replacement.toFixed(6);
        } else if (type === "j") {
          return JSON.stringify(replacement);
        } else if (type === "s" && typeof replacement === "object") {
          const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
          return `${ctor} {}`.trim();
        } else {
          return replacement.toString();
        }
      });
    },
    inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"')) {
              return `"${value}"`;
            } else if (!value.includes("`") && !value.includes("${")) {
              return `\`${value}\``;
            }
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value)) {
            return "NaN";
          } else if (Object.is(value, -0)) {
            return String(value);
          }
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(fn) {
        return fn instanceof AsyncFunction;
      },
      isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      }
    },
    isBlob,
    deprecate(fn, message) {
      return fn;
    },
    addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
      }
      validateAbortSignal(signal, "signal");
      validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted) {
        queueMicrotask(() => listener());
      } else {
        signal.addEventListener("abort", listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        });
        removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
        }
      };
    },
    AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
      if (signals.length === 1) {
        return signals[0];
      }
      const ac = new AbortController;
      const abort = () => ac.abort();
      signals.forEach((signal) => {
        validateAbortSignal(signal, "signals");
        signal.addEventListener("abort", abort, {
          once: true
        });
      });
      ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, {
        once: true
      });
      return ac.signal;
    }
  };
  module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});

// node_modules/n3/node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS((exports, module) => {
  var { format, inspect, AggregateError: CustomAggregateError } = require_util2();
  var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
  var kIsNodeError = Symbol("kIsNodeError");
  var kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ];
  var classRegExp = /^([A-Z][a-z0-9]*)+$/;
  var nodeInternalPrefix = "__node_internal_";
  var codes = {};
  function assert(value, message) {
    if (!value) {
      throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
  }
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (;i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function getMessage(key, msg, args) {
    if (typeof msg === "function") {
      assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
      return msg(...args);
    }
    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
    if (args.length === 0) {
      return msg;
    }
    return format(msg, ...args);
  }
  function E2(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    class NodeError extends Base {
      constructor(...args) {
        super(getMessage(code, message, args));
      }
      toString() {
        return `${this.name} [${code}]: ${this.message}`;
      }
    }
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: true,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${code}]: ${this.message}`;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    NodeError.prototype.code = code;
    NodeError.prototype[kIsNodeError] = true;
    codes[code] = NodeError;
  }
  function hideStackFrames(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  }
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors)) {
        outerError.errors.push(innerError);
        return outerError;
      }
      const err = new AggregateError2([outerError, innerError], outerError.message);
      err.code = outerError.code;
      return err;
    }
    return innerError || outerError;
  }

  class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  }
  E2("ERR_ASSERTION", "%s", Error);
  E2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let msg = "The ";
    if (name.endsWith(" argument")) {
      msg += `${name} `;
    } else {
      msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(typeof value === "string", "All expected entries have to be of type string");
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.test(value)) {
        instances.push(value);
      } else {
        assert(value !== "object", 'The value "object" should be written as "Object"');
        other.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.splice(types, pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`;
          break;
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`;
          break;
        default: {
          const last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += " or ";
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`;
          break;
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`;
          break;
        default: {
          const last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        }
      }
      if (other.length > 0) {
        msg += " or ";
      }
    }
    switch (other.length) {
      case 0:
        break;
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += "an ";
        }
        msg += `${other[0]}`;
        break;
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`;
        break;
      default: {
        const last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
      msg += `. Received function ${actual.name}`;
    } else if (typeof actual === "object") {
      var _actual$constructor;
      if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {
        msg += `. Received an instance of ${actual.constructor.name}`;
      } else {
        const inspected = inspect(actual, {
          depth: -1
        });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      msg += `. Received type ${typeof actual} (${inspected})`;
    }
    return msg;
  }, TypeError);
  E2("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + "...";
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  E2("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
    var _value$constructor;
    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`;
  }, TypeError);
  E2("ERR_MISSING_ARGS", (...args) => {
    assert(args.length > 0, "At least one arg needs to be specified");
    let msg;
    const len = args.length;
    args = (Array.isArray(args) ? args : [args]).map((a2) => `"${a2}"`).join(" or ");
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`;
        break;
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`;
        break;
      default:
        {
          const last = args.pop();
          msg += `The ${args.join(", ")}, and ${last} arguments`;
        }
        break;
    }
    return `${msg} must be specified`;
  }, TypeError);
  E2("ERR_OUT_OF_RANGE", (str, range, input) => {
    assert(range, 'Missing "range" argument');
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
  }, RangeError);
  E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  module.exports = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS((exports, module) => {
  var {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = require_primordials();
  var {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = require_errors();
  var { normalizeEncoding } = require_util2();
  var { isAsyncFunction, isArrayBufferView } = require_util2().types;
  var signals = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  function isUint32(value) {
    return value === value >>> 0;
  }
  var octalReg = /^[0-7]+$/;
  var modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value === "undefined") {
      value = def;
    }
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null) {
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      }
      value = NumberParseInt(value, 8);
    }
    validateUint32(value, name);
    return value;
  }
  var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  var validateUint32 = hideStackFrames((value, name, positive = false) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min = positive ? 1 : 0;
    const max = 4294967295;
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  function validateString(value, name) {
    if (typeof value !== "string")
      throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
  }
  function validateNumber(value, name, min = undefined, max) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
      throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
  }
  var validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v3) => typeof v3 === "string" ? `'${v3}'` : String2(v3)), ", ");
      const reason = "must be one of: " + allowed;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
  }
  function getOwnPropertyValueOrDefault(options, key, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
  }
  var validateObject = hideStackFrames((value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
    }
  });
  var validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
    }
  });
  var validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
    }
    if (value.length < minLength) {
      const reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateString(value[i], `${name}[${i}]`);
    }
  }
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateBoolean(value[i], `${name}[${i}]`);
    }
  }
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      const signal = value[i];
      const indexedName = `${name}[${i}]`;
      if (signal == null) {
        throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
      }
      validateAbortSignal(signal, indexedName);
    }
  }
  function validateSignalName(signal, name = "signal") {
    validateString(signal, name);
    if (signals[signal] === undefined) {
      if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer);
    }
  });
  function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
  }
  function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port | 0;
  }
  var validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
    }
  });
  var validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  var validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction(value))
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  });
  var validateUndefined = hideStackFrames((value, name) => {
    if (value !== undefined)
      throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value)) {
      throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
  }
  var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
      throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
  }
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string") {
      validateLinkHeaderFormat(hints, "hints");
      return hints;
    } else if (ArrayIsArray(hints)) {
      const hintsLength = hints.length;
      let result = "";
      if (hintsLength === 0) {
        return result;
      }
      for (let i = 0;i < hintsLength; i++) {
        const link = hints[i];
        validateLinkHeaderFormat(link, "hints");
        result += link;
        if (i !== hintsLength - 1) {
          result += ", ";
        }
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  module.exports = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber,
    validateObject,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
});

// node_modules/process/browser.js
var require_browser2 = __commonJS((exports, module) => {
  var process2 = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1;i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process2.title = "browser";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = "";
  process2.versions = {};
  function noop2() {
  }
  process2.on = noop2;
  process2.addListener = noop2;
  process2.once = noop2;
  process2.off = noop2;
  process2.removeListener = noop2;
  process2.removeAllListeners = noop2;
  process2.emit = noop2;
  process2.prependListener = noop2;
  process2.prependOnceListener = noop2;
  process2.listeners = function(name) {
    return [];
  };
  process2.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process2.cwd = function() {
    return "/";
  };
  process2.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process2.umask = function() {
    return 0;
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS((exports, module) => {
  var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
  var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
  var kIsErrored = SymbolFor("nodejs.stream.errored");
  var kIsReadable = SymbolFor("nodejs.stream.readable");
  var kIsWritable = SymbolFor("nodejs.stream.writable");
  var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
  var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
  var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = false) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
  }
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
  }
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  function isIterable(obj, isAsync) {
    if (obj == null)
      return false;
    if (isAsync === true)
      return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === false)
      return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  function isDestroyed(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
  }
  function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableEnded === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
      return null;
    return wState.ended;
  }
  function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableFinished === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
      return null;
    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
  }
  function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream))
      return null;
    if (stream.readableEnded === true)
      return true;
    const rState = stream._readableState;
    if (!rState || rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
      return null;
    return rState.ended;
  }
  function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream))
      return null;
    const rState = stream._readableState;
    if (rState !== null && rState !== undefined && rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
      return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
  }
  function isReadable(stream) {
    if (stream && stream[kIsReadable] != null)
      return stream[kIsReadable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
  }
  function isWritable(stream) {
    if (stream && stream[kIsWritable] != null)
      return stream[kIsWritable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
  }
  function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (isDestroyed(stream)) {
      return true;
    }
    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
      return false;
    }
    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
      return false;
    }
    return true;
  }
  function isWritableErrored(stream) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.writableErrored) {
      return stream.writableErrored;
    }
    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
  }
  function isReadableErrored(stream) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.readableErrored) {
      return stream.readableErrored;
    }
    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
  }
  function isClosed(stream) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (typeof stream.closed === "boolean") {
      return stream.closed;
    }
    const wState = stream._writableState;
    const rState = stream._readableState;
    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean") {
      return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
    }
    if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
      return stream._closed;
    }
    return null;
  }
  function isOutgoingMessage(stream) {
    return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
  }
  function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
  }
  function isServerRequest(stream) {
    var _stream$req;
    return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
  }
  function willEmitClose(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
  }
  function isDisturbed(stream) {
    var _stream$kIsDisturbed;
    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
  }
  function isErrored(stream) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
  }
  module.exports = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var { AbortError, codes } = require_errors();
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
  var { kEmptyObject, once } = require_util2();
  var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
  var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
  var {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = require_utils();
  var addAbortListener;
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  var nop = () => {
  };
  function eos(stream, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2) {
      callback = options;
      options = kEmptyObject;
    } else if (options == null) {
      options = kEmptyObject;
    } else {
      validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    if (isReadableStream(stream) || isWritableStream(stream)) {
      return eosWeb(stream, options, callback);
    }
    if (!isNodeStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);
    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const onlegacyfinish = () => {
      if (!stream.writable) {
        onfinish();
      }
    };
    let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
    let writableFinished = isWritableFinished(stream, false);
    const onfinish = () => {
      writableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.readable || readable)) {
        return;
      }
      if (!readable || readableFinished) {
        callback.call(stream);
      }
    };
    let readableFinished = isReadableFinished(stream, false);
    const onend = () => {
      readableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.writable || writable)) {
        return;
      }
      if (!writable || writableFinished) {
        callback.call(stream);
      }
    };
    const onerror = (err) => {
      callback.call(stream, err);
    };
    let closed = isClosed(stream);
    const onclose = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
        if (!isReadableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      if (writable && !writableFinished) {
        if (!isWritableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      callback.call(stream);
    };
    const onclosed = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      callback.call(stream);
    };
    const onrequest = () => {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      if (!willEmitClose) {
        stream.on("abort", onclose);
      }
      if (stream.req) {
        onrequest();
      } else {
        stream.on("request", onrequest);
      }
    } else if (writable && !wState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
      stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) {
      stream.on("error", onerror);
    }
    stream.on("close", onclose);
    if (closed) {
      process2.nextTick(onclose);
    } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
      if (!willEmitClose) {
        process2.nextTick(onclosed);
      }
    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
      process2.nextTick(onclosed);
    } else if (rState && stream.req && stream.aborted) {
      process2.nextTick(onclosed);
    }
    const cleanup = () => {
      callback = nop;
      stream.removeListener("aborted", onclose);
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
      const abort = () => {
        const endCallback = callback;
        cleanup();
        endCallback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    return cleanup;
  }
  function eosWeb(stream, options, callback) {
    let isAborted = false;
    let abort = nop;
    if (options.signal) {
      abort = () => {
        isAborted = true;
        callback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process2.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    const resolverFn = (...args) => {
      if (!isAborted) {
        process2.nextTick(() => callback.apply(stream, args));
      }
    };
    PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
    return nop;
  }
  function finished(stream, opts) {
    var _opts;
    let autoCleanup = false;
    if (opts === null) {
      opts = kEmptyObject;
    }
    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
      validateBoolean(opts.cleanup, "cleanup");
      autoCleanup = opts.cleanup;
    }
    return new Promise2((resolve, reject) => {
      const cleanup = eos(stream, opts, (err) => {
        if (autoCleanup) {
          cleanup();
        }
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  module.exports = eos;
  module.exports.finished = finished;
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = require_errors();
  var { Symbol: Symbol2 } = require_primordials();
  var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
  var kDestroy = Symbol2("kDestroy");
  var kConstruct = Symbol2("kConstruct");
  function checkError(err, w3, r) {
    if (err) {
      err.stack;
      if (w3 && !w3.errored) {
        w3.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
    }
  }
  function destroy(err, cb) {
    const r = this._readableState;
    const w3 = this._writableState;
    const s = w3 || r;
    if (w3 !== null && w3 !== undefined && w3.destroyed || r !== null && r !== undefined && r.destroyed) {
      if (typeof cb === "function") {
        cb();
      }
      return this;
    }
    checkError(err, w3, r);
    if (w3) {
      w3.destroyed = true;
    }
    if (r) {
      r.destroyed = true;
    }
    if (!s.constructed) {
      this.once(kDestroy, function(er) {
        _destroy(this, aggregateTwoErrors(er, err), cb);
      });
    } else {
      _destroy(this, err, cb);
    }
    return this;
  }
  function _destroy(self2, err, cb) {
    let called = false;
    function onDestroy(err2) {
      if (called) {
        return;
      }
      called = true;
      const r = self2._readableState;
      const w3 = self2._writableState;
      checkError(err2, w3, r);
      if (w3) {
        w3.closed = true;
      }
      if (r) {
        r.closed = true;
      }
      if (typeof cb === "function") {
        cb(err2);
      }
      if (err2) {
        process2.nextTick(emitErrorCloseNT, self2, err2);
      } else {
        process2.nextTick(emitCloseNT, self2);
      }
    }
    try {
      self2._destroy(err || null, onDestroy);
    } catch (err2) {
      onDestroy(err2);
    }
  }
  function emitErrorCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    const r = self2._readableState;
    const w3 = self2._writableState;
    if (w3) {
      w3.closeEmitted = true;
    }
    if (r) {
      r.closeEmitted = true;
    }
    if (w3 !== null && w3 !== undefined && w3.emitClose || r !== null && r !== undefined && r.emitClose) {
      self2.emit("close");
    }
  }
  function emitErrorNT(self2, err) {
    const r = self2._readableState;
    const w3 = self2._writableState;
    if (w3 !== null && w3 !== undefined && w3.errorEmitted || r !== null && r !== undefined && r.errorEmitted) {
      return;
    }
    if (w3) {
      w3.errorEmitted = true;
    }
    if (r) {
      r.errorEmitted = true;
    }
    self2.emit("error", err);
  }
  function undestroy() {
    const r = this._readableState;
    const w3 = this._writableState;
    if (r) {
      r.constructed = true;
      r.closed = false;
      r.closeEmitted = false;
      r.destroyed = false;
      r.errored = null;
      r.errorEmitted = false;
      r.reading = false;
      r.ended = r.readable === false;
      r.endEmitted = r.readable === false;
    }
    if (w3) {
      w3.constructed = true;
      w3.destroyed = false;
      w3.closed = false;
      w3.closeEmitted = false;
      w3.errored = null;
      w3.errorEmitted = false;
      w3.finalCalled = false;
      w3.prefinished = false;
      w3.ended = w3.writable === false;
      w3.ending = w3.writable === false;
      w3.finished = w3.writable === false;
    }
  }
  function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w3 = stream._writableState;
    if (w3 !== null && w3 !== undefined && w3.destroyed || r !== null && r !== undefined && r.destroyed) {
      return this;
    }
    if (r !== null && r !== undefined && r.autoDestroy || w3 !== null && w3 !== undefined && w3.autoDestroy)
      stream.destroy(err);
    else if (err) {
      err.stack;
      if (w3 && !w3.errored) {
        w3.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
      if (sync) {
        process2.nextTick(emitErrorNT, stream, err);
      } else {
        emitErrorNT(stream, err);
      }
    }
  }
  function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
      return;
    }
    const r = stream._readableState;
    const w3 = stream._writableState;
    if (r) {
      r.constructed = false;
    }
    if (w3) {
      w3.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
      return;
    }
    process2.nextTick(constructNT, stream);
  }
  function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
        return;
      }
      called = true;
      const r = stream._readableState;
      const w3 = stream._writableState;
      const s = w3 || r;
      if (r) {
        r.constructed = true;
      }
      if (w3) {
        w3.constructed = true;
      }
      if (s.destroyed) {
        stream.emit(kDestroy, err);
      } else if (err) {
        errorOrDestroy(stream, err, true);
      } else {
        process2.nextTick(emitConstructNT, stream);
      }
    }
    try {
      stream._construct((err) => {
        process2.nextTick(onConstruct, err);
      });
    } catch (err) {
      process2.nextTick(onConstruct, err);
    }
  }
  function emitConstructNT(stream) {
    stream.emit(kConstruct);
  }
  function isRequest(stream) {
    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
  }
  function emitCloseLegacy(stream) {
    stream.emit("close");
  }
  function emitErrorCloseLegacy(stream, err) {
    stream.emit("error", err);
    process2.nextTick(emitCloseLegacy, stream);
  }
  function destroyer(stream, err) {
    if (!stream || isDestroyed(stream)) {
      return;
    }
    if (!err && !isFinished(stream)) {
      err = new AbortError;
    }
    if (isServerRequest(stream)) {
      stream.socket = null;
      stream.destroy(err);
    } else if (isRequest(stream)) {
      stream.abort();
    } else if (isRequest(stream.req)) {
      stream.req.abort();
    } else if (typeof stream.destroy === "function") {
      stream.destroy(err);
    } else if (typeof stream.close === "function") {
      stream.close();
    } else if (err) {
      process2.nextTick(emitErrorCloseLegacy, stream, err);
    } else {
      process2.nextTick(emitCloseLegacy, stream);
    }
    if (!stream.destroyed) {
      stream[kIsDestroyed] = true;
    }
  }
  module.exports = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
  var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
  function Stream(opts) {
    EE.call(this, opts);
  }
  ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
  ObjectSetPrototypeOf(Stream, EE);
  Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === false && source.pause) {
        source.pause();
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        this.emit("error", er);
      }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  module.exports = {
    Stream,
    prependListener
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS((exports, module) => {
  var { SymbolDispose } = require_primordials();
  var { AbortError, codes } = require_errors();
  var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
  var eos = require_end_of_stream();
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
  var addAbortListener;
  var validateAbortSignal = (signal, name) => {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
    }
  };
  exports.addAbortSignal = function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, "signal");
    if (!isNodeStream(stream) && !isWebStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    return exports.addAbortSignalNoValidate(signal, stream);
  };
  exports.addAbortSignalNoValidate = function(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      return stream;
    }
    const onAbort = isNodeStream(stream) ? () => {
      stream.destroy(new AbortError(undefined, {
        cause: signal.reason
      }));
    } : () => {
      stream[kControllerErrorFunction](new AbortError(undefined, {
        cause: signal.reason
      }));
    };
    if (signal.aborted) {
      onAbort();
    } else {
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      const disposable = addAbortListener(signal, onAbort);
      eos(stream, disposable[SymbolDispose]);
    }
    return stream;
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { inspect } = require_util2();
  module.exports = class BufferList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    push(v3) {
      const entry = {
        data: v3,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
    unshift(v3) {
      const entry = {
        data: v3,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      const ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
    join(s) {
      if (this.length === 0)
        return "";
      let p = this.head;
      let ret = "" + p.data;
      while ((p = p.next) !== null)
        ret += s + p.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      const ret = Buffer2.allocUnsafe(n >>> 0);
      let p = this.head;
      let i = 0;
      while (p) {
        TypedArrayPrototypeSet(ret, p.data, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }
    consume(n, hasStrings) {
      const data = this.head.data;
      if (n < data.length) {
        const slice = data.slice(0, n);
        this.head.data = data.slice(n);
        return slice;
      }
      if (n === data.length) {
        return this.shift();
      }
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p = this.head;p; p = p.next) {
        yield p.data;
      }
    }
    _getString(n) {
      let ret = "";
      let p = this.head;
      let c = 0;
      do {
        const str = p.data;
        if (n > str.length) {
          ret += str;
          n -= str.length;
        } else {
          if (n === str.length) {
            ret += str;
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            ret += StringPrototypeSlice(str, 0, n);
            this.head = p;
            p.data = StringPrototypeSlice(str, n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    _getBuffer(n) {
      const ret = Buffer2.allocUnsafe(n);
      const retLen = n;
      let p = this.head;
      let c = 0;
      do {
        const buf = p.data;
        if (n > buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n);
          n -= buf.length;
        } else {
          if (n === buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
            this.head = p;
            p.data = buf.slice(n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
      });
    }
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var { MathFloor, NumberIsInteger } = require_primordials();
  var { validateInteger } = require_validators();
  var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
  var defaultHighWaterMarkBytes = 16 * 1024;
  var defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  function setDefaultHighWaterMark(objectMode, value) {
    validateInteger(value, "value", 0);
    if (objectMode) {
      defaultHighWaterMarkObjectMode = value;
    } else {
      defaultHighWaterMarkBytes = value;
    }
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
  }
  module.exports = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
});

// node:string_decoder
var exports_string_decoder = {};
__export(exports_string_decoder, {
  default: () => export_default2,
  StringDecoder: () => export_StringDecoder
});
var Tt, Z, Nt, St, Rt, _t, R2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Lt = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of St(t))
      !_t.call(e, n) && n !== r && Z(e, n, { get: () => t[n], enumerable: !(i = Nt(t, n)) || i.enumerable });
  return e;
}, kt = (e, t, r) => (r = e != null ? Tt(Rt(e)) : {}, Lt(t || !e || !e.__esModule ? Z(r, "default", { value: e, enumerable: true }) : r, e)), tt, rt, Bt, mt, At, Ut, export_StringDecoder, export_default2;
var init_string_decoder = __esm(() => {
  Tt = Object.create;
  Z = Object.defineProperty;
  Nt = Object.getOwnPropertyDescriptor;
  St = Object.getOwnPropertyNames;
  Rt = Object.getPrototypeOf;
  _t = Object.prototype.hasOwnProperty;
  tt = R2((k) => {
    k.byteLength = Mt;
    k.toByteArray = Pt;
    k.fromByteArray = Gt;
    var d2 = [], w3 = [], Dt = typeof Uint8Array < "u" ? Uint8Array : Array, O2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (I = 0, Q = O2.length;I < Q; ++I)
      d2[I] = O2[I], w3[O2.charCodeAt(I)] = I;
    var I, Q;
    w3[45] = 62;
    w3[95] = 63;
    function v3(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var i = r === t ? 0 : 4 - r % 4;
      return [r, i];
    }
    function Mt(e) {
      var t = v3(e), r = t[0], i = t[1];
      return (r + i) * 3 / 4 - i;
    }
    function $t(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function Pt(e) {
      var t, r = v3(e), i = r[0], n = r[1], o2 = new Dt($t(e, i, n)), u = 0, s = n > 0 ? i - 4 : i, f;
      for (f = 0;f < s; f += 4)
        t = w3[e.charCodeAt(f)] << 18 | w3[e.charCodeAt(f + 1)] << 12 | w3[e.charCodeAt(f + 2)] << 6 | w3[e.charCodeAt(f + 3)], o2[u++] = t >> 16 & 255, o2[u++] = t >> 8 & 255, o2[u++] = t & 255;
      return n === 2 && (t = w3[e.charCodeAt(f)] << 2 | w3[e.charCodeAt(f + 1)] >> 4, o2[u++] = t & 255), n === 1 && (t = w3[e.charCodeAt(f)] << 10 | w3[e.charCodeAt(f + 1)] << 4 | w3[e.charCodeAt(f + 2)] >> 2, o2[u++] = t >> 8 & 255, o2[u++] = t & 255), o2;
    }
    function Ot(e) {
      return d2[e >> 18 & 63] + d2[e >> 12 & 63] + d2[e >> 6 & 63] + d2[e & 63];
    }
    function qt(e, t, r) {
      for (var i, n = [], o2 = t;o2 < r; o2 += 3)
        i = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), n.push(Ot(i));
      return n.join("");
    }
    function Gt(e) {
      for (var t, r = e.length, i = r % 3, n = [], o2 = 16383, u = 0, s = r - i;u < s; u += o2)
        n.push(qt(e, u, u + o2 > s ? s : u + o2));
      return i === 1 ? (t = e[r - 1], n.push(d2[t >> 2] + d2[t << 4 & 63] + "==")) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(d2[t >> 10] + d2[t >> 4 & 63] + d2[t << 2 & 63] + "=")), n.join("");
    }
  });
  rt = R2((q) => {
    q.read = function(e, t, r, i, n) {
      var o2, u, s = n * 8 - i - 1, f = (1 << s) - 1, l2 = f >> 1, a2 = -7, c = r ? n - 1 : 0, U = r ? -1 : 1, x3 = e[t + c];
      for (c += U, o2 = x3 & (1 << -a2) - 1, x3 >>= -a2, a2 += s;a2 > 0; o2 = o2 * 256 + e[t + c], c += U, a2 -= 8)
        ;
      for (u = o2 & (1 << -a2) - 1, o2 >>= -a2, a2 += i;a2 > 0; u = u * 256 + e[t + c], c += U, a2 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l2;
      else {
        if (o2 === f)
          return u ? NaN : (x3 ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, i), o2 = o2 - l2;
      }
      return (x3 ? -1 : 1) * u * Math.pow(2, o2 - i);
    };
    q.write = function(e, t, r, i, n, o2) {
      var u, s, f, l2 = o2 * 8 - n - 1, a2 = (1 << l2) - 1, c = a2 >> 1, U = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x3 = i ? 0 : o2 - 1, P3 = i ? 1 : -1, Ct = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, u = a2) : (u = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -u)) < 1 && (u--, f *= 2), u + c >= 1 ? t += U / f : t += U * Math.pow(2, 1 - c), t * f >= 2 && (u++, f /= 2), u + c >= a2 ? (s = 0, u = a2) : u + c >= 1 ? (s = (t * f - 1) * Math.pow(2, n), u = u + c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, n), u = 0));n >= 8; e[r + x3] = s & 255, x3 += P3, s /= 256, n -= 8)
        ;
      for (u = u << n | s, l2 += n;l2 > 0; e[r + x3] = u & 255, x3 += P3, u /= 256, l2 -= 8)
        ;
      e[r + x3 - P3] |= Ct * 128;
    };
  });
  Bt = R2((S) => {
    var G = tt(), T = rt(), et = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    S.Buffer = h2;
    S.SlowBuffer = Vt;
    S.INSPECT_MAX_BYTES = 50;
    var D2 = 2147483647;
    S.kMaxLength = D2;
    h2.TYPED_ARRAY_SUPPORT = Wt();
    !h2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Wt() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h2.prototype, "parent", { enumerable: true, get: function() {
      if (!!h2.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h2.prototype, "offset", { enumerable: true, get: function() {
      if (!!h2.isBuffer(this))
        return this.byteOffset;
    } });
    function E2(e) {
      if (e > D2)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, h2.prototype), t;
    }
    function h2(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return b3(e);
      }
      return ut2(e, t, r);
    }
    h2.poolSize = 8192;
    function ut2(e, t, r) {
      if (typeof e == "string")
        return jt(e, t);
      if (ArrayBuffer.isView(e))
        return bt(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (B(e, ArrayBuffer) || e && B(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (B(e, SharedArrayBuffer) || e && B(e.buffer, SharedArrayBuffer)))
        return Y(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let i = e.valueOf && e.valueOf();
      if (i != null && i !== e)
        return h2.from(i, t, r);
      let n = Ht(e);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return h2.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    h2.from = function(e, t, r) {
      return ut2(e, t, r);
    };
    Object.setPrototypeOf(h2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h2, Uint8Array);
    function ht2(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Yt(e, t, r) {
      return ht2(e), e <= 0 ? E2(e) : t !== undefined ? typeof r == "string" ? E2(e).fill(t, r) : E2(e).fill(t) : E2(e);
    }
    h2.alloc = function(e, t, r) {
      return Yt(e, t, r);
    };
    function b3(e) {
      return ht2(e), E2(e < 0 ? 0 : H(e) | 0);
    }
    h2.allocUnsafe = function(e) {
      return b3(e);
    };
    h2.allocUnsafeSlow = function(e) {
      return b3(e);
    };
    function jt(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !h2.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = st2(e, t) | 0, i = E2(r), n = i.write(e, t);
      return n !== r && (i = i.slice(0, n)), i;
    }
    function W(e) {
      let t = e.length < 0 ? 0 : H(e.length) | 0, r = E2(t);
      for (let i = 0;i < t; i += 1)
        r[i] = e[i] & 255;
      return r;
    }
    function bt(e) {
      if (B(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Y(t.buffer, t.byteOffset, t.byteLength);
      }
      return W(e);
    }
    function Y(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let i;
      return t === undefined && r === undefined ? i = new Uint8Array(e) : r === undefined ? i = new Uint8Array(e, t) : i = new Uint8Array(e, t, r), Object.setPrototypeOf(i, h2.prototype), i;
    }
    function Ht(e) {
      if (h2.isBuffer(e)) {
        let t = H(e.length) | 0, r = E2(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || X(e.length) ? E2(0) : W(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return W(e.data);
    }
    function H(e) {
      if (e >= D2)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + D2.toString(16) + " bytes");
      return e | 0;
    }
    function Vt(e) {
      return +e != e && (e = 0), h2.alloc(+e);
    }
    h2.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== h2.prototype;
    };
    h2.compare = function(t, r) {
      if (B(t, Uint8Array) && (t = h2.from(t, t.offset, t.byteLength)), B(r, Uint8Array) && (r = h2.from(r, r.offset, r.byteLength)), !h2.isBuffer(t) || !h2.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let i = t.length, n = r.length;
      for (let o2 = 0, u = Math.min(i, n);o2 < u; ++o2)
        if (t[o2] !== r[o2]) {
          i = t[o2], n = r[o2];
          break;
        }
      return i < n ? -1 : n < i ? 1 : 0;
    };
    h2.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h2.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return h2.alloc(0);
      let i;
      if (r === undefined)
        for (r = 0, i = 0;i < t.length; ++i)
          r += t[i].length;
      let n = h2.allocUnsafe(r), o2 = 0;
      for (i = 0;i < t.length; ++i) {
        let u = t[i];
        if (B(u, Uint8Array))
          o2 + u.length > n.length ? (h2.isBuffer(u) || (u = h2.from(u)), u.copy(n, o2)) : Uint8Array.prototype.set.call(n, u, o2);
        else if (h2.isBuffer(u))
          u.copy(n, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += u.length;
      }
      return n;
    };
    function st2(e, t) {
      if (h2.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || B(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, i = arguments.length > 2 && arguments[2] === true;
      if (!i && r === 0)
        return 0;
      let n = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return j2(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return dt(e).length;
          default:
            if (n)
              return i ? -1 : j2(e).length;
            t = ("" + t).toLowerCase(), n = true;
        }
    }
    h2.byteLength = st2;
    function Xt(e, t, r) {
      let i = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return ir(this, t, r);
          case "utf8":
          case "utf-8":
            return ct2(this, t, r);
          case "ascii":
            return rr2(this, t, r);
          case "latin1":
          case "binary":
            return er(this, t, r);
          case "base64":
            return vt(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return nr(this, t, r);
          default:
            if (i)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), i = true;
        }
    }
    h2.prototype._isBuffer = true;
    function F(e, t, r) {
      let i = e[t];
      e[t] = e[r], e[r] = i;
    }
    h2.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        F(this, r, r + 1);
      return this;
    };
    h2.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        F(this, r, r + 3), F(this, r + 1, r + 2);
      return this;
    };
    h2.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        F(this, r, r + 7), F(this, r + 1, r + 6), F(this, r + 2, r + 5), F(this, r + 3, r + 4);
      return this;
    };
    h2.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? ct2(this, 0, t) : Xt.apply(this, arguments);
    };
    h2.prototype.toLocaleString = h2.prototype.toString;
    h2.prototype.equals = function(t) {
      if (!h2.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : h2.compare(this, t) === 0;
    };
    h2.prototype.inspect = function() {
      let t = "", r = S.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    et && (h2.prototype[et] = h2.prototype.inspect);
    h2.prototype.compare = function(t, r, i, n, o2) {
      if (B(t, Uint8Array) && (t = h2.from(t, t.offset, t.byteLength)), !h2.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), i === undefined && (i = t ? t.length : 0), n === undefined && (n = 0), o2 === undefined && (o2 = this.length), r < 0 || i > t.length || n < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (n >= o2 && r >= i)
        return 0;
      if (n >= o2)
        return -1;
      if (r >= i)
        return 1;
      if (r >>>= 0, i >>>= 0, n >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let u = o2 - n, s = i - r, f = Math.min(u, s), l2 = this.slice(n, o2), a2 = t.slice(r, i);
      for (let c = 0;c < f; ++c)
        if (l2[c] !== a2[c]) {
          u = l2[c], s = a2[c];
          break;
        }
      return u < s ? -1 : s < u ? 1 : 0;
    };
    function ft2(e, t, r, i, n) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, X(r) && (r = n ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (n)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (n)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = h2.from(t, i)), h2.isBuffer(t))
        return t.length === 0 ? -1 : it(e, t, r, i, n);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : it(e, [t], r, i, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function it(e, t, r, i, n) {
      let o2 = 1, u = e.length, s = t.length;
      if (i !== undefined && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, u /= 2, s /= 2, r /= 2;
      }
      function f(a2, c) {
        return o2 === 1 ? a2[c] : a2.readUInt16BE(c * o2);
      }
      let l2;
      if (n) {
        let a2 = -1;
        for (l2 = r;l2 < u; l2++)
          if (f(e, l2) === f(t, a2 === -1 ? 0 : l2 - a2)) {
            if (a2 === -1 && (a2 = l2), l2 - a2 + 1 === s)
              return a2 * o2;
          } else
            a2 !== -1 && (l2 -= l2 - a2), a2 = -1;
      } else
        for (r + s > u && (r = u - s), l2 = r;l2 >= 0; l2--) {
          let a2 = true;
          for (let c = 0;c < s; c++)
            if (f(e, l2 + c) !== f(t, c)) {
              a2 = false;
              break;
            }
          if (a2)
            return l2;
        }
      return -1;
    }
    h2.prototype.includes = function(t, r, i) {
      return this.indexOf(t, r, i) !== -1;
    };
    h2.prototype.indexOf = function(t, r, i) {
      return ft2(this, t, r, i, true);
    };
    h2.prototype.lastIndexOf = function(t, r, i) {
      return ft2(this, t, r, i, false);
    };
    function Jt(e, t, r, i) {
      r = Number(r) || 0;
      let n = e.length - r;
      i ? (i = Number(i), i > n && (i = n)) : i = n;
      let o2 = t.length;
      i > o2 / 2 && (i = o2 / 2);
      let u;
      for (u = 0;u < i; ++u) {
        let s = parseInt(t.substr(u * 2, 2), 16);
        if (X(s))
          return u;
        e[r + u] = s;
      }
      return u;
    }
    function zt(e, t, r, i) {
      return M2(j2(t, e.length - r), e, r, i);
    }
    function Kt(e, t, r, i) {
      return M2(sr(t), e, r, i);
    }
    function Zt(e, t, r, i) {
      return M2(dt(t), e, r, i);
    }
    function Qt(e, t, r, i) {
      return M2(fr(t, e.length - r), e, r, i);
    }
    h2.prototype.write = function(t, r, i, n) {
      if (r === undefined)
        n = "utf8", i = this.length, r = 0;
      else if (i === undefined && typeof r == "string")
        n = r, i = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === undefined && (n = "utf8")) : (n = i, i = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((i === undefined || i > o2) && (i = o2), t.length > 0 && (i < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u = false;
      for (;; )
        switch (n) {
          case "hex":
            return Jt(this, t, r, i);
          case "utf8":
          case "utf-8":
            return zt(this, t, r, i);
          case "ascii":
          case "latin1":
          case "binary":
            return Kt(this, t, r, i);
          case "base64":
            return Zt(this, t, r, i);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Qt(this, t, r, i);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u = true;
        }
    };
    h2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function vt(e, t, r) {
      return t === 0 && r === e.length ? G.fromByteArray(e) : G.fromByteArray(e.slice(t, r));
    }
    function ct2(e, t, r) {
      r = Math.min(e.length, r);
      let i = [], n = t;
      for (;n < r; ) {
        let o2 = e[n], u = null, s = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (n + s <= r) {
          let f, l2, a2, c;
          switch (s) {
            case 1:
              o2 < 128 && (u = o2);
              break;
            case 2:
              f = e[n + 1], (f & 192) === 128 && (c = (o2 & 31) << 6 | f & 63, c > 127 && (u = c));
              break;
            case 3:
              f = e[n + 1], l2 = e[n + 2], (f & 192) === 128 && (l2 & 192) === 128 && (c = (o2 & 15) << 12 | (f & 63) << 6 | l2 & 63, c > 2047 && (c < 55296 || c > 57343) && (u = c));
              break;
            case 4:
              f = e[n + 1], l2 = e[n + 2], a2 = e[n + 3], (f & 192) === 128 && (l2 & 192) === 128 && (a2 & 192) === 128 && (c = (o2 & 15) << 18 | (f & 63) << 12 | (l2 & 63) << 6 | a2 & 63, c > 65535 && c < 1114112 && (u = c));
          }
        }
        u === null ? (u = 65533, s = 1) : u > 65535 && (u -= 65536, i.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), i.push(u), n += s;
      }
      return tr(i);
    }
    var nt2 = 4096;
    function tr(e) {
      let t = e.length;
      if (t <= nt2)
        return String.fromCharCode.apply(String, e);
      let r = "", i = 0;
      for (;i < t; )
        r += String.fromCharCode.apply(String, e.slice(i, i += nt2));
      return r;
    }
    function rr2(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n] & 127);
      return i;
    }
    function er(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n]);
      return i;
    }
    function ir(e, t, r) {
      let i = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
      let n = "";
      for (let o2 = t;o2 < r; ++o2)
        n += cr[e[o2]];
      return n;
    }
    function nr(e, t, r) {
      let i = e.slice(t, r), n = "";
      for (let o2 = 0;o2 < i.length - 1; o2 += 2)
        n += String.fromCharCode(i[o2] + i[o2 + 1] * 256);
      return n;
    }
    h2.prototype.slice = function(t, r) {
      let i = this.length;
      t = ~~t, r = r === undefined ? i : ~~r, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < t && (r = t);
      let n = this.subarray(t, r);
      return Object.setPrototypeOf(n, h2.prototype), n;
    };
    function p(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h2.prototype.readUintLE = h2.prototype.readUIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p(t, r, this.length);
      let n = this[t], o2 = 1, u = 0;
      for (;++u < r && (o2 *= 256); )
        n += this[t + u] * o2;
      return n;
    };
    h2.prototype.readUintBE = h2.prototype.readUIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p(t, r, this.length);
      let n = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        n += this[t + --r] * o2;
      return n;
    };
    h2.prototype.readUint8 = h2.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || p(t, 1, this.length), this[t];
    };
    h2.prototype.readUint16LE = h2.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || p(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    h2.prototype.readUint16BE = h2.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || p(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    h2.prototype.readUint32LE = h2.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    h2.prototype.readUint32BE = h2.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    h2.prototype.readBigUInt64LE = m2(function(t) {
      t = t >>> 0, N2(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _2(t, this.length - 8);
      let n = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + i * 2 ** 24;
      return BigInt(n) + (BigInt(o2) << BigInt(32));
    });
    h2.prototype.readBigUInt64BE = m2(function(t) {
      t = t >>> 0, N2(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _2(t, this.length - 8);
      let n = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i;
      return (BigInt(n) << BigInt(32)) + BigInt(o2);
    });
    h2.prototype.readIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p(t, r, this.length);
      let n = this[t], o2 = 1, u = 0;
      for (;++u < r && (o2 *= 256); )
        n += this[t + u] * o2;
      return o2 *= 128, n >= o2 && (n -= Math.pow(2, 8 * r)), n;
    };
    h2.prototype.readIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p(t, r, this.length);
      let n = r, o2 = 1, u = this[t + --n];
      for (;n > 0 && (o2 *= 256); )
        u += this[t + --n] * o2;
      return o2 *= 128, u >= o2 && (u -= Math.pow(2, 8 * r)), u;
    };
    h2.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || p(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    h2.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || p(t, 2, this.length);
      let i = this[t] | this[t + 1] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h2.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || p(t, 2, this.length);
      let i = this[t + 1] | this[t] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h2.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    h2.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    h2.prototype.readBigInt64LE = m2(function(t) {
      t = t >>> 0, N2(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _2(t, this.length - 8);
      let n = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (i << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    h2.prototype.readBigInt64BE = m2(function(t) {
      t = t >>> 0, N2(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _2(t, this.length - 8);
      let n = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i);
    });
    h2.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), T.read(this, t, true, 23, 4);
    };
    h2.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || p(t, 4, this.length), T.read(this, t, false, 23, 4);
    };
    h2.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || p(t, 8, this.length), T.read(this, t, true, 52, 8);
    };
    h2.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || p(t, 8, this.length), T.read(this, t, false, 52, 8);
    };
    function y2(e, t, r, i, n, o2) {
      if (!h2.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > n || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + i > e.length)
        throw new RangeError("Index out of range");
    }
    h2.prototype.writeUintLE = h2.prototype.writeUIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s = Math.pow(2, 8 * i) - 1;
        y2(this, t, r, i, s, 0);
      }
      let o2 = 1, u = 0;
      for (this[r] = t & 255;++u < i && (o2 *= 256); )
        this[r + u] = t / o2 & 255;
      return r + i;
    };
    h2.prototype.writeUintBE = h2.prototype.writeUIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s = Math.pow(2, 8 * i) - 1;
        y2(this, t, r, i, s, 0);
      }
      let o2 = i - 1, u = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (u *= 256); )
        this[r + o2] = t / u & 255;
      return r + i;
    };
    h2.prototype.writeUint8 = h2.prototype.writeUInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    h2.prototype.writeUint16LE = h2.prototype.writeUInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h2.prototype.writeUint16BE = h2.prototype.writeUInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h2.prototype.writeUint32LE = h2.prototype.writeUInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    h2.prototype.writeUint32BE = h2.prototype.writeUInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function at2(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let u = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, r;
    }
    function lt2(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let u = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = u, u = u >> 8, e[r + 2] = u, u = u >> 8, e[r + 1] = u, u = u >> 8, e[r] = u, r + 8;
    }
    h2.prototype.writeBigUInt64LE = m2(function(t, r = 0) {
      return at2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h2.prototype.writeBigUInt64BE = m2(function(t, r = 0) {
      return lt2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h2.prototype.writeIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f = Math.pow(2, 8 * i - 1);
        y2(this, t, r, i, f - 1, -f);
      }
      let o2 = 0, u = 1, s = 0;
      for (this[r] = t & 255;++o2 < i && (u *= 256); )
        t < 0 && s === 0 && this[r + o2 - 1] !== 0 && (s = 1), this[r + o2] = (t / u >> 0) - s & 255;
      return r + i;
    };
    h2.prototype.writeIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f = Math.pow(2, 8 * i - 1);
        y2(this, t, r, i, f - 1, -f);
      }
      let o2 = i - 1, u = 1, s = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (u *= 256); )
        t < 0 && s === 0 && this[r + o2 + 1] !== 0 && (s = 1), this[r + o2] = (t / u >> 0) - s & 255;
      return r + i;
    };
    h2.prototype.writeInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    h2.prototype.writeInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h2.prototype.writeInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h2.prototype.writeInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    h2.prototype.writeInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y2(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    h2.prototype.writeBigInt64LE = m2(function(t, r = 0) {
      return at2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h2.prototype.writeBigInt64BE = m2(function(t, r = 0) {
      return lt2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function pt2(e, t, r, i, n, o2) {
      if (r + i > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function yt(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T.write(e, t, r, i, 23, 4), r + 4;
    }
    h2.prototype.writeFloatLE = function(t, r, i) {
      return yt(this, t, r, true, i);
    };
    h2.prototype.writeFloatBE = function(t, r, i) {
      return yt(this, t, r, false, i);
    };
    function wt(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T.write(e, t, r, i, 52, 8), r + 8;
    }
    h2.prototype.writeDoubleLE = function(t, r, i) {
      return wt(this, t, r, true, i);
    };
    h2.prototype.writeDoubleBE = function(t, r, i) {
      return wt(this, t, r, false, i);
    };
    h2.prototype.copy = function(t, r, i, n) {
      if (!h2.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (i < 0 || i >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), t.length - r < n - i && (n = t.length - r + i);
      let o2 = n - i;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : Uint8Array.prototype.set.call(t, this.subarray(i, n), r), o2;
    };
    h2.prototype.fill = function(t, r, i, n) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h2.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (t.length === 1) {
          let u = t.charCodeAt(0);
          (n === "utf8" && u < 128 || n === "latin1") && (t = u);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < i)
        throw new RangeError("Out of range index");
      if (i <= r)
        return this;
      r = r >>> 0, i = i === undefined ? this.length : i >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < i; ++o2)
          this[o2] = t;
      else {
        let u = h2.isBuffer(t) ? t : h2.from(t, n), s = u.length;
        if (s === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < i - r; ++o2)
          this[o2 + r] = u[o2 % s];
      }
      return this;
    };
    var C2 = {};
    function V(e, t, r) {
      C2[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(e, t, r) {
      let i = `The value of "${e}" is out of range.`, n = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = ot2(String(r)) : typeof r == "bigint" && (n = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (n = ot2(n)), n += "n"), i += ` It must be ${t}. Received ${n}`, i;
    }, RangeError);
    function ot2(e) {
      let t = "", r = e.length, i = e[0] === "-" ? 1 : 0;
      for (;r >= i + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function or(e, t, r) {
      N2(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && _2(t, e.length - (r + 1));
    }
    function xt(e, t, r, i, n, o2) {
      if (e > r || e < t) {
        let u = typeof t == "bigint" ? "n" : "", s;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s = `>= 0${u} and < 2${u} ** ${(o2 + 1) * 8}${u}` : s = `>= -(2${u} ** ${(o2 + 1) * 8 - 1}${u}) and < 2 ** ${(o2 + 1) * 8 - 1}${u}` : s = `>= ${t}${u} and <= ${r}${u}`, new C2.ERR_OUT_OF_RANGE("value", s, e);
      }
      or(i, n, o2);
    }
    function N2(e, t) {
      if (typeof e != "number")
        throw new C2.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function _2(e, t, r) {
      throw Math.floor(e) !== e ? (N2(e, r), new C2.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new C2.ERR_BUFFER_OUT_OF_BOUNDS : new C2.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var ur = /[^+/0-9A-Za-z-_]/g;
    function hr(e) {
      if (e = e.split("=")[0], e = e.trim().replace(ur, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function j2(e, t) {
      t = t || 1 / 0;
      let r, i = e.length, n = null, o2 = [];
      for (let u = 0;u < i; ++u) {
        if (r = e.charCodeAt(u), r > 55295 && r < 57344) {
          if (!n) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (u + 1 === i) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            n = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), n = r;
            continue;
          }
          r = (n - 55296 << 10 | r - 56320) + 65536;
        } else
          n && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (n = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function sr(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function fr(e, t) {
      let r, i, n, o2 = [];
      for (let u = 0;u < e.length && !((t -= 2) < 0); ++u)
        r = e.charCodeAt(u), i = r >> 8, n = r % 256, o2.push(n), o2.push(i);
      return o2;
    }
    function dt(e) {
      return G.toByteArray(hr(e));
    }
    function M2(e, t, r, i) {
      let n;
      for (n = 0;n < i && !(n + r >= t.length || n >= e.length); ++n)
        t[n + r] = e[n];
      return n;
    }
    function B(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function X(e) {
      return e !== e;
    }
    var cr = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let i = r * 16;
        for (let n = 0;n < 16; ++n)
          t[i + n] = e[r] + e[n];
      }
      return t;
    }();
    function m2(e) {
      return typeof BigInt > "u" ? ar : e;
    }
    function ar() {
      throw new Error("BigInt not supported");
    }
  });
  mt = R2((J, Et) => {
    var $2 = Bt(), g2 = $2.Buffer;
    function gt(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    g2.from && g2.alloc && g2.allocUnsafe && g2.allocUnsafeSlow ? Et.exports = $2 : (gt($2, J), J.Buffer = A2);
    function A2(e, t, r) {
      return g2(e, t, r);
    }
    A2.prototype = Object.create(g2.prototype);
    gt(g2, A2);
    A2.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return g2(e, t, r);
    };
    A2.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var i = g2(e);
      return t !== undefined ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
    };
    A2.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return g2(e);
    };
    A2.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return $2.SlowBuffer(e);
    };
  });
  At = R2((Ft) => {
    var K2 = mt().Buffer, It = K2.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function lr(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function pr(e) {
      var t = lr(e);
      if (typeof t != "string" && (K2.isEncoding === It || !It(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    Ft.StringDecoder = L2;
    function L2(e) {
      this.encoding = pr(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = gr2, this.end = Er2, t = 4;
          break;
        case "utf8":
          this.fillLast = xr, t = 4;
          break;
        case "base64":
          this.text = mr2, this.end = Ir2, t = 3;
          break;
        default:
          this.write = Fr2, this.end = Ar2;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = K2.allocUnsafe(t);
    }
    L2.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    L2.prototype.end = Br2;
    L2.prototype.text = dr;
    L2.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function z(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function yr(e, t, r) {
      var i = t.length - 1;
      if (i < r)
        return 0;
      var n = z(t[i]);
      return n >= 0 ? (n > 0 && (e.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (e.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : e.lastNeed = n - 3), n) : 0));
    }
    function wr(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function xr(e) {
      var t = this.lastTotal - this.lastNeed, r = wr(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function dr(e, t) {
      var r = yr(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var i = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i);
    }
    function Br2(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function gr2(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var i = r.charCodeAt(r.length - 1);
          if (i >= 55296 && i <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Er2(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function mr2(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ir2(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Fr2(e) {
      return e.toString(this.encoding);
    }
    function Ar2(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Ut = kt(At());
  export_StringDecoder = Ut.StringDecoder;
  export_default2 = Ut.StringDecoder;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;
  function from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer2) {
      return new Readable({
        objectMode: true,
        ...opts,
        read() {
          this.push(iterable);
          this.push(null);
        }
      });
    }
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator]) {
      isAsync = true;
      iterator = iterable[SymbolAsyncIterator]();
    } else if (iterable && iterable[SymbolIterator]) {
      isAsync = false;
      iterator = iterable[SymbolIterator]();
    } else {
      throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
    }
    const readable = new Readable({
      objectMode: true,
      highWaterMark: 1,
      ...opts
    });
    let reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    readable._destroy = function(error, cb) {
      PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
    };
    async function close(error) {
      const hadError = error !== undefined && error !== null;
      const hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        const { value, done } = await iterator.throw(error);
        await value;
        if (done) {
          return;
        }
      }
      if (typeof iterator.return === "function") {
        const { value } = await iterator.return();
        await value;
      }
    }
    async function next() {
      for (;; ) {
        try {
          const { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done) {
            readable.push(null);
          } else {
            const res = value && typeof value.then === "function" ? await value : value;
            if (res === null) {
              reading = false;
              throw new ERR_STREAM_NULL_VALUES;
            } else if (readable.push(res)) {
              continue;
            } else {
              reading = false;
            }
          }
        } catch (err) {
          readable.destroy(err);
        }
        break;
      }
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = require_primordials();
  module.exports = Readable;
  Readable.ReadableState = ReadableState;
  var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
  var { Stream, prependListener } = require_legacy();
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { addAbortSignal } = require_add_abort_signal();
  var eos = require_end_of_stream();
  var debug = require_util2().debuglog("stream", (fn) => {
    debug = fn;
  });
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = require_errors();
  var { validateObject } = require_validators();
  var kPaused = Symbol2("kPaused");
  var { StringDecoder } = (init_string_decoder(), __toCommonJS(exports_string_decoder));
  var from = require_from();
  ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Readable, Stream);
  var nop = () => {
  };
  var { errorOrDestroy } = destroyImpl;
  var kObjectMode = 1 << 0;
  var kEnded = 1 << 1;
  var kEndEmitted = 1 << 2;
  var kReading = 1 << 3;
  var kConstructed = 1 << 4;
  var kSync = 1 << 5;
  var kNeedReadable = 1 << 6;
  var kEmittedReadable = 1 << 7;
  var kReadableListening = 1 << 8;
  var kResumeScheduled = 1 << 9;
  var kErrorEmitted = 1 << 10;
  var kEmitClose = 1 << 11;
  var kAutoDestroy = 1 << 12;
  var kDestroyed = 1 << 13;
  var kClosed = 1 << 14;
  var kCloseEmitted = 1 << 15;
  var kMultiAwaitDrain = 1 << 16;
  var kReadingMore = 1 << 17;
  var kDataEmitted = 1 << 18;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: false,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      }
    };
  }
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    constructed: makeBitMapDescriptor(kConstructed),
    sync: makeBitMapDescriptor(kSync),
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    destroyed: makeBitMapDescriptor(kDestroyed),
    closed: makeBitMapDescriptor(kClosed),
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
    if (options && options.objectMode)
      this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode)
      this.state |= kObjectMode;
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this[kPaused] = null;
    if (options && options.emitClose === false)
      this.state &= ~kEmitClose;
    if (options && options.autoDestroy === false)
      this.state &= ~kAutoDestroy;
    this.errored = null;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    const isDuplex = this instanceof require_duplex();
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal && !isDuplex)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      if (this._readableState.needReadable) {
        maybeReadMore(this, this._readableState);
      }
    });
  }
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed) {
      error = this.readableEnded ? null : new AbortError;
      this.destroy(error);
    }
    return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if ((state.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (state.encoding !== encoding) {
          if (addToFront && state.encoding) {
            chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
          } else {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "";
      } else if (chunk != null) {
        err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    if (err) {
      errorOrDestroy(stream, err);
    } else if (chunk === null) {
      state.state &= ~kReading;
      onEofChunk(stream, state);
    } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
      if (addToFront) {
        if ((state.state & kEndEmitted) !== 0)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
        else if (state.destroyed || state.errored)
          return false;
        else
          addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
      } else if (state.destroyed || state.errored) {
        return false;
      } else {
        state.state &= ~kReading;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.state &= ~kReading;
      maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
      if ((state.state & kMultiAwaitDrain) !== 0) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
      state.dataEmitted = true;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if ((state.state & kNeedReadable) !== 0)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer) {
      content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "")
      buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM) {
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if ((state.state & kObjectMode) !== 0)
      return 1;
    if (NumberIsNaN(n)) {
      if (state.flowing && state.length)
        return state.buffer.first().length;
      return state.length;
    }
    if (n <= state.length)
      return n;
    return state.ended ? state.length : 0;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
      n = NaN;
    } else if (!NumberIsInteger(n)) {
      n = NumberParseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0)
      state.state &= ~kEmittedReadable;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    let doRead = (state.state & kNeedReadable) !== 0;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
      doRead = false;
      debug("reading, ended or constructing", doRead);
    } else if (doRead) {
      debug("do read");
      state.state |= kReading | kSync;
      if (state.length === 0)
        state.state |= kNeedReadable;
      try {
        this._read(state.highWaterMark);
      } catch (err) {
        errorOrDestroy(this, err);
      }
      state.state &= ~kSync;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    let ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      if (state.multiAwaitDrain) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
      state.dataEmitted = true;
      this.emit("data", ret);
    }
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      const chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
  function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process2.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
      state.readingMore = true;
      process2.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      const len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
      if (!state.multiAwaitDrain) {
        state.multiAwaitDrain = true;
        state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process2.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      if (ondrain) {
        dest.removeListener("drain", ondrain);
      }
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    function pause() {
      if (!cleanedUp) {
        if (state.pipes.length === 1 && state.pipes[0] === dest) {
          debug("false write response, pause", 0);
          state.awaitDrainWriters = dest;
          state.multiAwaitDrain = false;
        } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
          debug("false write response, pause", state.awaitDrainWriters.size);
          state.awaitDrainWriters.add(dest);
        }
        src.pause();
      }
      if (!ondrain) {
        ondrain = pipeOnDrain(src, dest);
        dest.on("drain", ondrain);
      }
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      const ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (dest.listenerCount("error") === 0) {
        const s = dest._writableState || dest._readableState;
        if (s && !s.errorEmitted) {
          errorOrDestroy(dest, er);
        } else {
          dest.emit("error", er);
        }
      }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
      pause();
    } else if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
      const state = src._readableState;
      if (state.awaitDrainWriters === dest) {
        debug("pipeOnDrain", 1);
        state.awaitDrainWriters = null;
      } else if (state.multiAwaitDrain) {
        debug("pipeOnDrain", state.awaitDrainWriters.size);
        state.awaitDrainWriters.delete(dest);
      }
      if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
        src.resume();
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipes.length === 0)
      return this;
    if (!dest) {
      const dests = state.pipes;
      state.pipes = [];
      this.pause();
      for (let i = 0;i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    const index = ArrayPrototypeIndexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0)
      this.pause();
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process2.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process2.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    const state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    } else if (!state.readableListening) {
      state.flowing = null;
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state[kPaused] = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process2.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
  };
  function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk) => {
      if (!this.push(chunk) && stream.pause) {
        paused = true;
        stream.pause();
      }
    });
    stream.on("end", () => {
      this.push(null);
    });
    stream.on("error", (err) => {
      errorOrDestroy(this, err);
    });
    stream.on("close", () => {
      this.destroy();
    });
    stream.on("destroy", () => {
      this.destroy();
    });
    this._read = () => {
      if (paused && stream.resume) {
        paused = false;
        stream.resume();
      }
    };
    const streamKeys = ObjectKeys(stream);
    for (let j2 = 1;j2 < streamKeys.length; j2++) {
      const i = streamKeys[j2];
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = stream[i].bind(stream);
      }
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
      validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
      stream = Readable.wrap(stream, {
        objectMode: true
      });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
  }
  async function* createAsyncIterator(stream, options) {
    let callback = nop;
    function next(resolve) {
      if (this === stream) {
        callback();
        callback = nop;
      } else {
        callback = resolve;
      }
    }
    stream.on("readable", next);
    let error;
    const cleanup = eos(stream, {
      writable: false
    }, (err) => {
      error = err ? aggregateTwoErrors(error, err) : null;
      callback();
      callback = nop;
    });
    try {
      while (true) {
        const chunk = stream.destroyed ? null : stream.read();
        if (chunk !== null) {
          yield chunk;
        } else if (error) {
          throw error;
        } else if (error === null) {
          return;
        } else {
          await new Promise2(next);
        }
      }
    } catch (err) {
      error = aggregateTwoErrors(error, err);
      throw error;
    } finally {
      if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {
        destroyImpl.destroyer(stream, null);
      } else {
        stream.off("readable", next);
        cleanup();
      }
    }
  }
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        const r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState) {
          this._readableState.readable = !!val;
        }
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.objectMode : false;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.destroyed : false;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.endEmitted : false;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== false;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    let ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process2.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.emit("end");
      if (stream.writable && stream.allowHalfOpen === false) {
        process2.nextTick(endWritableNT, stream);
      } else if (state.autoDestroy) {
        const wState = stream._writableState;
        const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
  }
  function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
      stream.end();
    }
  }
  Readable.from = function(iterable, opts) {
    return from(Readable, iterable, opts);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,
      ...options,
      destroy(err, callback) {
        destroyImpl.destroyer(src, err);
        callback(err);
      }
    }).wrap(src);
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = require_primordials();
  module.exports = Writable;
  Writable.WritableState = WritableState;
  var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
  var Stream = require_legacy().Stream;
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var destroyImpl = require_destroy();
  var { addAbortSignal } = require_add_abort_signal();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
  var {
    ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = require_errors().codes;
  var { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Writable, Stream);
  function nop() {
  }
  var kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex)
      this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
  }
  function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  };
  ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    const isDuplex = this instanceof require_duplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      const state = this._writableState;
      if (!state.writing) {
        clearBuffer(this, state);
      }
      finishMaybe(this, state);
    });
  }
  ObjectDefineProperty(Writable, SymbolHasInstance, {
    __proto__: null,
    value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    }
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = state.defaultEncoding;
    } else {
      if (!encoding)
        encoding = state.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function")
        cb = nop;
    }
    if (chunk === null) {
      throw new ERR_STREAM_NULL_VALUES;
    } else if (!state.objectMode) {
      if (typeof chunk === "string") {
        if (state.decodeStrings !== false) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "buffer";
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "buffer";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "buffer";
      } else {
        throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    let err;
    if (state.ending) {
      err = new ERR_STREAM_WRITE_AFTER_END;
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
      process2.nextTick(cb, err);
      errorOrDestroy(stream, err, true);
      return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer2.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked || state.errored || !state.constructed) {
      state.buffered.push({
        chunk,
        encoding,
        callback
      });
      if (state.allBuffers && encoding !== "buffer") {
        state.allBuffers = false;
      }
      if (state.allNoop && callback !== nop) {
        state.allNoop = false;
      }
    } else {
      state.writelen = len;
      state.writecb = callback;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy(stream, er);
  }
  function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
      return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
      er.stack;
      if (!state.errored) {
        state.errored = er;
      }
      if (stream._readableState && !stream._readableState.errored) {
        stream._readableState.errored = er;
      }
      if (sync) {
        process2.nextTick(onwriteError, stream, state, er, cb);
      } else {
        onwriteError(stream, state, er, cb);
      }
    } else {
      if (state.buffered.length > state.bufferedIndex) {
        clearBuffer(stream, state);
      }
      if (sync) {
        if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
          state.afterWriteTickInfo.count++;
        } else {
          state.afterWriteTickInfo = {
            count: 1,
            cb,
            stream,
            state
          };
          process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
        }
      } else {
        afterWrite(stream, state, 1, cb);
      }
    }
  }
  function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
  }
  function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
    while (count-- > 0) {
      state.pendingcb--;
      cb();
    }
    if (state.destroyed) {
      errorBuffer(state);
    }
    finishMaybe(stream, state);
  }
  function errorBuffer(state) {
    if (state.writing) {
      return;
    }
    for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
      var _state$errored;
      const { chunk, callback } = state.buffered[n];
      const len = state.objectMode ? 1 : chunk.length;
      state.length -= len;
      callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
  }
  function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
      return;
    }
    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
      return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
      state.pendingcb -= bufferedLength - 1;
      const callback = state.allNoop ? nop : (err) => {
        for (let n = i;n < buffered.length; ++n) {
          buffered[n].callback(err);
        }
      };
      const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state.allBuffers;
      doWrite(stream, state, true, state.length, chunks, "", callback);
      resetBuffer(state);
    } else {
      do {
        const { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        const len = objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, callback);
      } while (i < buffered.length && !state.writing);
      if (i === buffered.length) {
        resetBuffer(state);
      } else if (i > 256) {
        buffered.splice(0, i);
        state.bufferedIndex = 0;
      } else {
        state.bufferedIndex = i;
      }
    }
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
      this._writev([
        {
          chunk,
          encoding
        }
      ], cb);
    } else {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
      const ret = _write(this, chunk, encoding);
      if (ret instanceof Error2) {
        err = ret;
      }
    }
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (err) {
    } else if (!state.errored && !state.ending) {
      state.ending = true;
      finishMaybe(this, state, true);
      state.ended = true;
    } else if (state.finished) {
      err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
      if (err || state.finished) {
        process2.nextTick(cb, err);
      } else {
        state[kOnFinished].push(cb);
      }
    }
    return this;
  };
  function needFinish(state) {
    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
  }
  function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      state.pendingcb--;
      if (err) {
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0;i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i](err);
        }
        errorOrDestroy(stream, err, state.sync);
      } else if (needFinish(state)) {
        state.prefinished = true;
        stream.emit("prefinish");
        state.pendingcb++;
        process2.nextTick(finish, stream, state);
      }
    }
    state.sync = true;
    state.pendingcb++;
    try {
      stream._final(onFinish);
    } catch (err) {
      onFinish(err);
    }
    state.sync = false;
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.finalCalled = true;
        callFinal(stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        if (sync) {
          state.pendingcb++;
          process2.nextTick((stream2, state2) => {
            if (needFinish(state2)) {
              finish(stream2, state2);
            } else {
              state2.pendingcb--;
            }
          }, stream, state);
        } else if (needFinish(state)) {
          state.pendingcb++;
          finish(stream, state);
        }
      }
    }
  }
  function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
      const rState = stream._readableState;
      const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : false;
      },
      set(value) {
        if (this._writableState) {
          this._writableState.destroyed = value;
        }
      }
    },
    writable: {
      __proto__: null,
      get() {
        const w3 = this._writableState;
        return !!w3 && w3.writable !== false && !w3.destroyed && !w3.errored && !w3.ending && !w3.ended;
      },
      set(val) {
        if (this._writableState) {
          this._writableState.writable = !!val;
        }
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : false;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : false;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : false;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const wState = this._writableState;
        if (!wState)
          return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  var destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
      process2.nextTick(errorBuffer, state);
    }
    destroy.call(this, err, cb);
    return this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Writable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var bufferModule = (init_buffer(), __toCommonJS(exports_buffer));
  var {
    isReadable,
    isWritable,
    isIterable,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = require_utils();
  var eos = require_end_of_stream();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
  } = require_errors();
  var { destroyer } = require_destroy();
  var Duplex = require_duplex();
  var Readable = require_readable();
  var Writable = require_writable();
  var { createDeferredPromise } = require_util2();
  var from = require_from();
  var Blob2 = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob2 !== "undefined" ? function isBlob(b3) {
    return b3 instanceof Blob2;
  } : function isBlob(b3) {
    return false;
  };
  var AbortController = globalThis.AbortController || require_browser().AbortController;
  var { FunctionPrototypeCall } = require_primordials();

  class Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === undefined ? undefined : options.readable) === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if ((options === null || options === undefined ? undefined : options.writable) === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
  }
  module.exports = function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
      return body;
    }
    if (isReadableNodeStream(body)) {
      return _duplexify({
        readable: body
      });
    }
    if (isWritableNodeStream(body)) {
      return _duplexify({
        writable: body
      });
    }
    if (isNodeStream(body)) {
      return _duplexify({
        writable: false,
        readable: false
      });
    }
    if (isReadableStream(body)) {
      return _duplexify({
        readable: Readable.fromWeb(body)
      });
    }
    if (isWritableStream(body)) {
      return _duplexify({
        writable: Writable.fromWeb(body)
      });
    }
    if (typeof body === "function") {
      const { value, write, final, destroy } = fromAsyncGen(body);
      if (isIterable(value)) {
        return from(Duplexify, value, {
          objectMode: true,
          write,
          final,
          destroy
        });
      }
      const then2 = value === null || value === undefined ? undefined : value.then;
      if (typeof then2 === "function") {
        let d2;
        const promise = FunctionPrototypeCall(then2, value, (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }
        }, (err) => {
          destroyer(d2, err);
        });
        return d2 = new Duplexify({
          objectMode: true,
          readable: false,
          write,
          final(cb) {
            final(async () => {
              try {
                await promise;
                process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
      return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
      return from(Duplexify, body, {
        objectMode: true,
        writable: false
      });
    }
    if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {
      return Duplexify.fromWeb(body);
    }
    if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
      const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;
      const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
      return _duplexify({
        readable,
        writable
      });
    }
    const then = body === null || body === undefined ? undefined : body.then;
    if (typeof then === "function") {
      let d2;
      FunctionPrototypeCall(then, body, (val) => {
        if (val != null) {
          d2.push(val);
        }
        d2.push(null);
      }, (err) => {
        destroyer(d2, err);
      });
      return d2 = new Duplexify({
        objectMode: true,
        writable: false,
        read() {
        }
      });
    }
    throw new ERR_INVALID_ARG_TYPE2(name, [
      "Blob",
      "ReadableStream",
      "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ], body);
  };
  function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController;
    const signal = ac.signal;
    const value = fn(async function* () {
      while (true) {
        const _promise = promise;
        promise = null;
        const { chunk, done, cb } = await _promise;
        process2.nextTick(cb);
        if (done)
          return;
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          });
        ({ promise, resolve } = createDeferredPromise());
        yield chunk;
      }
    }(), {
      signal
    });
    return {
      value,
      write(chunk, encoding, cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          chunk,
          done: false,
          cb
        });
      },
      final(cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          done: true,
          cb
        });
      },
      destroy(err, cb) {
        ac.abort();
        cb(err);
      }
    };
  }
  function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w3 = pair.writable;
    let readable = !!isReadable(r);
    let writable = !!isWritable(w3);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d2;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d2.destroy(err);
      }
    }
    d2 = new Duplexify({
      readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
      writableObjectMode: !!(w3 !== null && w3 !== undefined && w3.writableObjectMode),
      readable,
      writable
    });
    if (writable) {
      eos(w3, (err) => {
        writable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      d2._write = function(chunk, encoding, callback) {
        if (w3.write(chunk, encoding)) {
          callback();
        } else {
          ondrain = callback;
        }
      };
      d2._final = function(callback) {
        w3.end();
        onfinish = callback;
      };
      w3.on("drain", function() {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb();
        }
      });
      w3.on("finish", function() {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      eos(r, (err) => {
        readable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      r.on("readable", function() {
        if (onreadable) {
          const cb = onreadable;
          onreadable = null;
          cb();
        }
      });
      r.on("end", function() {
        d2.push(null);
      });
      d2._read = function() {
        while (true) {
          const buf = r.read();
          if (buf === null) {
            onreadable = d2._read;
            return;
          }
          if (!d2.push(buf)) {
            return;
          }
        }
      };
    }
    d2._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        destroyer(w3, err);
        destroyer(r, err);
      }
    };
    return d2;
  }
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS((exports, module) => {
  var {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = require_primordials();
  module.exports = Duplex;
  var Readable = require_readable();
  var Writable = require_writable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    const keys = ObjectKeys(Writable.prototype);
    for (let i = 0;i < keys.length; i++) {
      const method = keys[i];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options) {
      this.allowHalfOpen = options.allowHalfOpen !== false;
      if (options.readable === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if (options.writable === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    } else {
      this.allowHalfOpen = true;
    }
  }
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState) {
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      }
    }
  });
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
  };
  var duplexify;
  Duplex.from = function(body) {
    if (!duplexify) {
      duplexify = require_duplexify();
    }
    return duplexify(body, "body");
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
  module.exports = Transform;
  var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
  var Duplex = require_duplex();
  var { getHighWaterMark } = require_state();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  var kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
    if (readableHighWaterMark === 0) {
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed) {
      this._flush((er, data) => {
        if (er) {
          if (cb) {
            cb(er);
          } else {
            this.destroy(er);
          }
          return;
        }
        if (data != null) {
          this.push(data);
        }
        this.push(null);
        if (cb) {
          cb();
        }
      });
    } else {
      this.push(null);
      if (cb) {
        cb();
      }
    }
  }
  function prefinish() {
    if (this._final !== final) {
      final.call(this);
    }
  }
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    this._transform(chunk, encoding, (err, val) => {
      if (err) {
        callback(err);
        return;
      }
      if (val != null) {
        this.push(val);
      }
      if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) {
        callback();
      } else {
        this[kCallback] = callback;
      }
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      const callback = this[kCallback];
      this[kCallback] = null;
      callback();
    }
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf } = require_primordials();
  module.exports = PassThrough;
  var Transform = require_transform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var process2 = require_browser2();
  var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
  var eos = require_end_of_stream();
  var { once } = require_util2();
  var destroyImpl = require_destroy();
  var Duplex = require_duplex();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = require_errors();
  var { validateFunction, validateAbortSignal } = require_validators();
  var {
    isIterable,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = require_utils();
  var AbortController = globalThis.AbortController || require_browser().AbortController;
  var PassThrough;
  var Readable;
  var addAbortListener;
  function destroyer(stream, reading, writing) {
    let finished = false;
    stream.on("close", () => {
      finished = true;
    });
    const cleanup = eos(stream, {
      readable: reading,
      writable: writing
    }, (err) => {
      finished = !err;
    });
    return {
      destroy: (err) => {
        if (finished)
          return;
        finished = true;
        destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      },
      cleanup
    };
  }
  function popCallback(streams) {
    validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
    return streams.pop();
  }
  function makeAsyncIterable(val) {
    if (isIterable(val)) {
      return val;
    } else if (isReadableNodeStream(val)) {
      return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  async function* fromReadable(val) {
    if (!Readable) {
      Readable = require_readable();
    }
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  async function pumpToNode(iterable, writable, finish, { end }) {
    let error;
    let onresolve = null;
    const resume = (err) => {
      if (err) {
        error = err;
      }
      if (onresolve) {
        const callback = onresolve;
        onresolve = null;
        callback();
      }
    };
    const wait = () => new Promise2((resolve, reject) => {
      if (error) {
        reject(error);
      } else {
        onresolve = () => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        };
      }
    });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
      readable: false
    }, resume);
    try {
      if (writable.writableNeedDrain) {
        await wait();
      }
      for await (const chunk of iterable) {
        if (!writable.write(chunk)) {
          await wait();
        }
      }
      if (end) {
        writable.end();
        await wait();
      }
      finish();
    } catch (err) {
      finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
      cleanup();
      writable.off("drain", resume);
    }
  }
  async function pumpToWeb(readable, writable, finish, { end }) {
    if (isTransformStream(writable)) {
      writable = writable.writable;
    }
    const writer = writable.getWriter();
    try {
      for await (const chunk of readable) {
        await writer.ready;
        writer.write(chunk).catch(() => {
        });
      }
      await writer.ready;
      if (end) {
        await writer.close();
      }
      finish();
    } catch (err) {
      try {
        await writer.abort(err);
        finish(err);
      } catch (err2) {
        finish(err2);
      }
    }
  }
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0])) {
      streams = streams[0];
    }
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController;
    const signal = ac.signal;
    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;
    const lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError);
    }
    addAbortListener = addAbortListener || require_util2().addAbortListener;
    let disposable;
    if (outerSignal) {
      disposable = addAbortListener(outerSignal, abort);
    }
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
      finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, final) {
      var _disposable;
      if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
        error = err;
      }
      if (!error && !final) {
        return;
      }
      while (destroys.length) {
        destroys.shift()(error);
      }
      (_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose]();
      ac.abort();
      if (final) {
        if (!error) {
          lastStreamCleanup.forEach((fn) => fn());
        }
        process2.nextTick(callback, error, value);
      }
    }
    let ret;
    for (let i = 0;i < streams.length; i++) {
      const stream = streams[i];
      const reading = i < streams.length - 1;
      const writing = i > 0;
      const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
      const isLastStream = i === streams.length - 1;
      if (isNodeStream(stream)) {
        let onError2 = function(err) {
          if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            finish(err);
          }
        };
        var onError = onError2;
        if (end) {
          const { destroy, cleanup } = destroyer(stream, reading, writing);
          destroys.push(destroy);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
        stream.on("error", onError2);
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(() => {
            stream.removeListener("error", onError2);
          });
        }
      }
      if (i === 0) {
        if (typeof stream === "function") {
          ret = stream({
            signal
          });
          if (!isIterable(ret)) {
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          }
        } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      } else if (typeof stream === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
        } else {
          ret = makeAsyncIterable(ret);
        }
        ret = stream(ret, {
          signal
        });
        if (reading) {
          if (!isIterable(ret, true)) {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
          }
        } else {
          var _ret2;
          if (!PassThrough) {
            PassThrough = require_passthrough();
          }
          const pt2 = new PassThrough({
            objectMode: true
          });
          const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
          if (typeof then === "function") {
            finishCount++;
            then.call(ret, (val) => {
              value = val;
              if (val != null) {
                pt2.write(val);
              }
              if (end) {
                pt2.end();
              }
              process2.nextTick(finish);
            }, (err) => {
              pt2.destroy(err);
              process2.nextTick(finish, err);
            });
          } else if (isIterable(ret, true)) {
            finishCount++;
            pumpToNode(ret, pt2, finish, {
              end
            });
          } else if (isReadableStream(ret) || isTransformStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, pt2, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          }
          ret = pt2;
          const { destroy, cleanup } = destroyer(ret, false, true);
          destroys.push(destroy);
          if (isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
      } else if (isNodeStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          const cleanup = pipe(ret, stream, finish, {
            end
          });
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          const toRead = ret.readable || ret;
          finishCount++;
          pumpToNode(toRead, stream, finish, {
            end
          });
        } else if (isIterable(ret)) {
          finishCount++;
          pumpToNode(ret, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else if (isWebStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount++;
          pumpToWeb(makeAsyncIterable(ret), stream, finish, {
            end
          });
        } else if (isReadableStream(ret) || isIterable(ret)) {
          finishCount++;
          pumpToWeb(ret, stream, finish, {
            end
          });
        } else if (isTransformStream(ret)) {
          finishCount++;
          pumpToWeb(ret.readable, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    }
    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {
      process2.nextTick(abort);
    }
    return ret;
  }
  function pipe(src, dst, finish, { end }) {
    let ended = false;
    dst.on("close", () => {
      if (!ended) {
        finish(new ERR_STREAM_PREMATURE_CLOSE);
      }
    });
    src.pipe(dst, {
      end: false
    });
    if (end) {
      let endFn2 = function() {
        ended = true;
        dst.end();
      };
      var endFn = endFn2;
      if (isReadableFinished(src)) {
        process2.nextTick(endFn2);
      } else {
        src.once("end", endFn2);
      }
    } else {
      finish();
    }
    eos(src, {
      readable: true,
      writable: false
    }, (err) => {
      const rState = src._readableState;
      if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
        src.once("end", finish).once("error", finish);
      } else {
        finish(err);
      }
    });
    return eos(dst, {
      readable: false,
      writable: true
    }, finish);
  }
  module.exports = {
    pipelineImpl,
    pipeline
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS((exports, module) => {
  var { pipeline } = require_pipeline();
  var Duplex = require_duplex();
  var { destroyer } = require_destroy();
  var {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = require_utils();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = require_errors();
  var eos = require_end_of_stream();
  module.exports = function compose(...streams) {
    if (streams.length === 0) {
      throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
      return Duplex.from(streams[0]);
    }
    const orgStreams = [...streams];
    if (typeof streams[0] === "function") {
      streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
      const idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0;n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
        continue;
      }
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      }
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d2;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d2.destroy(err);
      } else if (!readable && !writable) {
        d2.destroy();
      }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
    const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    d2 = new Duplex({
      writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
      writable,
      readable
    });
    if (writable) {
      if (isNodeStream(head)) {
        d2._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d2._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
      } else if (isWebStream(head)) {
        const writable2 = isTransformStream(head) ? head.writable : head;
        const writer = writable2.getWriter();
        d2._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
            callback();
          } catch (err) {
            callback(err);
          }
        };
        d2._final = async function(callback) {
          try {
            await writer.ready;
            writer.close().catch(() => {
            });
            onfinish = callback;
          } catch (err) {
            callback(err);
          }
        };
      }
      const toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      if (isNodeStream(tail)) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d2.push(null);
        });
        d2._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d2._read;
              return;
            }
            if (!d2.push(buf)) {
              return;
            }
          }
        };
      } else if (isWebStream(tail)) {
        const readable2 = isTransformStream(tail) ? tail.readable : tail;
        const reader = readable2.getReader();
        d2._read = async function() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (!d2.push(value)) {
                return;
              }
              if (done) {
                d2.push(null);
                return;
              }
            } catch {
              return;
            }
          }
        };
      }
    }
    d2._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        if (isNodeStream(tail)) {
          destroyer(tail, err);
        }
      }
    };
    return d2;
  };
});

// node_modules/n3/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS((exports, module) => {
  var AbortController = globalThis.AbortController || require_browser().AbortController;
  var {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = require_errors();
  var { validateAbortSignal, validateInteger, validateObject } = require_validators();
  var kWeakHandler = require_primordials().Symbol("kWeak");
  var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
  var { finished } = require_end_of_stream();
  var staticCompose = require_compose();
  var { addAbortSignalNoValidate } = require_add_abort_signal();
  var { isWritable, isNodeStream } = require_utils();
  var { deprecate } = require_util2();
  var {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = require_primordials();
  var kEmpty = Symbol2("kEmpty");
  var kEof = Symbol2("kEof");
  function compose(stream, options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    if (isNodeStream(stream) && !isWritable(stream)) {
      throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
    }
    const composedStream = staticCompose(this, stream);
    if (options !== null && options !== undefined && options.signal) {
      addAbortSignalNoValidate(options.signal, composedStream);
    }
    return composedStream;
  }
  function map(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let concurrency = 1;
    if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
      concurrency = MathFloor(options.concurrency);
    }
    let highWaterMark = concurrency - 1;
    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
      highWaterMark = MathFloor(options.highWaterMark);
    }
    validateInteger(concurrency, "options.concurrency", 1);
    validateInteger(highWaterMark, "options.highWaterMark", 0);
    highWaterMark += concurrency;
    return async function* map() {
      const signal = require_util2().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2));
      const stream = this;
      const queue = [];
      const signalOpt = {
        signal
      };
      let next;
      let resume;
      let done = false;
      let cnt = 0;
      function onCatch() {
        done = true;
        afterItemProcessed();
      }
      function afterItemProcessed() {
        cnt -= 1;
        maybeResume();
      }
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
          resume();
          resume = null;
        }
      }
      async function pump() {
        try {
          for await (let val of stream) {
            if (done) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            try {
              val = fn(val, signalOpt);
              if (val === kEmpty) {
                continue;
              }
              val = PromiseResolve(val);
            } catch (err) {
              val = PromiseReject(err);
            }
            cnt += 1;
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
            if (next) {
              next();
              next = null;
            }
            if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
              await new Promise2((resolve) => {
                resume = resolve;
              });
            }
          }
          queue.push(kEof);
        } catch (err) {
          const val = PromiseReject(err);
          PromisePrototypeThen(val, afterItemProcessed, onCatch);
          queue.push(val);
        } finally {
          done = true;
          if (next) {
            next();
            next = null;
          }
        }
      }
      pump();
      try {
        while (true) {
          while (queue.length > 0) {
            const val = await queue[0];
            if (val === kEof) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            if (val !== kEmpty) {
              yield val;
            }
            queue.shift();
            maybeResume();
          }
          await new Promise2((resolve) => {
            next = resolve;
          });
        }
      } finally {
        done = true;
        if (resume) {
          resume();
          resume = null;
        }
      }
    }.call(this);
  }
  function asIndexedPairs(options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    return async function* asIndexedPairs() {
      let index = 0;
      for await (const val of this) {
        var _options$signal;
        if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {
          throw new AbortError({
            cause: options.signal.reason
          });
        }
        yield [index++, val];
      }
    }.call(this);
  }
  async function some(fn, options = undefined) {
    for await (const unused of filter.call(this, fn, options)) {
      return true;
    }
    return false;
  }
  async function every(fn, options = undefined) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    return !await some.call(this, async (...args) => {
      return !await fn(...args);
    }, options);
  }
  async function find(fn, options) {
    for await (const result of filter.call(this, fn, options)) {
      return result;
    }
    return;
  }
  async function forEach(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function forEachFn(value, options2) {
      await fn(value, options2);
      return kEmpty;
    }
    for await (const unused of map.call(this, forEachFn, options))
      ;
  }
  function filter(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    }
    async function filterFn(value, options2) {
      if (await fn(value, options2)) {
        return value;
      }
      return kEmpty;
    }
    return map.call(this, filterFn, options);
  }

  class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function reduce(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function") {
      throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
      const err = new AbortError(undefined, {
        cause: options.signal.reason
      });
      this.once("error", () => {
      });
      await finished(this.destroy(err));
      throw err;
    }
    const ac = new AbortController;
    const signal = ac.signal;
    if (options !== null && options !== undefined && options.signal) {
      const opts = {
        once: true,
        [kWeakHandler]: this,
        [kResistStopPropagation]: true
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = false;
    try {
      for await (const value of this) {
        var _options$signal3;
        gotAnyItemFromStream = true;
        if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {
          throw new AbortError;
        }
        if (!hasInitialValue) {
          initialValue = value;
          hasInitialValue = true;
        } else {
          initialValue = await reducer(initialValue, value, {
            signal
          });
        }
      }
      if (!gotAnyItemFromStream && !hasInitialValue) {
        throw new ReduceAwareErrMissingArgs;
      }
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  async function toArray(options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    const result = [];
    for await (const val of this) {
      var _options$signal4;
      if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {
        throw new AbortError(undefined, {
          cause: options.signal.reason
        });
      }
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  function flatMap(fn, options) {
    const values = map.call(this, fn, options);
    return async function* flatMap() {
      for await (const val of values) {
        yield* val;
      }
    }.call(this);
  }
  function toIntegerOrInfinity(number) {
    number = Number2(number);
    if (NumberIsNaN(number)) {
      return 0;
    }
    if (number < 0) {
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
    }
    return number;
  }
  function drop(number, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* drop() {
      var _options$signal5;
      if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal6;
        if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {
          throw new AbortError;
        }
        if (number-- <= 0) {
          yield val;
        }
      }
    }.call(this);
  }
  function take(number, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number = toIntegerOrInfinity(number);
    return async function* take() {
      var _options$signal7;
      if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal8;
        if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {
          throw new AbortError;
        }
        if (number-- > 0) {
          yield val;
        }
        if (number <= 0) {
          return;
        }
      }
    }.call(this);
  }
  exports.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter,
    flatMap,
    map,
    take,
    compose
  };
  exports.promiseReturningOperators = {
    every,
    forEach,
    reduce,
    toArray,
    some,
    find
  };
});

// node_modules/n3/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS((exports, module) => {
  var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
  var { isIterable, isNodeStream, isWebStream } = require_utils();
  var { pipelineImpl: pl } = require_pipeline();
  var { finished } = require_end_of_stream();
  require_stream();
  function pipeline(...streams) {
    return new Promise2((resolve, reject) => {
      let signal;
      let end;
      const lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
        const options = ArrayPrototypePop(streams);
        signal = options.signal;
        end = options.end;
      }
      pl(streams, (err, value) => {
        if (err) {
          reject(err);
        } else {
          resolve(value);
        }
      }, {
        signal,
        end
      });
    });
  }
  module.exports = {
    finished,
    pipeline
  };
});

// node_modules/n3/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(exports_buffer));
  var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
  var {
    promisify: { custom: customPromisify }
  } = require_util2();
  var { streamReturningOperators, promiseReturningOperators } = require_operators();
  var {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = require_errors();
  var compose = require_compose();
  var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
  var { pipeline } = require_pipeline();
  var { destroyer } = require_destroy();
  var eos = require_end_of_stream();
  var promises = require_promises();
  var utils = require_utils();
  var Stream = module.exports = require_legacy().Stream;
  Stream.isDestroyed = utils.isDestroyed;
  Stream.isDisturbed = utils.isDisturbed;
  Stream.isErrored = utils.isErrored;
  Stream.isReadable = utils.isReadable;
  Stream.isWritable = utils.isWritable;
  Stream.Readable = require_readable();
  for (const key of ObjectKeys(streamReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return Stream.Readable.from(ReflectApply(op, this, args));
    };
    fn = fn2;
    const op = streamReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  var fn;
  for (const key of ObjectKeys(promiseReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return ReflectApply(op, this, args);
    };
    fn = fn2;
    const op = promiseReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  var fn;
  Stream.Writable = require_writable();
  Stream.Duplex = require_duplex();
  Stream.Transform = require_transform();
  Stream.PassThrough = require_passthrough();
  Stream.pipeline = pipeline;
  var { addAbortSignal } = require_add_abort_signal();
  Stream.addAbortSignal = addAbortSignal;
  Stream.finished = eos;
  Stream.destroy = destroyer;
  Stream.compose = compose;
  Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty(Stream, "promises", {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get() {
      return promises;
    }
  });
  ObjectDefineProperty(pipeline, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.pipeline;
    }
  });
  ObjectDefineProperty(eos, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.finished;
    }
  });
  Stream.Stream = Stream;
  Stream._isUint8Array = function isUint8Array(value) {
    return value instanceof Uint8Array;
  };
  Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  };
});

// node_modules/n3/node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS((exports, module) => {
  var CustomStream = require_stream();
  var promises = require_promises();
  var originalDestroy = CustomStream.Readable.destroy;
  module.exports = CustomStream.Readable;
  module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
  module.exports._isUint8Array = CustomStream._isUint8Array;
  module.exports.isDisturbed = CustomStream.isDisturbed;
  module.exports.isErrored = CustomStream.isErrored;
  module.exports.isReadable = CustomStream.isReadable;
  module.exports.Readable = CustomStream.Readable;
  module.exports.Writable = CustomStream.Writable;
  module.exports.Duplex = CustomStream.Duplex;
  module.exports.Transform = CustomStream.Transform;
  module.exports.PassThrough = CustomStream.PassThrough;
  module.exports.addAbortSignal = CustomStream.addAbortSignal;
  module.exports.finished = CustomStream.finished;
  module.exports.destroy = CustomStream.destroy;
  module.exports.destroy = originalDestroy;
  module.exports.pipeline = CustomStream.pipeline;
  module.exports.compose = CustomStream.compose;
  Object.defineProperty(CustomStream, "promises", {
    configurable: true,
    enumerable: true,
    get() {
      return promises;
    }
  });
  module.exports.Stream = CustomStream.Stream;
  module.exports.default = module.exports;
});

// node_modules/@digitalbazaar/security-context/js/security-v1.js
var require_security_v1 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    "@context": {
      id: "@id",
      type: "@type",
      dc: "http://purl.org/dc/terms/",
      sec: "https://w3id.org/security#",
      xsd: "http://www.w3.org/2001/XMLSchema#",
      EcdsaKoblitzSignature2016: "sec:EcdsaKoblitzSignature2016",
      Ed25519Signature2018: "sec:Ed25519Signature2018",
      EncryptedMessage: "sec:EncryptedMessage",
      GraphSignature2012: "sec:GraphSignature2012",
      LinkedDataSignature2015: "sec:LinkedDataSignature2015",
      LinkedDataSignature2016: "sec:LinkedDataSignature2016",
      CryptographicKey: "sec:Key",
      authenticationTag: "sec:authenticationTag",
      canonicalizationAlgorithm: "sec:canonicalizationAlgorithm",
      cipherAlgorithm: "sec:cipherAlgorithm",
      cipherData: "sec:cipherData",
      cipherKey: "sec:cipherKey",
      created: { "@id": "dc:created", "@type": "xsd:dateTime" },
      creator: { "@id": "dc:creator", "@type": "@id" },
      digestAlgorithm: "sec:digestAlgorithm",
      digestValue: "sec:digestValue",
      domain: "sec:domain",
      encryptionKey: "sec:encryptionKey",
      expiration: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
      expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
      initializationVector: "sec:initializationVector",
      iterationCount: "sec:iterationCount",
      nonce: "sec:nonce",
      normalizationAlgorithm: "sec:normalizationAlgorithm",
      owner: { "@id": "sec:owner", "@type": "@id" },
      password: "sec:password",
      privateKey: { "@id": "sec:privateKey", "@type": "@id" },
      privateKeyPem: "sec:privateKeyPem",
      publicKey: { "@id": "sec:publicKey", "@type": "@id" },
      publicKeyBase58: "sec:publicKeyBase58",
      publicKeyPem: "sec:publicKeyPem",
      publicKeyWif: "sec:publicKeyWif",
      publicKeyService: { "@id": "sec:publicKeyService", "@type": "@id" },
      revoked: { "@id": "sec:revoked", "@type": "xsd:dateTime" },
      salt: "sec:salt",
      signature: "sec:signature",
      signatureAlgorithm: "sec:signingAlgorithm",
      signatureValue: "sec:signatureValue"
    }
  };
});

// node_modules/@digitalbazaar/security-context/js/security-v2.js
var require_security_v2 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    "@context": [{
      "@version": 1.1
    }, "https://w3id.org/security/v1", {
      AesKeyWrappingKey2019: "sec:AesKeyWrappingKey2019",
      DeleteKeyOperation: "sec:DeleteKeyOperation",
      DeriveSecretOperation: "sec:DeriveSecretOperation",
      EcdsaSecp256k1Signature2019: "sec:EcdsaSecp256k1Signature2019",
      EcdsaSecp256r1Signature2019: "sec:EcdsaSecp256r1Signature2019",
      EcdsaSecp256k1VerificationKey2019: "sec:EcdsaSecp256k1VerificationKey2019",
      EcdsaSecp256r1VerificationKey2019: "sec:EcdsaSecp256r1VerificationKey2019",
      Ed25519Signature2018: "sec:Ed25519Signature2018",
      Ed25519VerificationKey2018: "sec:Ed25519VerificationKey2018",
      EquihashProof2018: "sec:EquihashProof2018",
      ExportKeyOperation: "sec:ExportKeyOperation",
      GenerateKeyOperation: "sec:GenerateKeyOperation",
      KmsOperation: "sec:KmsOperation",
      RevokeKeyOperation: "sec:RevokeKeyOperation",
      RsaSignature2018: "sec:RsaSignature2018",
      RsaVerificationKey2018: "sec:RsaVerificationKey2018",
      Sha256HmacKey2019: "sec:Sha256HmacKey2019",
      SignOperation: "sec:SignOperation",
      UnwrapKeyOperation: "sec:UnwrapKeyOperation",
      VerifyOperation: "sec:VerifyOperation",
      WrapKeyOperation: "sec:WrapKeyOperation",
      X25519KeyAgreementKey2019: "sec:X25519KeyAgreementKey2019",
      allowedAction: "sec:allowedAction",
      assertionMethod: {
        "@id": "sec:assertionMethod",
        "@type": "@id",
        "@container": "@set"
      },
      authentication: {
        "@id": "sec:authenticationMethod",
        "@type": "@id",
        "@container": "@set"
      },
      capability: { "@id": "sec:capability", "@type": "@id" },
      capabilityAction: "sec:capabilityAction",
      capabilityChain: {
        "@id": "sec:capabilityChain",
        "@type": "@id",
        "@container": "@list"
      },
      capabilityDelegation: {
        "@id": "sec:capabilityDelegationMethod",
        "@type": "@id",
        "@container": "@set"
      },
      capabilityInvocation: {
        "@id": "sec:capabilityInvocationMethod",
        "@type": "@id",
        "@container": "@set"
      },
      caveat: { "@id": "sec:caveat", "@type": "@id", "@container": "@set" },
      challenge: "sec:challenge",
      ciphertext: "sec:ciphertext",
      controller: { "@id": "sec:controller", "@type": "@id" },
      delegator: { "@id": "sec:delegator", "@type": "@id" },
      equihashParameterK: {
        "@id": "sec:equihashParameterK",
        "@type": "xsd:integer"
      },
      equihashParameterN: {
        "@id": "sec:equihashParameterN",
        "@type": "xsd:integer"
      },
      invocationTarget: { "@id": "sec:invocationTarget", "@type": "@id" },
      invoker: { "@id": "sec:invoker", "@type": "@id" },
      jws: "sec:jws",
      keyAgreement: {
        "@id": "sec:keyAgreementMethod",
        "@type": "@id",
        "@container": "@set"
      },
      kmsModule: { "@id": "sec:kmsModule" },
      parentCapability: { "@id": "sec:parentCapability", "@type": "@id" },
      plaintext: "sec:plaintext",
      proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
      proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab" },
      proofValue: "sec:proofValue",
      referenceId: "sec:referenceId",
      unwrappedKey: "sec:unwrappedKey",
      verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" },
      verifyData: "sec:verifyData",
      wrappedKey: "sec:wrappedKey"
    }]
  };
});

// node_modules/@digitalbazaar/security-context/js/constants.js
var require_constants2 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    SECURITY_CONTEXT_V1_URL: "https://w3id.org/security/v1",
    SECURITY_CONTEXT_V2_URL: "https://w3id.org/security/v2",
    CONTEXT_URL: "https://w3id.org/security/v2"
  };
});

// node_modules/@digitalbazaar/security-context/js/index.js
var require_js = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.
   */
  var secv1 = require_security_v1();
  var secv2 = require_security_v2();
  var constants = require_constants2();
  var {
    CONTEXT_URL,
    SECURITY_CONTEXT_V1_URL,
    SECURITY_CONTEXT_V2_URL
  } = constants;
  var contexts = new Map;
  contexts.set(SECURITY_CONTEXT_V1_URL, secv1);
  contexts.set(SECURITY_CONTEXT_V2_URL, secv2);
  module.exports = {
    constants,
    contexts,
    SECURITY_CONTEXT_V1_URL,
    SECURITY_CONTEXT_V2_URL,
    CONTEXT_URL,
    CONTEXT: secv2
  };
});

// node_modules/jsonld-signatures/lib/constants.js
var require_constants3 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.
   */
  var {
    constants: securityConstants
  } = require_js();
  module.exports = {
    SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
    SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
    SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
    SECURITY_PROOF_URL: "https://w3id.org/security#proof",
    SECURITY_SIGNATURE_URL: "https://w3id.org/security#signature"
  };
});

// node_modules/jsonld-signatures/lib/contexts.js
var require_contexts = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.
   */
  var constants = require_constants3();
  var { contexts: securityContexts } = require_js();
  module.exports = new Map([
    [
      constants.SECURITY_CONTEXT_V1_URL,
      securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)
    ],
    [
      constants.SECURITY_CONTEXT_V2_URL,
      securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)
    ]
  ]);
});

// node_modules/jsonld-signatures/lib/documentLoader.js
var require_documentLoader = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.
   */
  var contexts = require_contexts();
  var api = {};
  module.exports = api;
  api.extendContextLoader = (documentLoader) => {
    return async (url) => {
      const context2 = contexts.get(url);
      if (context2 !== undefined) {
        return {
          contextUrl: null,
          documentUrl: url,
          document: context2,
          tag: "static"
        };
      }
      return documentLoader(url);
    };
  };
  api.strictDocumentLoader = api.extendContextLoader((url) => {
    throw new Error(`${url} not found.`);
  });
});

// node_modules/serialize-error/index.js
var require_serialize_error = __commonJS((exports, module) => {
  class NonError extends Error {
    constructor(message2) {
      super(NonError._prepareSuperMessage(message2));
      Object.defineProperty(this, "name", {
        value: "NonError",
        configurable: true,
        writable: true
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NonError);
      }
    }
    static _prepareSuperMessage(message2) {
      try {
        return JSON.stringify(message2);
      } catch {
        return String(message2);
      }
    }
  }
  var commonProperties = [
    { property: "name", enumerable: false },
    { property: "message", enumerable: false },
    { property: "stack", enumerable: false },
    { property: "code", enumerable: true }
  ];
  var isCalled = Symbol(".toJSON called");
  var toJSON = (from) => {
    from[isCalled] = true;
    const json = from.toJSON();
    delete from[isCalled];
    return json;
  };
  var destroyCircular = ({
    from,
    seen,
    to_,
    forceEnumerable,
    maxDepth,
    depth
  }) => {
    const to = to_ || (Array.isArray(from) ? [] : {});
    seen.push(from);
    if (depth >= maxDepth) {
      return to;
    }
    if (typeof from.toJSON === "function" && from[isCalled] !== true) {
      return toJSON(from);
    }
    for (const [key, value] of Object.entries(from)) {
      if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
        to[key] = "[object Buffer]";
        continue;
      }
      if (typeof value === "function") {
        continue;
      }
      if (!value || typeof value !== "object") {
        to[key] = value;
        continue;
      }
      if (!seen.includes(from[key])) {
        depth++;
        to[key] = destroyCircular({
          from: from[key],
          seen: seen.slice(),
          forceEnumerable,
          maxDepth,
          depth
        });
        continue;
      }
      to[key] = "[Circular]";
    }
    for (const { property, enumerable } of commonProperties) {
      if (typeof from[property] === "string") {
        Object.defineProperty(to, property, {
          value: from[property],
          enumerable: forceEnumerable ? true : enumerable,
          configurable: true,
          writable: true
        });
      }
    }
    return to;
  };
  var serializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (typeof value === "object" && value !== null) {
      return destroyCircular({
        from: value,
        seen: [],
        forceEnumerable: true,
        maxDepth,
        depth: 0
      });
    }
    if (typeof value === "function") {
      return `[Function: ${value.name || "anonymous"}]`;
    }
    return value;
  };
  var deserializeError = (value, options = {}) => {
    const { maxDepth = Number.POSITIVE_INFINITY } = options;
    if (value instanceof Error) {
      return value;
    }
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const newError = new Error;
      destroyCircular({
        from: value,
        seen: [],
        to_: newError,
        maxDepth,
        depth: 0
      });
      return newError;
    }
    return new NonError(value);
  };
  module.exports = {
    serializeError,
    deserializeError
  };
});

// node_modules/jsonld-signatures/lib/ProofSet.js
var require_ProofSet = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var constants = require_constants3();
  var jsonld2 = require_jsonld();
  var { extendContextLoader, strictDocumentLoader } = require_documentLoader();
  var { serializeError } = require_serialize_error();
  module.exports = class ProofSet {
    async add(document2, { suite, purpose, documentLoader } = {}) {
      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }
      if (!purpose) {
        throw new TypeError('"options.purpose" is required.');
      }
      if (documentLoader) {
        documentLoader = extendContextLoader(documentLoader);
      } else {
        documentLoader = strictDocumentLoader;
      }
      const input = { ...document2 };
      delete input.proof;
      const proofSet = _getProofs({ document: document2 });
      const proof = await suite.createProof({
        document: input,
        purpose,
        proofSet,
        documentLoader
      });
      jsonld2.addValue(document2, "proof", proof);
      return document2;
    }
    async derive(document2, { suite, purpose, documentLoader } = {}) {
      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }
      if (!purpose) {
        throw new TypeError('"options.purpose" is required.');
      }
      if (documentLoader) {
        documentLoader = extendContextLoader(documentLoader);
      } else {
        documentLoader = strictDocumentLoader;
      }
      const input = { ...document2 };
      delete input.proof;
      const proofSet = _getProofs({ document: document2 });
      const newDocument = await suite.derive({
        document: input,
        purpose,
        proofSet,
        documentLoader
      });
      return newDocument;
    }
    async verify(document2, { suite, purpose, documentLoader } = {}) {
      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }
      if (!purpose) {
        throw new TypeError('"options.purpose" is required.');
      }
      const suites = Array.isArray(suite) ? suite : [suite];
      if (suites.length === 0) {
        throw new TypeError("At least one suite is required.");
      }
      if (documentLoader) {
        documentLoader = extendContextLoader(documentLoader);
      } else {
        documentLoader = strictDocumentLoader;
      }
      try {
        document2 = { ...document2 };
        const proofSet = _getProofs({ document: document2 });
        if (proofSet.length === 0) {
          throw new Error("No matching proofs found in the given document.");
        }
        delete document2.proof;
        const results = await _verify({ document: document2, suites, proofSet, purpose, documentLoader });
        if (results.length === 0) {
          const error = new Error("Did not verify any proofs; insufficient proofs matched the " + "acceptable suite(s) and required purpose(s).");
          error.name = "NotFoundError";
          throw error;
        }
        const verified = results.some((r) => r.verified);
        if (!verified) {
          const errors = [].concat(...results.filter((r) => r.error).map((r) => r.error));
          const result = { verified, results };
          if (errors.length > 0) {
            result.error = errors;
          }
          return result;
        }
        return { verified, results };
      } catch (error) {
        _makeSerializable(error);
        return { verified: false, error };
      }
    }
  };
  function _getProofs({ document: document2 }) {
    let proofSet;
    proofSet = jsonld2.getValues(document2, "proof");
    const context2 = document2["@context"] || constants.SECURITY_CONTEXT_URL;
    proofSet = proofSet.map((proof) => ({
      "@context": context2,
      ...proof
    }));
    return proofSet;
  }
  async function _verify({
    document: document2,
    suites,
    proofSet,
    purpose,
    documentLoader
  }) {
    const purposes = Array.isArray(purpose) ? purpose : [purpose];
    const purposeToProofs = new Map;
    const proofToSuite = new Map;
    const suiteMatchQueue = new Map;
    await Promise.all(purposes.map((purpose2) => _matchProofSet({
      purposeToProofs,
      proofToSuite,
      purpose: purpose2,
      proofSet,
      suites,
      suiteMatchQueue,
      document: document2,
      documentLoader
    })));
    if (purposeToProofs.size < purposes.length) {
      return [];
    }
    const verifyResults = new Map;
    await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {
      let result;
      try {
        let vm;
        const purpose2 = {
          async validate(proof2, { verificationMethod: verificationMethod2 }) {
            vm = verificationMethod2;
            return { valid: true };
          }
        };
        const { verified, verificationMethod, error } = await suite.verifyProof({ proof, document: document2, purpose: purpose2, proofSet, documentLoader });
        if (!vm) {
          vm = verificationMethod;
        }
        result = { proof, verified, verificationMethod: vm, error };
      } catch (error) {
        result = { proof, verified: false, error };
      }
      if (result.error) {
        _makeSerializable(result.error);
      }
      verifyResults.set(proof, result);
    }));
    await Promise.all([...purposeToProofs.entries()].map(async ([purpose2, proofs]) => {
      for (const proof of proofs) {
        const result = verifyResults.get(proof);
        if (!result.verified) {
          continue;
        }
        const { verificationMethod } = result;
        const suite = proofToSuite.get(proof);
        let purposeResult;
        try {
          purposeResult = await purpose2.validate(proof, {
            document: document2,
            suite,
            verificationMethod,
            documentLoader
          });
        } catch (error) {
          purposeResult = { valid: false, error };
        }
        if (result.purposeResult) {
          if (Array.isArray(result.purposeResult)) {
            result.purposeResult.push(purposeResult);
          } else {
            result.purposeResult = [result.purposeResult, purposeResult];
          }
        } else {
          result.purposeResult = purposeResult;
        }
        if (!purposeResult.valid) {
          _makeSerializable(purposeResult.error);
          if (!result.error) {
            result.verified = false;
            result.error = purposeResult.error;
          }
        }
      }
    }));
    return [...verifyResults.values()];
  }
  function _makeSerializable(error) {
    Object.defineProperty(error, "toJSON", {
      value: function() {
        return serializeError(this);
      },
      configurable: true,
      writable: true
    });
  }
  async function _matchProofSet({
    purposeToProofs,
    proofToSuite,
    purpose,
    proofSet,
    suites,
    suiteMatchQueue,
    document: document2,
    documentLoader
  }) {
    for (const proof of proofSet) {
      if (!await purpose.match(proof, { document: document2, documentLoader })) {
        continue;
      }
      let matched = false;
      for (const s of suites) {
        let matchingProofs = suiteMatchQueue.get(s);
        if (!matchingProofs) {
          suiteMatchQueue.set(s, matchingProofs = new Map);
        }
        let promise = matchingProofs.get(proof);
        if (!promise) {
          promise = s.matchProof({ proof, document: document2, documentLoader });
          matchingProofs.set(proof, promise);
        }
        if (await promise) {
          matched = true;
          proofToSuite.set(proof, s);
          break;
        }
      }
      if (matched) {
        const matches = purposeToProofs.get(purpose);
        if (matches) {
          matches.push(proof);
        } else {
          purposeToProofs.set(purpose, [proof]);
        }
      }
    }
  }
});

// node_modules/jsonld-signatures/lib/VerificationError.js
var require_VerificationError = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
   */

  class VerificationError extends Error {
    constructor(errors) {
      super("Verification error(s).");
      this.name = "VerificationError";
      this.errors = [].concat(errors);
    }
  }
  module.exports = VerificationError;
});

// node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js
var require_LinkedDataProof = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018-2023 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = class LinkedDataProof {
    constructor({ type } = {}) {
      if (typeof type !== "string") {
        throw new TypeError('A LinkedDataProof must have a "type".');
      }
      this.type = type;
    }
    async createProof({}) {
      throw new Error('"createProof" must be implemented in a derived class.');
    }
    async derive({}) {
      throw new Error('"deriveProof" must be implemented in a derived class.');
    }
    async verifyProof({}) {
      throw new Error('"verifyProof" must be implemented in a derived class.');
    }
    async matchProof({
      proof
    }) {
      return proof.type === this.type;
    }
  };
});

// node_modules/jsonld-signatures/lib/util.js
var require_util3 = __commonJS((exports, module) => {
  var api = {};
  module.exports = api;
  api.w3cDate = (date) => {
    if (date === undefined || date === null) {
      date = new Date;
    } else if (typeof date === "number" || typeof date === "string") {
      date = new Date(date);
    }
    const str = date.toISOString();
    return str.substr(0, str.length - 5) + "Z";
  };
  api.concat = (b1, b22) => {
    const rval = new Uint8Array(b1.length + b22.length);
    rval.set(b1, 0);
    rval.set(b22, b1.length);
    return rval;
  };
});

// node_modules/jsonld-signatures/lib/sha256digest-browser.js
var require_sha256digest_browser = __commonJS((exports, module) => {
  var crypto2 = self && (self.crypto || self.msCrypto);
  module.exports = {
    async sha256digest({ string }) {
      const bytes = new TextEncoder().encode(string);
      return new Uint8Array(await crypto2.subtle.digest("SHA-256", bytes));
    }
  };
});

// node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js
var require_LinkedDataSignature = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.
   */
  var constants = require_constants3();
  var jsonld2 = require_jsonld();
  var util = require_util3();
  var { sha256digest } = require_sha256digest_browser();
  var LinkedDataProof = require_LinkedDataProof();
  module.exports = class LinkedDataSignature extends LinkedDataProof {
    constructor({
      type,
      proof,
      LDKeyClass,
      date,
      key,
      signer,
      verifier,
      useNativeCanonize,
      canonizeOptions,
      contextUrl
    } = {}) {
      super({ type });
      this.LDKeyClass = LDKeyClass;
      this.contextUrl = contextUrl;
      this.proof = proof;
      const vm = _processSignatureParams({ key, signer, verifier });
      this.verificationMethod = vm.verificationMethod;
      this.key = vm.key;
      this.signer = vm.signer;
      this.verifier = vm.verifier;
      this.canonizeOptions = canonizeOptions;
      if (date) {
        this.date = new Date(date);
        if (isNaN(this.date)) {
          throw TypeError(`"date" "${date}" is not a valid date.`);
        }
      }
      this.useNativeCanonize = useNativeCanonize;
      this._hashCache = null;
    }
    async createProof({
      document: document2,
      purpose,
      proofSet,
      documentLoader,
      expansionMap
    }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      let proof;
      if (this.proof) {
        proof = { ...this.proof };
      } else {
        proof = {};
      }
      proof.type = this.type;
      let date = this.date;
      if (proof.created === undefined && date === undefined) {
        date = new Date;
      }
      if (date && typeof date !== "string") {
        date = util.w3cDate(date);
      }
      if (date) {
        proof.created = date;
      }
      proof.verificationMethod = this.verificationMethod;
      proof = await this.updateProof({ document: document2, proof, proofSet, purpose, documentLoader });
      proof = await purpose.update(proof, { document: document2, suite: this, documentLoader });
      const verifyData = await this.createVerifyData({ document: document2, proof, proofSet, documentLoader });
      proof = await this.sign({ verifyData, document: document2, proof, documentLoader });
      return proof;
    }
    async updateProof({ proof, expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      return proof;
    }
    async verifyProof({ proof, document: document2, proofSet, documentLoader, expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      try {
        const verifyData = await this.createVerifyData({ document: document2, proof, proofSet, documentLoader, expansionMap });
        const verificationMethod = await this.getVerificationMethod({ proof, document: document2, documentLoader, expansionMap });
        const verified = await this.verifySignature({
          verifyData,
          verificationMethod,
          document: document2,
          proof,
          documentLoader,
          expansionMap
        });
        if (!verified) {
          throw new Error("Invalid signature.");
        }
        return { verified: true, verificationMethod };
      } catch (error) {
        return { verified: false, error };
      }
    }
    async canonize(input, { documentLoader, expansionMap, skipExpansion }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      return jsonld2.canonize(input, {
        algorithm: "URDNA2015",
        base: null,
        format: "application/n-quads",
        documentLoader,
        safe: true,
        skipExpansion,
        useNative: this.useNativeCanonize,
        ...this.canonizeOptions
      });
    }
    async canonizeProof(proof, { document: document2, documentLoader, expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      proof = {
        "@context": document2["@context"] || constants.SECURITY_CONTEXT_URL,
        ...proof
      };
      delete proof.jws;
      delete proof.signatureValue;
      delete proof.proofValue;
      return this.canonize(proof, {
        documentLoader,
        expansionMap,
        skipExpansion: false,
        ...this.canonizeOptions
      });
    }
    async createVerifyData({ document: document2, proof, documentLoader, expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      let cachedDocHash;
      const { _hashCache } = this;
      if (_hashCache && _hashCache.document === document2) {
        cachedDocHash = _hashCache.hash;
      } else {
        this._hashCache = {
          document: document2,
          hash: cachedDocHash = this.canonize(document2, { documentLoader, expansionMap }).then((c14nDocument) => sha256digest({ string: c14nDocument }))
        };
      }
      const [proofHash, docHash] = await Promise.all([
        this.canonizeProof(proof, { document: document2, documentLoader, expansionMap }).then((c14nProofOptions) => sha256digest({ string: c14nProofOptions })),
        cachedDocHash
      ]);
      return util.concat(proofHash, docHash);
    }
    async derive() {
      throw new Error("Must be implemented by a derived class.");
    }
    async getVerificationMethod({ proof, documentLoader }) {
      let { verificationMethod } = proof;
      if (typeof verificationMethod === "object") {
        verificationMethod = verificationMethod.id;
      }
      if (!verificationMethod) {
        throw new Error('No "verificationMethod" found in proof.');
      }
      const framed = await jsonld2.frame(verificationMethod, {
        "@context": constants.SECURITY_CONTEXT_URL,
        "@embed": "@always",
        id: verificationMethod
      }, { documentLoader, compactToRelative: false, safe: true });
      if (!framed) {
        throw new Error(`Verification method ${verificationMethod} not found.`);
      }
      if (framed.revoked !== undefined) {
        throw new Error("The verification method has been revoked.");
      }
      return framed;
    }
    async sign() {
      throw new Error("Must be implemented by a derived class.");
    }
    async verifySignature() {
      throw new Error("Must be implemented by a derived class.");
    }
    ensureSuiteContext({ document: document2, addSuiteContext }) {
      const { contextUrl } = this;
      if (_includesContext({ document: document2, contextUrl })) {
        return;
      }
      if (!addSuiteContext) {
        throw new TypeError(`The document to be signed must contain this suite's @context, ` + `"${contextUrl}".`);
      }
      const existingContext = document2["@context"] || [];
      document2["@context"] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];
    }
  };
  function _includesContext({ document: document2, contextUrl }) {
    const context2 = document2["@context"];
    return context2 === contextUrl || Array.isArray(context2) && context2.includes(contextUrl);
  }
  function _processSignatureParams({ key, signer, verifier }) {
    const vm = {};
    if (key) {
      vm.key = key;
      vm.verificationMethod = key.id;
      if (typeof key.signer === "function") {
        vm.signer = key.signer();
      }
      if (typeof key.verifier === "function") {
        vm.verifier = key.verifier();
      }
      if (!(vm.signer || vm.verifier)) {
        throw new TypeError('The "key" parameter must contain a "signer" or "verifier" method.');
      }
    } else {
      vm.verificationMethod = signer && signer.id || verifier && verifier.id;
      vm.signer = signer;
      vm.verifier = verifier;
    }
    if (vm.signer) {
      if (typeof vm.signer.sign !== "function") {
        throw new TypeError("A signer API has not been specified.");
      }
    }
    if (vm.verifier) {
      if (typeof vm.verifier.verify !== "function") {
        throw new TypeError("A verifier API has not been specified.");
      }
    }
    return vm;
  }
});

// node_modules/jsonld-signatures/lib/suites.js
var require_suites = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   */
  var api = {};
  module.exports = api;
  api.suites = {
    LinkedDataProof: require_LinkedDataProof(),
    LinkedDataSignature: require_LinkedDataSignature()
  };
});

// node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js
var require_ProofPurpose = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = class ProofPurpose {
    constructor({ term, date, maxTimestampDelta = Infinity } = {}) {
      if (term === undefined) {
        throw new Error('"term" is required.');
      }
      if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== "number") {
        throw new TypeError('"maxTimestampDelta" must be a number.');
      }
      this.term = term;
      if (date !== undefined) {
        this.date = new Date(date);
        if (isNaN(this.date)) {
          throw TypeError(`"date" "${date}" is not a valid date.`);
        }
      }
      this.maxTimestampDelta = maxTimestampDelta;
    }
    async validate(proof, {
      expansionMap
    }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      try {
        if (this.maxTimestampDelta !== Infinity) {
          const expected = (this.date || new Date).getTime();
          const delta = this.maxTimestampDelta * 1000;
          const created = new Date(proof.created).getTime();
          if (!(created >= expected - delta && created <= expected + delta)) {
            throw new Error("The proof's created timestamp is out of range.");
          }
        }
        return { valid: true };
      } catch (error) {
        return { valid: false, error };
      }
    }
    async update(proof, { expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      proof.proofPurpose = this.term;
      return proof;
    }
    async match(proof, { expansionMap }) {
      if (expansionMap) {
        throw new Error('"expansionMap" not supported.');
      }
      return proof.proofPurpose === this.term;
    }
  };
});

// node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js
var require_ControllerProofPurpose = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
   */
  var constants = require_constants3();
  var jsonld2 = require_jsonld();
  var ProofPurpose = require_ProofPurpose();
  var DID_CONTEXT_V1 = "https://www.w3.org/ns/did/v1";
  var DID_VR_TERMS = [
    "assertionMethod",
    "authentication",
    "capabilityInvocation",
    "capabilityDelegation",
    "keyAgreement",
    "verificationMethod"
  ];
  module.exports = class ControllerProofPurpose extends ProofPurpose {
    constructor({ term, controller, date, maxTimestampDelta = Infinity } = {}) {
      super({ term, date, maxTimestampDelta });
      if (controller !== undefined) {
        if (typeof controller !== "object") {
          throw new TypeError('"controller" must be an object.');
        }
        this.controller = controller;
      }
      this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);
    }
    async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
      try {
        const result = await super.validate(proof, { verificationMethod, documentLoader, expansionMap });
        if (!result.valid) {
          throw result.error;
        }
        const { id: verificationId } = verificationMethod;
        const { term, _termDefinedByDIDContext } = this;
        if (this.controller) {
          result.controller = this.controller;
        } else {
          const { controller } = verificationMethod;
          let controllerId;
          if (controller) {
            if (typeof controller === "object") {
              controllerId = controller.id;
            } else if (typeof controller !== "string") {
              throw new TypeError('"controller" must be a string representing a URL.');
            } else {
              controllerId = controller;
            }
          }
          let { document: document2 } = await documentLoader(controllerId);
          const mustFrame = !(_termDefinedByDIDContext && document2["@context"] === DID_CONTEXT_V1 || Array.isArray(document2["@context"]) && document2["@context"][0] === DID_CONTEXT_V1);
          if (mustFrame) {
            document2 = await jsonld2.frame(document2, {
              "@context": constants.SECURITY_CONTEXT_URL,
              id: controllerId,
              [term]: {
                "@embed": "@never",
                id: verificationId
              }
            }, { documentLoader, compactToRelative: false, safe: true });
          }
          result.controller = document2;
        }
        const verificationMethods = jsonld2.getValues(result.controller, term);
        result.valid = verificationMethods.some((vm) => vm === verificationId || typeof vm === "object" && vm.id === verificationId);
        if (!result.valid) {
          throw new Error(`Verification method "${verificationMethod.id}" not authorized ` + `by controller for proof purpose "${this.term}".`);
        }
        return result;
      } catch (error) {
        return { valid: false, error };
      }
    }
  };
});

// node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js
var require_AssertionProofPurpose = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   */
  var ControllerProofPurpose = require_ControllerProofPurpose();
  module.exports = class AssertionProofPurpose extends ControllerProofPurpose {
    constructor({
      term = "assertionMethod",
      controller,
      date,
      maxTimestampDelta = Infinity
    } = {}) {
      super({ term, controller, date, maxTimestampDelta });
    }
  };
});

// node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js
var require_AuthenticationProofPurpose = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   */
  var ControllerProofPurpose = require_ControllerProofPurpose();
  module.exports = class AuthenticationProofPurpose extends ControllerProofPurpose {
    constructor({
      term = "authentication",
      controller,
      challenge,
      date,
      domain,
      maxTimestampDelta = Infinity
    } = {}) {
      super({ term, controller, date, maxTimestampDelta });
      if (typeof challenge !== "string") {
        throw new TypeError('"challenge" must be a string.');
      }
      if (domain !== undefined && typeof domain !== "string") {
        throw new TypeError('"domain" must be a string.');
      }
      this.challenge = challenge;
      this.domain = domain;
    }
    async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
      try {
        if (proof.challenge !== this.challenge) {
          throw new Error("The challenge is not as expected; " + `challenge="${proof.challenge}", expected="${this.challenge}"`);
        }
        if (this.domain !== undefined && proof.domain !== this.domain) {
          throw new Error("The domain is not as expected; " + `domain="${proof.domain}", expected="${this.domain}"`);
        }
        return super.validate(proof, { verificationMethod, documentLoader, expansionMap });
      } catch (error) {
        return { valid: false, error };
      }
    }
    async update(proof, { document: document2, suite, documentLoader, expansionMap }) {
      proof = await super.update(proof, { document: document2, suite, documentLoader, expansionMap });
      proof.challenge = this.challenge;
      if (this.domain !== undefined) {
        proof.domain = this.domain;
      }
      return proof;
    }
  };
});

// node_modules/jsonld-signatures/lib/purposes.js
var require_purposes = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
   */
  var api = {};
  module.exports = api;
  api.purposes = {
    AssertionProofPurpose: require_AssertionProofPurpose(),
    AuthenticationProofPurpose: require_AuthenticationProofPurpose(),
    ControllerProofPurpose: require_ControllerProofPurpose(),
    ProofPurpose: require_ProofPurpose()
  };
});

// node_modules/jsonld-signatures/lib/jsonld-signatures.js
var require_jsonld_signatures = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2010-2023 Digital Bazaar, Inc. All rights reserved.
   */
  var api = {};
  module.exports = api;
  var constants = require_constants3();
  Object.assign(api, constants);
  var ProofSet = require_ProofSet();
  var VerificationError = require_VerificationError();
  api.derive = async function derive(document2, {
    suite,
    purpose,
    documentLoader,
    addSuiteContext = true
  } = {}) {
    if (typeof document2 !== "object") {
      throw new TypeError('The "document" parameter must be an object.');
    }
    suite.ensureSuiteContext({ document: document2, addSuiteContext });
    try {
      return await new ProofSet().derive(document2, { suite, purpose, documentLoader });
    } catch (e) {
      if (!documentLoader && e.name === "jsonld.InvalidUrl") {
        const { details: { url } } = e;
        const err = new Error(`A URL "${url}" could not be fetched; you need to pass ` + '"documentLoader" or resolve the URL before calling "derive".');
        err.cause = e;
        throw err;
      }
      throw e;
    }
  };
  api.sign = async function sign(document2, {
    suite,
    purpose,
    documentLoader,
    expansionMap,
    addSuiteContext = true
  } = {}) {
    if (expansionMap) {
      throw new Error('"expansionMap" not supported.');
    }
    if (typeof document2 !== "object") {
      throw new TypeError('The "document" parameter must be an object.');
    }
    suite.ensureSuiteContext({ document: document2, addSuiteContext });
    try {
      return await new ProofSet().add(document2, { suite, purpose, documentLoader });
    } catch (e) {
      if (!documentLoader && e.name === "jsonld.InvalidUrl") {
        const { details: { url } } = e;
        const err = new Error(`A URL "${url}" could not be fetched; you need to pass ` + '"documentLoader" or resolve the URL before calling "sign".');
        err.cause = e;
        throw err;
      }
      throw e;
    }
  };
  api.verify = async function verify(document2, {
    suite,
    purpose,
    documentLoader,
    expansionMap
  } = {}) {
    if (expansionMap) {
      throw new Error('"expansionMap" not supported.');
    }
    if (typeof document2 !== "object") {
      throw new TypeError('The "document" parameter must be an object.');
    }
    const result = await new ProofSet().verify(document2, { suite, purpose, documentLoader });
    const { error } = result;
    if (error) {
      if (!documentLoader && error.name === "jsonld.InvalidUrl") {
        const { details: { url } } = error;
        const urlError = new Error(`A URL "${url}" could not be fetched; you need to pass ` + '"documentLoader" or resolve the URL before calling "verify".');
        result.error = new VerificationError(urlError);
      } else {
        result.error = new VerificationError(error);
      }
    }
    return result;
  };
  api.suites = require_suites().suites;
  api.purposes = require_purposes().purposes;
  Object.assign(api, require_documentLoader());
});

// node_modules/@digitalbazaar/data-integrity-context/js/data-integrity-v1.js
var require_data_integrity_v1 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    "@context": {
      id: "@id",
      type: "@type",
      "@protected": true,
      proof: {
        "@id": "https://w3id.org/security#proof",
        "@type": "@id",
        "@container": "@graph"
      },
      DataIntegrityProof: {
        "@id": "https://w3id.org/security#DataIntegrityProof",
        "@context": {
          "@protected": true,
          id: "@id",
          type: "@type",
          challenge: "https://w3id.org/security#challenge",
          created: {
            "@id": "http://purl.org/dc/terms/created",
            "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
          },
          domain: "https://w3id.org/security#domain",
          expires: {
            "@id": "https://w3id.org/security#expiration",
            "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
          },
          nonce: "https://w3id.org/security#nonce",
          proofPurpose: {
            "@id": "https://w3id.org/security#proofPurpose",
            "@type": "@vocab",
            "@context": {
              "@protected": true,
              id: "@id",
              type: "@type",
              assertionMethod: {
                "@id": "https://w3id.org/security#assertionMethod",
                "@type": "@id",
                "@container": "@set"
              },
              authentication: {
                "@id": "https://w3id.org/security#authenticationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              capabilityInvocation: {
                "@id": "https://w3id.org/security#capabilityInvocationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              capabilityDelegation: {
                "@id": "https://w3id.org/security#capabilityDelegationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              keyAgreement: {
                "@id": "https://w3id.org/security#keyAgreementMethod",
                "@type": "@id",
                "@container": "@set"
              }
            }
          },
          cryptosuite: "https://w3id.org/security#cryptosuite",
          proofValue: {
            "@id": "https://w3id.org/security#proofValue",
            "@type": "https://w3id.org/security#multibase"
          },
          verificationMethod: {
            "@id": "https://w3id.org/security#verificationMethod",
            "@type": "@id"
          }
        }
      }
    }
  };
});

// node_modules/@digitalbazaar/data-integrity-context/js/data-integrity-v2.js
var require_data_integrity_v2 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    "@context": {
      id: "@id",
      type: "@type",
      "@protected": true,
      proof: {
        "@id": "https://w3id.org/security#proof",
        "@type": "@id",
        "@container": "@graph"
      },
      DataIntegrityProof: {
        "@id": "https://w3id.org/security#DataIntegrityProof",
        "@context": {
          "@protected": true,
          id: "@id",
          type: "@type",
          challenge: "https://w3id.org/security#challenge",
          created: {
            "@id": "http://purl.org/dc/terms/created",
            "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
          },
          domain: "https://w3id.org/security#domain",
          expires: {
            "@id": "https://w3id.org/security#expiration",
            "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
          },
          nonce: "https://w3id.org/security#nonce",
          previousProof: {
            "@id": "https://w3id.org/security#previousProof",
            "@type": "@id"
          },
          proofPurpose: {
            "@id": "https://w3id.org/security#proofPurpose",
            "@type": "@vocab",
            "@context": {
              "@protected": true,
              id: "@id",
              type: "@type",
              assertionMethod: {
                "@id": "https://w3id.org/security#assertionMethod",
                "@type": "@id",
                "@container": "@set"
              },
              authentication: {
                "@id": "https://w3id.org/security#authenticationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              capabilityInvocation: {
                "@id": "https://w3id.org/security#capabilityInvocationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              capabilityDelegation: {
                "@id": "https://w3id.org/security#capabilityDelegationMethod",
                "@type": "@id",
                "@container": "@set"
              },
              keyAgreement: {
                "@id": "https://w3id.org/security#keyAgreementMethod",
                "@type": "@id",
                "@container": "@set"
              }
            }
          },
          cryptosuite: {
            "@id": "https://w3id.org/security#cryptosuite",
            "@type": "https://w3id.org/security#cryptosuiteString"
          },
          proofValue: {
            "@id": "https://w3id.org/security#proofValue",
            "@type": "https://w3id.org/security#multibase"
          },
          verificationMethod: {
            "@id": "https://w3id.org/security#verificationMethod",
            "@type": "@id"
          }
        }
      }
    }
  };
});

// node_modules/@digitalbazaar/data-integrity-context/js/constants.js
var require_constants4 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
   */
  module.exports = {
    CONTEXT_FILENAME_V1: "data-integrity-v1.jsonld",
    CONTEXT_FILENAME_V2: "data-integrity-v2.jsonld",
    DATA_INTEGRITY_CONTEXT_V1_URL: "https://w3id.org/security/data-integrity/v1",
    DATA_INTEGRITY_CONTEXT_V2_URL: "https://w3id.org/security/data-integrity/v2",
    CONTEXT_URL: "https://w3id.org/security/data-integrity/v2",
    CBORLD_VALUE_V1: 48,
    CBORLD_VALUE: 51
  };
});

// node_modules/@digitalbazaar/data-integrity-context/js/index.js
var require_js2 = __commonJS((exports, module) => {
  /*!
   * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
   */
  var contextV1 = require_data_integrity_v1();
  var contextV2 = require_data_integrity_v2();
  var constants = require_constants4();
  var {
    CONTEXT_URL,
    DATA_INTEGRITY_CONTEXT_V1_URL,
    DATA_INTEGRITY_CONTEXT_V2_URL,
    CBORLD_VALUE
  } = constants;
  var contexts = new Map;
  contexts.set(DATA_INTEGRITY_CONTEXT_V1_URL, contextV1);
  contexts.set(DATA_INTEGRITY_CONTEXT_V2_URL, contextV2);
  var appContextMap = new Map;
  appContextMap.set(CONTEXT_URL, CBORLD_VALUE);
  module.exports = {
    constants,
    contexts,
    appContextMap,
    DATA_INTEGRITY_CONTEXT_V1_URL,
    DATA_INTEGRITY_CONTEXT_V2_URL,
    CONTEXT_URL,
    CONTEXT: contextV2
  };
});

// node_modules/http-link-header/lib/link.js
var require_link = __commonJS((exports, module) => {
  var COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;
  var WS_TRIM_PATTERN = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  var WS_CHAR_PATTERN = /\s|\uFEFF|\xA0/;
  var WS_FOLD_PATTERN = /\r?\n[\x20\x09]+/g;
  var DELIMITER_PATTERN = /[;,"]/;
  var WS_DELIMITER_PATTERN = /[;,"]|\s/;
  var TOKEN_PATTERN = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/;
  var STATE = {
    IDLE: 1 << 0,
    URI: 1 << 1,
    ATTR: 1 << 2
  };
  function trim(value) {
    return value.replace(WS_TRIM_PATTERN, "");
  }
  function hasWhitespace(value) {
    return WS_CHAR_PATTERN.test(value);
  }
  function skipWhitespace(value, offset) {
    while (hasWhitespace(value[offset])) {
      offset++;
    }
    return offset;
  }
  function needsQuotes(value) {
    return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);
  }
  function shallowCompareObjects(object1, object2) {
    return Object.keys(object1).length === Object.keys(object2).length && Object.keys(object1).every((key) => (key in object2) && object1[key] === object2[key]);
  }

  class Link {
    constructor(value) {
      this.refs = [];
      if (value) {
        this.parse(value);
      }
    }
    rel(value) {
      var links = [];
      var type = value.toLowerCase();
      for (var i = 0;i < this.refs.length; i++) {
        if (typeof this.refs[i].rel === "string" && this.refs[i].rel.toLowerCase() === type) {
          links.push(this.refs[i]);
        }
      }
      return links;
    }
    get(attr, value) {
      attr = attr.toLowerCase();
      value = value.toLowerCase();
      var links = [];
      for (var i = 0;i < this.refs.length; i++) {
        if (typeof this.refs[i][attr] === "string" && this.refs[i][attr].toLowerCase() === value) {
          links.push(this.refs[i]);
        }
      }
      return links;
    }
    set(link) {
      this.refs.push(link);
      return this;
    }
    setUnique(link) {
      if (!this.refs.some((ref) => shallowCompareObjects(ref, link))) {
        this.refs.push(link);
      }
      return this;
    }
    has(attr, value) {
      attr = attr.toLowerCase();
      value = value.toLowerCase();
      for (var i = 0;i < this.refs.length; i++) {
        if (typeof this.refs[i][attr] === "string" && this.refs[i][attr].toLowerCase() === value) {
          return true;
        }
      }
      return false;
    }
    parse(value, offset) {
      offset = offset || 0;
      value = offset ? value.slice(offset) : value;
      value = trim(value).replace(WS_FOLD_PATTERN, "");
      var state = STATE.IDLE;
      var length = value.length;
      var offset = 0;
      var ref = null;
      while (offset < length) {
        if (state === STATE.IDLE) {
          if (hasWhitespace(value[offset])) {
            offset++;
            continue;
          } else if (value[offset] === "<") {
            if (ref != null) {
              ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);
            }
            var end = value.indexOf(">", offset);
            if (end === -1)
              throw new Error("Expected end of URI delimiter at offset " + offset);
            ref = { uri: value.slice(offset + 1, end) };
            offset = end;
            state = STATE.URI;
          } else {
            throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
          }
          offset++;
        } else if (state === STATE.URI) {
          if (hasWhitespace(value[offset])) {
            offset++;
            continue;
          } else if (value[offset] === ";") {
            state = STATE.ATTR;
            offset++;
          } else if (value[offset] === ",") {
            state = STATE.IDLE;
            offset++;
          } else {
            throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
          }
        } else if (state === STATE.ATTR) {
          if (value[offset] === ";" || hasWhitespace(value[offset])) {
            offset++;
            continue;
          }
          var end = value.indexOf("=", offset);
          if (end === -1)
            end = value.indexOf(";", offset);
          if (end === -1)
            end = value.length;
          var attr = trim(value.slice(offset, end)).toLowerCase();
          var attrValue = "";
          offset = end + 1;
          offset = skipWhitespace(value, offset);
          if (value[offset] === '"') {
            offset++;
            while (offset < length) {
              if (value[offset] === '"') {
                offset++;
                break;
              }
              if (value[offset] === "\\") {
                offset++;
              }
              attrValue += value[offset];
              offset++;
            }
          } else {
            var end = offset + 1;
            while (!DELIMITER_PATTERN.test(value[end]) && end < length) {
              end++;
            }
            attrValue = value.slice(offset, end);
            offset = end;
          }
          if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {
          } else if (attr[attr.length - 1] === "*") {
            ref[attr] = Link.parseExtendedValue(attrValue);
          } else {
            attrValue = attr === "type" ? attrValue.toLowerCase() : attrValue;
            if (ref[attr] != null) {
              if (Array.isArray(ref[attr])) {
                ref[attr].push(attrValue);
              } else {
                ref[attr] = [ref[attr], attrValue];
              }
            } else {
              ref[attr] = attrValue;
            }
          }
          switch (value[offset]) {
            case ",":
              state = STATE.IDLE;
              break;
            case ";":
              state = STATE.ATTR;
              break;
          }
          offset++;
        } else {
          throw new Error('Unknown parser state "' + state + '"');
        }
      }
      if (ref != null) {
        ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);
      }
      ref = null;
      return this;
    }
    toString() {
      var refs = [];
      var link = "";
      var ref = null;
      for (var i = 0;i < this.refs.length; i++) {
        ref = this.refs[i];
        link = Object.keys(this.refs[i]).reduce(function(link2, attr) {
          if (attr === "uri")
            return link2;
          return link2 + "; " + Link.formatAttribute(attr, ref[attr]);
        }, "<" + ref.uri + ">");
        refs.push(link);
      }
      return refs.join(", ");
    }
  }
  Link.isCompatibleEncoding = function(value) {
    return COMPATIBLE_ENCODING_PATTERN.test(value);
  };
  Link.parse = function(value, offset) {
    return new Link().parse(value, offset);
  };
  Link.isSingleOccurenceAttr = function(attr) {
    return attr === "rel" || attr === "type" || attr === "media" || attr === "title" || attr === "title*";
  };
  Link.isTokenAttr = function(attr) {
    return attr === "rel" || attr === "type" || attr === "anchor";
  };
  Link.escapeQuotes = function(value) {
    return value.replace(/"/g, "\\\"");
  };
  Link.expandRelations = function(ref) {
    var rels = ref.rel.split(" ");
    return rels.map(function(rel) {
      var value = Object.assign({}, ref);
      value.rel = rel;
      return value;
    });
  };
  Link.parseExtendedValue = function(value) {
    var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec(value);
    return {
      language: parts[2].toLowerCase(),
      encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),
      value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]
    };
  };
  Link.formatExtendedAttribute = function(attr, data) {
    var encoding = (data.encoding || "utf-8").toUpperCase();
    var language = data.language || "en";
    var encodedValue = "";
    if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {
      encodedValue = data.value.toString(encoding);
    } else if (Buffer.isBuffer(data.value)) {
      encodedValue = data.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1");
    } else {
      encodedValue = encodeURIComponent(data.value);
    }
    return attr + "=" + encoding + "'" + language + "'" + encodedValue;
  };
  Link.formatAttribute = function(attr, value) {
    if (Array.isArray(value)) {
      return value.map((item) => {
        return Link.formatAttribute(attr, item);
      }).join("; ");
    }
    if (attr[attr.length - 1] === "*" || typeof value !== "string") {
      return Link.formatExtendedAttribute(attr, value);
    }
    if (Link.isTokenAttr(attr)) {
      value = needsQuotes(value) ? '"' + Link.escapeQuotes(value) + '"' : Link.escapeQuotes(value);
    } else if (needsQuotes(value)) {
      value = encodeURIComponent(value);
      value = value.replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";");
      value = '"' + value + '"';
    }
    return attr + "=" + value;
  };
  module.exports = Link;
});

// node_modules/jsonld-document-loader/lib/JsonLdDocumentLoader.js
/*!
 * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.
 */

class JsonLdDocumentLoader {
  constructor() {
    this.documents = new Map;
    this.protocolHandlers = new Map;
  }
  addStatic(url, document2) {
    if (!_isString(url)) {
      throw new TypeError("The first parameter (url) must be a string.");
    }
    if (!_isObject(document2)) {
      throw new TypeError("The second parameter (document) must be an object.");
    }
    this.documents.set(url, document2);
  }
  setProtocolHandler({ protocol, handler } = {}) {
    this.protocolHandlers.set(protocol, handler);
  }
  setDidResolver(didResolver) {
    this.setProtocolHandler({ protocol: "did", handler: didResolver });
  }
  async documentLoader(url) {
    if (!_isString(url)) {
      throw new TypeError('The "url" parameter must be a string.');
    }
    let document2;
    document2 = this.documents.get(url);
    let tag;
    if (document2) {
      tag = "static";
    }
    if (!document2) {
      const [protocol] = url.split(":");
      if (this.protocolHandlers.has(protocol)) {
        document2 = await this.protocolHandlers.get(protocol).get({ url });
      }
    }
    if (document2) {
      const result = {
        contextUrl: null,
        document: document2,
        documentUrl: url
      };
      if (tag) {
        result.tag = tag;
      }
      return result;
    }
    throw new Error(`Document not found in document loader: ${url}`);
  }
  build() {
    return this.documentLoader.bind(this);
  }
}
function _isString(arg) {
  return typeof arg === "string";
}
function _isObject(arg) {
  return typeof arg === "object" && arg !== null;
}

// node_modules/jsonld-document-loader/lib/index.js
/*!
 * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.
 */

// src/utils/index.ts
var import_jsonld = __toESM(require_jsonld(), 1);

// node_modules/n3/src/N3Lexer.js
var import_queue_microtask = __toESM(require_queue_microtask(), 1);

// node_modules/n3/src/IRIs.js
var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
var XSD = "http://www.w3.org/2001/XMLSchema#";
var SWAP = "http://www.w3.org/2000/10/swap/";
var IRIs_default = {
  xsd: {
    decimal: `${XSD}decimal`,
    boolean: `${XSD}boolean`,
    double: `${XSD}double`,
    integer: `${XSD}integer`,
    string: `${XSD}string`
  },
  rdf: {
    type: `${RDF}type`,
    nil: `${RDF}nil`,
    first: `${RDF}first`,
    rest: `${RDF}rest`,
    langString: `${RDF}langString`
  },
  owl: {
    sameAs: "http://www.w3.org/2002/07/owl#sameAs"
  },
  r: {
    forSome: `${SWAP}reify#forSome`,
    forAll: `${SWAP}reify#forAll`
  },
  log: {
    implies: `${SWAP}log#implies`
  }
};

// node_modules/n3/src/N3Lexer.js
var { xsd } = IRIs_default;
var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
var escapeReplacements = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  n: `
`,
  r: "\r",
  t: "\t",
  f: "\f",
  b: "\b",
  _: "_",
  "~": "~",
  ".": ".",
  "-": "-",
  "!": "!",
  $: "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "*": "*",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%"
};
var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
var lineModeRegExps = {
  _iri: true,
  _unescapedIri: true,
  _simpleQuotedString: true,
  _langcode: true,
  _blank: true,
  _newline: true,
  _comment: true,
  _whitespace: true,
  _endOfFile: true
};
var invalidRegExp = /$0^/;

class N3Lexer {
  constructor(options) {
    this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/;
    this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/;
    this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/;
    this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
    this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
    this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
    this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
    this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
    this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
    this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
    this._keyword = /^@[a-z]+(?=[\s#<:])/i;
    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
    this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
    this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
    this._comment = /#([^\n\r]*)/;
    this._whitespace = /^[ \t]+/;
    this._endOfFile = /^(?:#[^\n\r]*)?$/;
    options = options || {};
    if (this._lineMode = !!options.lineMode) {
      this._n3Mode = false;
      for (const key in this) {
        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
          this[key] = invalidRegExp;
      }
    } else {
      this._n3Mode = options.n3 !== false;
    }
    this._comments = !!options.comments;
    this._literalClosingPos = 0;
  }
  _tokenizeToEnd(callback, inputFinished) {
    let input = this._input;
    let currentLineLength = input.length;
    while (true) {
      let whiteSpaceMatch, comment;
      while (whiteSpaceMatch = this._newline.exec(input)) {
        if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0])))
          emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
        input = input.substr(whiteSpaceMatch[0].length, input.length);
        currentLineLength = input.length;
        this._line++;
      }
      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))
        input = input.substr(whiteSpaceMatch[0].length, input.length);
      if (this._endOfFile.test(input)) {
        if (inputFinished) {
          if (this._comments && (comment = this._comment.exec(input)))
            emitToken("comment", comment[1], "", this._line, input.length);
          input = null;
          emitToken("eof", "", "", this._line, 0);
        }
        return this._input = input;
      }
      const line = this._line, firstChar = input[0];
      let type = "", value = "", prefix = "", match = null, matchLength = 0, inconclusive = false;
      switch (firstChar) {
        case "^":
          if (input.length < 3)
            break;
          else if (input[1] === "^") {
            this._previousMarker = "^^";
            input = input.substr(2);
            if (input[0] !== "<") {
              inconclusive = true;
              break;
            }
          } else {
            if (this._n3Mode) {
              matchLength = 1;
              type = "^";
            }
            break;
          }
        case "<":
          if (match = this._unescapedIri.exec(input))
            type = "IRI", value = match[1];
          else if (match = this._iri.exec(input)) {
            value = this._unescape(match[1]);
            if (value === null || illegalIriChars.test(value))
              return reportSyntaxError(this);
            type = "IRI";
          } else if (input.length > 1 && input[1] === "<")
            type = "<<", matchLength = 2;
          else if (this._n3Mode && input.length > 1 && input[1] === "=")
            type = "inverse", matchLength = 2, value = ">";
          break;
        case ">":
          if (input.length > 1 && input[1] === ">")
            type = ">>", matchLength = 2;
          break;
        case "_":
          if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `)))
            type = "blank", prefix = "_", value = match[1];
          break;
        case '"':
          if (match = this._simpleQuotedString.exec(input))
            value = match[1];
          else {
            ({ value, matchLength } = this._parseLiteral(input));
            if (value === null)
              return reportSyntaxError(this);
          }
          if (match !== null || matchLength !== 0) {
            type = "literal";
            this._literalClosingPos = 0;
          }
          break;
        case "'":
          if (!this._lineMode) {
            if (match = this._simpleApostropheString.exec(input))
              value = match[1];
            else {
              ({ value, matchLength } = this._parseLiteral(input));
              if (value === null)
                return reportSyntaxError(this);
            }
            if (match !== null || matchLength !== 0) {
              type = "literal";
              this._literalClosingPos = 0;
            }
          }
          break;
        case "?":
          if (this._n3Mode && (match = this._variable.exec(input)))
            type = "var", value = match[0];
          break;
        case "@":
          if (this._previousMarker === "literal" && (match = this._langcode.exec(input)))
            type = "langcode", value = match[1];
          else if (match = this._keyword.exec(input))
            type = match[0];
          break;
        case ".":
          if (input.length === 1 ? inputFinished : input[1] < "0" || input[1] > "9") {
            type = ".";
            matchLength = 1;
            break;
          }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "+":
        case "-":
          if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {
            type = "literal", value = match[0];
            prefix = typeof match[1] === "string" ? xsd.double : typeof match[2] === "string" ? xsd.decimal : xsd.integer;
          }
          break;
        case "B":
        case "b":
        case "p":
        case "P":
        case "G":
        case "g":
          if (match = this._sparqlKeyword.exec(input))
            type = match[0].toUpperCase();
          else
            inconclusive = true;
          break;
        case "f":
        case "t":
          if (match = this._boolean.exec(input))
            type = "literal", value = match[0], prefix = xsd.boolean;
          else
            inconclusive = true;
          break;
        case "a":
          if (match = this._shortPredicates.exec(input))
            type = "abbreviation", value = "a";
          else
            inconclusive = true;
          break;
        case "=":
          if (this._n3Mode && input.length > 1) {
            type = "abbreviation";
            if (input[1] !== ">")
              matchLength = 1, value = "=";
            else
              matchLength = 2, value = ">";
          }
          break;
        case "!":
          if (!this._n3Mode)
            break;
        case ",":
        case ";":
        case "[":
        case "]":
        case "(":
        case ")":
        case "}":
          if (!this._lineMode) {
            matchLength = 1;
            type = firstChar;
          }
          break;
        case "{":
          if (!this._lineMode && input.length >= 2) {
            if (input[1] === "|")
              type = "{|", matchLength = 2;
            else
              type = firstChar, matchLength = 1;
          }
          break;
        case "|":
          if (input.length >= 2 && input[1] === "}")
            type = "|}", matchLength = 2;
          break;
        default:
          inconclusive = true;
      }
      if (inconclusive) {
        if ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (match = this._prefix.exec(input)))
          type = "prefix", value = match[1] || "";
        else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `)))
          type = "prefixed", prefix = match[1] || "", value = this._unescape(match[2]);
      }
      if (this._previousMarker === "^^") {
        switch (type) {
          case "prefixed":
            type = "type";
            break;
          case "IRI":
            type = "typeIRI";
            break;
          default:
            type = "";
        }
      }
      if (!type) {
        if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input))
          return reportSyntaxError(this);
        else
          return this._input = input;
      }
      const length = matchLength || match[0].length;
      const token = emitToken(type, value, prefix, line, length);
      this.previousToken = token;
      this._previousMarker = type;
      input = input.substr(length, input.length);
    }
    function emitToken(type, value, prefix, line, length) {
      const start = input ? currentLineLength - input.length : currentLineLength;
      const end = start + length;
      const token = { type, value, prefix, line, start, end };
      callback(null, token);
      return token;
    }
    function reportSyntaxError(self2) {
      callback(self2._syntaxError(/^\S*/.exec(input)[0]));
    }
  }
  _unescape(item) {
    let invalid = false;
    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
      if (typeof unicode4 === "string")
        return String.fromCharCode(Number.parseInt(unicode4, 16));
      if (typeof unicode8 === "string") {
        let charCode = Number.parseInt(unicode8, 16);
        return charCode <= 65535 ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(55296 + ((charCode -= 65536) >> 10), 56320 + (charCode & 1023));
      }
      if (escapedChar in escapeReplacements)
        return escapeReplacements[escapedChar];
      invalid = true;
      return "";
    });
    return invalid ? null : replaced;
  }
  _parseLiteral(input) {
    if (input.length >= 3) {
      const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
      const openingLength = opening.length;
      let closingPos = Math.max(this._literalClosingPos, openingLength);
      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
        let backslashCount = 0;
        while (input[closingPos - backslashCount - 1] === "\\")
          backslashCount++;
        if (backslashCount % 2 === 0) {
          const raw = input.substring(openingLength, closingPos);
          const lines = raw.split(/\r\n|\r|\n/).length - 1;
          const matchLength = closingPos + openingLength;
          if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode)
            break;
          this._line += lines;
          return { value: this._unescape(raw), matchLength };
        }
        closingPos++;
      }
      this._literalClosingPos = input.length - openingLength + 1;
    }
    return { value: "", matchLength: 0 };
  }
  _syntaxError(issue) {
    this._input = null;
    const err = new Error(`Unexpected "${issue}" on line ${this._line}.`);
    err.context = {
      token: undefined,
      line: this._line,
      previousToken: this.previousToken
    };
    return err;
  }
  _readStartingBom(input) {
    return input.startsWith("\uFEFF") ? input.substr(1) : input;
  }
  tokenize(input, callback) {
    this._line = 1;
    if (typeof input === "string") {
      this._input = this._readStartingBom(input);
      if (typeof callback === "function")
        import_queue_microtask.default(() => this._tokenizeToEnd(callback, true));
      else {
        const tokens = [];
        let error;
        this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);
        if (error)
          throw error;
        return tokens;
      }
    } else {
      this._pendingBuffer = null;
      if (typeof input.setEncoding === "function")
        input.setEncoding("utf8");
      input.on("data", (data) => {
        if (this._input !== null && data.length !== 0) {
          if (this._pendingBuffer) {
            data = Buffer.concat([this._pendingBuffer, data]);
            this._pendingBuffer = null;
          }
          if (data[data.length - 1] & 128) {
            this._pendingBuffer = data;
          } else {
            if (typeof this._input === "undefined")
              this._input = this._readStartingBom(typeof data === "string" ? data : data.toString());
            else
              this._input += data;
            this._tokenizeToEnd(callback, false);
          }
        }
      });
      input.on("end", () => {
        if (typeof this._input === "string")
          this._tokenizeToEnd(callback, true);
      });
      input.on("error", callback);
    }
  }
}

// node_modules/n3/src/N3DataFactory.js
var { rdf, xsd: xsd2 } = IRIs_default;
var DEFAULTGRAPH;
var _blankNodeCounter = 0;
var DataFactory = {
  namedNode,
  blankNode,
  variable,
  literal,
  defaultGraph,
  quad,
  triple: quad
};
var N3DataFactory_default = DataFactory;

class Term {
  constructor(id) {
    this.id = id;
  }
  get value() {
    return this.id;
  }
  equals(other) {
    if (other instanceof Term)
      return this.id === other.id;
    return !!other && this.termType === other.termType && this.value === other.value;
  }
  hashCode() {
    return 0;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value
    };
  }
}

class NamedNode extends Term {
  get termType() {
    return "NamedNode";
  }
}

class Literal extends Term {
  get termType() {
    return "Literal";
  }
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }
  get language() {
    const id = this.id;
    let atPos = id.lastIndexOf('"') + 1;
    return atPos < id.length && id[atPos++] === "@" ? id.substr(atPos).toLowerCase() : "";
  }
  get datatype() {
    return new NamedNode(this.datatypeString);
  }
  get datatypeString() {
    const id = this.id, dtPos = id.lastIndexOf('"') + 1;
    const char = dtPos < id.length ? id[dtPos] : "";
    return char === "^" ? id.substr(dtPos + 2) : char !== "@" ? xsd2.string : rdf.langString;
  }
  equals(other) {
    if (other instanceof Literal)
      return this.id === other.id;
    return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value,
      language: this.language,
      datatype: { termType: "NamedNode", value: this.datatypeString }
    };
  }
}

class BlankNode extends Term {
  constructor(name) {
    super(`_:${name}`);
  }
  get termType() {
    return "BlankNode";
  }
  get value() {
    return this.id.substr(2);
  }
}

class Variable extends Term {
  constructor(name) {
    super(`?${name}`);
  }
  get termType() {
    return "Variable";
  }
  get value() {
    return this.id.substr(1);
  }
}

class DefaultGraph extends Term {
  constructor() {
    super("");
    return DEFAULTGRAPH || this;
  }
  get termType() {
    return "DefaultGraph";
  }
  equals(other) {
    return this === other || !!other && this.termType === other.termType;
  }
}
DEFAULTGRAPH = new DefaultGraph;
function termFromId(id, factory, nested) {
  factory = factory || DataFactory;
  if (!id)
    return factory.defaultGraph();
  switch (id[0]) {
    case "?":
      return factory.variable(id.substr(1));
    case "_":
      return factory.blankNode(id.substr(2));
    case '"':
      if (factory === DataFactory)
        return new Literal(id);
      if (id[id.length - 1] === '"')
        return factory.literal(id.substr(1, id.length - 2));
      const endPos = id.lastIndexOf('"', id.length - 1);
      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === "@" ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));
    case "[":
      id = JSON.parse(id);
      break;
    default:
      if (!nested || !Array.isArray(id)) {
        return factory.namedNode(id);
      }
  }
  return factory.quad(termFromId(id[0], factory, true), termFromId(id[1], factory, true), termFromId(id[2], factory, true), id[3] && termFromId(id[3], factory, true));
}
function termToId(term, nested) {
  if (typeof term === "string")
    return term;
  if (term instanceof Term && term.termType !== "Quad")
    return term.id;
  if (!term)
    return DEFAULTGRAPH.id;
  switch (term.termType) {
    case "NamedNode":
      return term.value;
    case "BlankNode":
      return `_:${term.value}`;
    case "Variable":
      return `?${term.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return `"${term.value}"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd2.string ? `^^${term.datatype.value}` : ""}`;
    case "Quad":
      const res = [
        termToId(term.subject, true),
        termToId(term.predicate, true),
        termToId(term.object, true)
      ];
      if (term.graph && term.graph.termType !== "DefaultGraph") {
        res.push(termToId(term.graph, true));
      }
      return nested ? res : JSON.stringify(res);
    default:
      throw new Error(`Unexpected termType: ${term.termType}`);
  }
}

class Quad extends Term {
  constructor(subject, predicate, object, graph) {
    super("");
    this._subject = subject;
    this._predicate = predicate;
    this._object = object;
    this._graph = graph || DEFAULTGRAPH;
  }
  get termType() {
    return "Quad";
  }
  get subject() {
    return this._subject;
  }
  get predicate() {
    return this._predicate;
  }
  get object() {
    return this._object;
  }
  get graph() {
    return this._graph;
  }
  toJSON() {
    return {
      termType: this.termType,
      subject: this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object: this._object.toJSON(),
      graph: this._graph.toJSON()
    };
  }
  equals(other) {
    return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);
  }
}
function namedNode(iri) {
  return new NamedNode(iri);
}
function blankNode(name) {
  return new BlankNode(name || `n3-${_blankNodeCounter++}`);
}
function literal(value, languageOrDataType) {
  if (typeof languageOrDataType === "string")
    return new Literal(`"${value}"@${languageOrDataType.toLowerCase()}`);
  let datatype = languageOrDataType ? languageOrDataType.value : "";
  if (datatype === "") {
    if (typeof value === "boolean")
      datatype = xsd2.boolean;
    else if (typeof value === "number") {
      if (Number.isFinite(value))
        datatype = Number.isInteger(value) ? xsd2.integer : xsd2.double;
      else {
        datatype = xsd2.double;
        if (!Number.isNaN(value))
          value = value > 0 ? "INF" : "-INF";
      }
    }
  }
  return datatype === "" || datatype === xsd2.string ? new Literal(`"${value}"`) : new Literal(`"${value}"^^${datatype}`);
}
function variable(name) {
  return new Variable(name);
}
function defaultGraph() {
  return DEFAULTGRAPH;
}
function quad(subject, predicate, object, graph) {
  return new Quad(subject, predicate, object, graph);
}

// node_modules/n3/src/N3Parser.js
var blankNodePrefix = 0;

class N3Parser {
  constructor(options) {
    this._contextStack = [];
    this._graph = null;
    options = options || {};
    this._setBase(options.baseIRI);
    options.factory && initDataFactory(this, options.factory);
    const format = typeof options.format === "string" ? options.format.match(/\w*$/)[0].toLowerCase() : "", isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;
    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))
      this._readPredicateOrNamedGraph = this._readPredicate;
    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
    this._supportsRDFStar = format === "" || /star|\*$/.test(format);
    if (isLineMode)
      this._resolveRelativeIRI = (iri) => {
        return null;
      };
    this._blankNodePrefix = typeof options.blankNodePrefix !== "string" ? "" : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });
    this._explicitQuantifiers = !!options.explicitQuantifiers;
  }
  static _resetBlankNodePrefix() {
    blankNodePrefix = 0;
  }
  _setBase(baseIRI) {
    if (!baseIRI) {
      this._base = "";
      this._basePath = "";
    } else {
      const fragmentPos = baseIRI.indexOf("#");
      if (fragmentPos >= 0)
        baseIRI = baseIRI.substr(0, fragmentPos);
      this._base = baseIRI;
      this._basePath = baseIRI.indexOf("/") < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, "");
      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
      this._baseRoot = baseIRI[0];
      this._baseScheme = baseIRI[1];
    }
  }
  _saveContext(type, graph, subject, predicate, object) {
    const n3Mode = this._n3Mode;
    this._contextStack.push({
      type,
      subject,
      predicate,
      object,
      graph,
      inverse: n3Mode ? this._inversePredicate : false,
      blankPrefix: n3Mode ? this._prefixes._ : "",
      quantified: n3Mode ? this._quantified : null
    });
    if (n3Mode) {
      this._inversePredicate = false;
      this._prefixes._ = this._graph ? `${this._graph.value}.` : ".";
      this._quantified = Object.create(this._quantified);
    }
  }
  _restoreContext(type, token) {
    const context = this._contextStack.pop();
    if (!context || context.type !== type)
      return this._error(`Unexpected ${token.type}`, token);
    this._subject = context.subject;
    this._predicate = context.predicate;
    this._object = context.object;
    this._graph = context.graph;
    if (this._n3Mode) {
      this._inversePredicate = context.inverse;
      this._prefixes._ = context.blankPrefix;
      this._quantified = context.quantified;
    }
  }
  _readInTopContext(token) {
    switch (token.type) {
      case "eof":
        if (this._graph !== null)
          return this._error("Unclosed graph", token);
        delete this._prefixes._;
        return this._callback(null, null, this._prefixes);
      case "PREFIX":
        this._sparqlStyle = true;
      case "@prefix":
        return this._readPrefix;
      case "BASE":
        this._sparqlStyle = true;
      case "@base":
        return this._readBaseIRI;
      case "{":
        if (this._supportsNamedGraphs) {
          this._graph = "";
          this._subject = null;
          return this._readSubject;
        }
      case "GRAPH":
        if (this._supportsNamedGraphs)
          return this._readNamedGraphLabel;
      default:
        return this._readSubject(token);
    }
  }
  _readEntity(token, quantifier) {
    let value;
    switch (token.type) {
      case "IRI":
      case "typeIRI":
        const iri = this._resolveIRI(token.value);
        if (iri === null)
          return this._error("Invalid IRI", token);
        value = this._namedNode(iri);
        break;
      case "type":
      case "prefixed":
        const prefix = this._prefixes[token.prefix];
        if (prefix === undefined)
          return this._error(`Undefined prefix "${token.prefix}:"`, token);
        value = this._namedNode(prefix + token.value);
        break;
      case "blank":
        value = this._blankNode(this._prefixes[token.prefix] + token.value);
        break;
      case "var":
        value = this._variable(token.value.substr(1));
        break;
      default:
        return this._error(`Expected entity but got ${token.type}`, token);
    }
    if (!quantifier && this._n3Mode && value.id in this._quantified)
      value = this._quantified[value.id];
    return value;
  }
  _readSubject(token) {
    this._predicate = null;
    switch (token.type) {
      case "[":
        this._saveContext("blank", this._graph, this._subject = this._blankNode(), null, null);
        return this._readBlankNodeHead;
      case "(":
        this._saveContext("list", this._graph, this.RDF_NIL, null, null);
        this._subject = null;
        return this._readListItem;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext("formula", this._graph, this._graph = this._blankNode(), null, null);
        return this._readSubject;
      case "}":
        return this._readPunctuation(token);
      case "@forSome":
        if (!this._n3Mode)
          return this._error('Unexpected "@forSome"', token);
        this._subject = null;
        this._predicate = this.N3_FORSOME;
        this._quantifier = this._blankNode;
        return this._readQuantifierList;
      case "@forAll":
        if (!this._n3Mode)
          return this._error('Unexpected "@forAll"', token);
        this._subject = null;
        this._predicate = this.N3_FORALL;
        this._quantifier = this._variable;
        return this._readQuantifierList;
      case "literal":
        if (!this._n3Mode)
          return this._error("Unexpected literal", token);
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          return this._completeSubjectLiteral;
        } else
          this._subject = this._literal(token.value, this._namedNode(token.prefix));
        break;
      case "<<":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF* syntax", token);
        this._saveContext("<<", this._graph, null, null, null);
        this._graph = null;
        return this._readSubject;
      default:
        if ((this._subject = this._readEntity(token)) === undefined)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._readPredicateOrNamedGraph);
    }
    return this._readPredicateOrNamedGraph;
  }
  _readPredicate(token) {
    const type = token.type;
    switch (type) {
      case "inverse":
        this._inversePredicate = true;
      case "abbreviation":
        this._predicate = this.ABBREVIATIONS[token.value];
        break;
      case ".":
      case "]":
      case "}":
        if (this._predicate === null)
          return this._error(`Unexpected ${type}`, token);
        this._subject = null;
        return type === "]" ? this._readBlankNodeTail(token) : this._readPunctuation(token);
      case ";":
        return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", token);
      case "[":
        if (this._n3Mode) {
          this._saveContext("blank", this._graph, this._subject, this._subject = this._blankNode(), null);
          return this._readBlankNodeHead;
        }
      case "blank":
        if (!this._n3Mode)
          return this._error("Disallowed blank node as predicate", token);
      default:
        if ((this._predicate = this._readEntity(token)) === undefined)
          return;
    }
    return this._readObject;
  }
  _readObject(token) {
    switch (token.type) {
      case "literal":
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          return this._readDataTypeOrLang;
        } else
          this._object = this._literal(token.value, this._namedNode(token.prefix));
        break;
      case "[":
        this._saveContext("blank", this._graph, this._subject, this._predicate, this._subject = this._blankNode());
        return this._readBlankNodeHead;
      case "(":
        this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL);
        this._subject = null;
        return this._readListItem;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode());
        return this._readSubject;
      case "<<":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF* syntax", token);
        this._saveContext("<<", this._graph, this._subject, this._predicate, null);
        this._graph = null;
        return this._readSubject;
      default:
        if ((this._object = this._readEntity(token)) === undefined)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._getContextEndReader());
    }
    return this._getContextEndReader();
  }
  _readPredicateOrNamedGraph(token) {
    return token.type === "{" ? this._readGraph(token) : this._readPredicate(token);
  }
  _readGraph(token) {
    if (token.type !== "{")
      return this._error(`Expected graph but got ${token.type}`, token);
    this._graph = this._subject, this._subject = null;
    return this._readSubject;
  }
  _readBlankNodeHead(token) {
    if (token.type === "]") {
      this._subject = null;
      return this._readBlankNodeTail(token);
    } else {
      this._predicate = null;
      return this._readPredicate(token);
    }
  }
  _readBlankNodeTail(token) {
    if (token.type !== "]")
      return this._readBlankNodePunctuation(token);
    if (this._subject !== null)
      this._emit(this._subject, this._predicate, this._object, this._graph);
    const empty = this._predicate === null;
    this._restoreContext("blank", token);
    if (this._object !== null)
      return this._getContextEndReader();
    else if (this._predicate !== null)
      return this._readObject;
    else
      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
  }
  _readPredicateAfterBlank(token) {
    switch (token.type) {
      case ".":
      case "}":
        this._subject = null;
        return this._readPunctuation(token);
      default:
        return this._readPredicate(token);
    }
  }
  _readListItem(token) {
    let item = null, list = null, next = this._readListItem;
    const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1];
    switch (token.type) {
      case "[":
        this._saveContext("blank", this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());
        next = this._readBlankNodeHead;
        break;
      case "(":
        this._saveContext("list", this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);
        this._subject = null;
        break;
      case ")":
        this._restoreContext("list", token);
        if (stack.length !== 0 && stack[stack.length - 1].type === "list")
          this._emit(this._subject, this._predicate, this._object, this._graph);
        if (this._predicate === null) {
          next = this._readPredicate;
          if (this._subject === this.RDF_NIL)
            return next;
        } else {
          next = this._getContextEndReader();
          if (this._object === this.RDF_NIL)
            return next;
        }
        list = this.RDF_NIL;
        break;
      case "literal":
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          next = this._readListItemDataTypeOrLang;
        } else {
          item = this._literal(token.value, this._namedNode(token.prefix));
          next = this._getContextEndReader();
        }
        break;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode());
        return this._readSubject;
      default:
        if ((item = this._readEntity(token)) === undefined)
          return;
    }
    if (list === null)
      this._subject = list = this._blankNode();
    if (previousList === null) {
      if (parent.predicate === null)
        parent.subject = list;
      else
        parent.object = list;
    } else {
      this._emit(previousList, this.RDF_REST, list, this._graph);
    }
    if (item !== null) {
      if (this._n3Mode && (token.type === "IRI" || token.type === "prefixed")) {
        this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
        this._subject = item, this._predicate = null;
        return this._getPathReader(this._readListItem);
      }
      this._emit(list, this.RDF_FIRST, item, this._graph);
    }
    return next;
  }
  _readDataTypeOrLang(token) {
    return this._completeObjectLiteral(token, false);
  }
  _readListItemDataTypeOrLang(token) {
    return this._completeObjectLiteral(token, true);
  }
  _completeLiteral(token) {
    let literal2 = this._literal(this._literalValue);
    switch (token.type) {
      case "type":
      case "typeIRI":
        const datatype = this._readEntity(token);
        if (datatype === undefined)
          return;
        literal2 = this._literal(this._literalValue, datatype);
        token = null;
        break;
      case "langcode":
        literal2 = this._literal(this._literalValue, token.value);
        token = null;
        break;
    }
    return { token, literal: literal2 };
  }
  _completeSubjectLiteral(token) {
    this._subject = this._completeLiteral(token).literal;
    return this._readPredicateOrNamedGraph;
  }
  _completeObjectLiteral(token, listItem) {
    const completed = this._completeLiteral(token);
    if (!completed)
      return;
    this._object = completed.literal;
    if (listItem)
      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
    if (completed.token === null)
      return this._getContextEndReader();
    else {
      this._readCallback = this._getContextEndReader();
      return this._readCallback(completed.token);
    }
  }
  _readFormulaTail(token) {
    if (token.type !== "}")
      return this._readPunctuation(token);
    if (this._subject !== null)
      this._emit(this._subject, this._predicate, this._object, this._graph);
    this._restoreContext("formula", token);
    return this._object === null ? this._readPredicate : this._getContextEndReader();
  }
  _readPunctuation(token) {
    let next, graph = this._graph;
    const subject = this._subject, inversePredicate = this._inversePredicate;
    switch (token.type) {
      case "}":
        if (this._graph === null)
          return this._error("Unexpected graph closing", token);
        if (this._n3Mode)
          return this._readFormulaTail(token);
        this._graph = null;
      case ".":
        this._subject = null;
        next = this._contextStack.length ? this._readSubject : this._readInTopContext;
        if (inversePredicate)
          this._inversePredicate = false;
        break;
      case ";":
        next = this._readPredicate;
        break;
      case ",":
        next = this._readObject;
        break;
      case "{|":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF* syntax", token);
        const predicate = this._predicate, object = this._object;
        this._subject = this._quad(subject, predicate, object, this.DEFAULTGRAPH);
        next = this._readPredicate;
        break;
      case "|}":
        if (this._subject.termType !== "Quad")
          return this._error("Unexpected asserted triple closing", token);
        this._subject = null;
        next = this._readPunctuation;
        break;
      default:
        if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {
          next = this._readQuadPunctuation;
          break;
        }
        return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
    }
    if (subject !== null) {
      const predicate = this._predicate, object = this._object;
      if (!inversePredicate)
        this._emit(subject, predicate, object, graph);
      else
        this._emit(object, predicate, subject, graph);
    }
    return next;
  }
  _readBlankNodePunctuation(token) {
    let next;
    switch (token.type) {
      case ";":
        next = this._readPredicate;
        break;
      case ",":
        next = this._readObject;
        break;
      default:
        return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
    }
    this._emit(this._subject, this._predicate, this._object, this._graph);
    return next;
  }
  _readQuadPunctuation(token) {
    if (token.type !== ".")
      return this._error("Expected dot to follow quad", token);
    return this._readInTopContext;
  }
  _readPrefix(token) {
    if (token.type !== "prefix")
      return this._error("Expected prefix to follow @prefix", token);
    this._prefix = token.value;
    return this._readPrefixIRI;
  }
  _readPrefixIRI(token) {
    if (token.type !== "IRI")
      return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
    const prefixNode = this._readEntity(token);
    this._prefixes[this._prefix] = prefixNode.value;
    this._prefixCallback(this._prefix, prefixNode);
    return this._readDeclarationPunctuation;
  }
  _readBaseIRI(token) {
    const iri = token.type === "IRI" && this._resolveIRI(token.value);
    if (!iri)
      return this._error("Expected valid IRI to follow base declaration", token);
    this._setBase(iri);
    return this._readDeclarationPunctuation;
  }
  _readNamedGraphLabel(token) {
    switch (token.type) {
      case "IRI":
      case "blank":
      case "prefixed":
        return this._readSubject(token), this._readGraph;
      case "[":
        return this._readNamedGraphBlankLabel;
      default:
        return this._error("Invalid graph label", token);
    }
  }
  _readNamedGraphBlankLabel(token) {
    if (token.type !== "]")
      return this._error("Invalid graph label", token);
    this._subject = this._blankNode();
    return this._readGraph;
  }
  _readDeclarationPunctuation(token) {
    if (this._sparqlStyle) {
      this._sparqlStyle = false;
      return this._readInTopContext(token);
    }
    if (token.type !== ".")
      return this._error("Expected declaration to end with a dot", token);
    return this._readInTopContext;
  }
  _readQuantifierList(token) {
    let entity;
    switch (token.type) {
      case "IRI":
      case "prefixed":
        if ((entity = this._readEntity(token, true)) !== undefined)
          break;
      default:
        return this._error(`Unexpected ${token.type}`, token);
    }
    if (!this._explicitQuantifiers)
      this._quantified[entity.id] = this._quantifier(this._blankNode().value);
    else {
      if (this._subject === null)
        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);
      else
        this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);
      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
    }
    return this._readQuantifierPunctuation;
  }
  _readQuantifierPunctuation(token) {
    if (token.type === ",")
      return this._readQuantifierList;
    else {
      if (this._explicitQuantifiers) {
        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);
        this._subject = null;
      }
      this._readCallback = this._getContextEndReader();
      return this._readCallback(token);
    }
  }
  _getPathReader(afterPath) {
    this._afterPath = afterPath;
    return this._readPath;
  }
  _readPath(token) {
    switch (token.type) {
      case "!":
        return this._readForwardPath;
      case "^":
        return this._readBackwardPath;
      default:
        const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
        if (parent && parent.type === "item") {
          const item = this._subject;
          this._restoreContext("item", token);
          this._emit(this._subject, this.RDF_FIRST, item, this._graph);
        }
        return this._afterPath(token);
    }
  }
  _readForwardPath(token) {
    let subject, predicate;
    const object = this._blankNode();
    if ((predicate = this._readEntity(token)) === undefined)
      return;
    if (this._predicate === null)
      subject = this._subject, this._subject = object;
    else
      subject = this._object, this._object = object;
    this._emit(subject, predicate, object, this._graph);
    return this._readPath;
  }
  _readBackwardPath(token) {
    const subject = this._blankNode();
    let predicate, object;
    if ((predicate = this._readEntity(token)) === undefined)
      return;
    if (this._predicate === null)
      object = this._subject, this._subject = subject;
    else
      object = this._object, this._object = subject;
    this._emit(subject, predicate, object, this._graph);
    return this._readPath;
  }
  _readRDFStarTailOrGraph(token) {
    if (token.type !== ">>") {
      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)
        return this._readRDFStarTail;
      return this._error(`Expected >> to follow "${this._object.id}"`, token);
    }
    return this._readRDFStarTail(token);
  }
  _readRDFStarTail(token) {
    if (token.type !== ">>")
      return this._error(`Expected >> but got ${token.type}`, token);
    const quad2 = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);
    this._restoreContext("<<", token);
    if (this._subject === null) {
      this._subject = quad2;
      return this._readPredicate;
    } else {
      this._object = quad2;
      return this._getContextEndReader();
    }
  }
  _getContextEndReader() {
    const contextStack = this._contextStack;
    if (!contextStack.length)
      return this._readPunctuation;
    switch (contextStack[contextStack.length - 1].type) {
      case "blank":
        return this._readBlankNodeTail;
      case "list":
        return this._readListItem;
      case "formula":
        return this._readFormulaTail;
      case "<<":
        return this._readRDFStarTailOrGraph;
    }
  }
  _emit(subject, predicate, object, graph) {
    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));
  }
  _error(message, token) {
    const err = new Error(`${message} on line ${token.line}.`);
    err.context = {
      token,
      line: token.line,
      previousToken: this._lexer.previousToken
    };
    this._callback(err);
    this._callback = noop;
  }
  _resolveIRI(iri) {
    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
  }
  _resolveRelativeIRI(iri) {
    if (!iri.length)
      return this._base;
    switch (iri[0]) {
      case "#":
        return this._base + iri;
      case "?":
        return this._base.replace(/(?:\?.*)?$/, iri);
      case "/":
        return (iri[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
      default:
        return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
    }
  }
  _removeDotSegments(iri) {
    if (!/(^|\/)\.\.?($|[/#?])/.test(iri))
      return iri;
    const length = iri.length;
    let result = "", i = -1, pathStart = -1, segmentStart = 0, next = "/";
    while (i < length) {
      switch (next) {
        case ":":
          if (pathStart < 0) {
            if (iri[++i] === "/" && iri[++i] === "/")
              while ((pathStart = i + 1) < length && iri[pathStart] !== "/")
                i = pathStart;
          }
          break;
        case "?":
        case "#":
          i = length;
          break;
        case "/":
          if (iri[i + 1] === ".") {
            next = iri[++i + 1];
            switch (next) {
              case "/":
                result += iri.substring(segmentStart, i - 1);
                segmentStart = i + 1;
                break;
              case undefined:
              case "?":
              case "#":
                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
              case ".":
                next = iri[++i + 1];
                if (next === undefined || next === "/" || next === "?" || next === "#") {
                  result += iri.substring(segmentStart, i - 2);
                  if ((segmentStart = result.lastIndexOf("/")) >= pathStart)
                    result = result.substr(0, segmentStart);
                  if (next !== "/")
                    return `${result}/${iri.substr(i + 1)}`;
                  segmentStart = i + 1;
                }
            }
          }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  }
  parse(input, quadCallback, prefixCallback) {
    this._readCallback = this._readInTopContext;
    this._sparqlStyle = false;
    this._prefixes = Object.create(null);
    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;
    this._prefixCallback = prefixCallback || noop;
    this._inversePredicate = false;
    this._quantified = Object.create(null);
    if (!quadCallback) {
      const quads = [];
      let error;
      this._callback = (e, t) => {
        e ? error = e : t && quads.push(t);
      };
      this._lexer.tokenize(input).every((token) => {
        return this._readCallback = this._readCallback(token);
      });
      if (error)
        throw error;
      return quads;
    }
    this._callback = quadCallback;
    this._lexer.tokenize(input, (error, token) => {
      if (error !== null)
        this._callback(error), this._callback = noop;
      else if (this._readCallback)
        this._readCallback = this._readCallback(token);
    });
  }
}
function noop() {
}
function initDataFactory(parser, factory) {
  const namedNode2 = factory.namedNode;
  parser._namedNode = namedNode2;
  parser._blankNode = factory.blankNode;
  parser._literal = factory.literal;
  parser._variable = factory.variable;
  parser._quad = factory.quad;
  parser.DEFAULTGRAPH = factory.defaultGraph();
  parser.RDF_FIRST = namedNode2(IRIs_default.rdf.first);
  parser.RDF_REST = namedNode2(IRIs_default.rdf.rest);
  parser.RDF_NIL = namedNode2(IRIs_default.rdf.nil);
  parser.N3_FORALL = namedNode2(IRIs_default.r.forAll);
  parser.N3_FORSOME = namedNode2(IRIs_default.r.forSome);
  parser.ABBREVIATIONS = {
    a: namedNode2(IRIs_default.rdf.type),
    "=": namedNode2(IRIs_default.owl.sameAs),
    ">": namedNode2(IRIs_default.log.implies)
  };
  parser.QUANTIFIERS_GRAPH = namedNode2("urn:n3:quantifiers");
}
initDataFactory(N3Parser.prototype, N3DataFactory_default);

// node_modules/n3/src/N3Util.js
var exports_N3Util = {};
__export(exports_N3Util, {
  prefixes: () => prefixes,
  prefix: () => prefix,
  isVariable: () => isVariable,
  isNamedNode: () => isNamedNode,
  isLiteral: () => isLiteral,
  isDefaultGraph: () => isDefaultGraph,
  isBlankNode: () => isBlankNode,
  inDefaultGraph: () => inDefaultGraph
});
function isNamedNode(term) {
  return !!term && term.termType === "NamedNode";
}
function isBlankNode(term) {
  return !!term && term.termType === "BlankNode";
}
function isLiteral(term) {
  return !!term && term.termType === "Literal";
}
function isVariable(term) {
  return !!term && term.termType === "Variable";
}
function isDefaultGraph(term) {
  return !!term && term.termType === "DefaultGraph";
}
function inDefaultGraph(quad2) {
  return isDefaultGraph(quad2.graph);
}
function prefix(iri, factory) {
  return prefixes({ "": iri.value || iri }, factory)("");
}
function prefixes(defaultPrefixes, factory) {
  const prefixes2 = Object.create(null);
  for (const prefix2 in defaultPrefixes)
    processPrefix(prefix2, defaultPrefixes[prefix2]);
  factory = factory || N3DataFactory_default;
  function processPrefix(prefix2, iri) {
    if (typeof iri === "string") {
      const cache = Object.create(null);
      prefixes2[prefix2] = (local) => {
        return cache[local] || (cache[local] = factory.namedNode(iri + local));
      };
    } else if (!(prefix2 in prefixes2)) {
      throw new Error(`Unknown prefix: ${prefix2}`);
    }
    return prefixes2[prefix2];
  }
  return processPrefix;
}

// node_modules/n3/src/N3Writer.js
var DEFAULTGRAPH2 = N3DataFactory_default.defaultGraph();
var { rdf: rdf2, xsd: xsd3 } = IRIs_default;
var escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/;
var escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g;
var escapedCharacters = {
  "\\": "\\\\",
  '"': "\\\"",
  "\t": "\\t",
  "\n": "\\n",
  "\r": "\\r",
  "\b": "\\b",
  "\f": "\\f"
};

class SerializedTerm extends Term {
  equals(other) {
    return other === this;
  }
}

class N3Writer {
  constructor(outputStream, options) {
    this._prefixRegex = /$0^/;
    if (outputStream && typeof outputStream.write !== "function")
      options = outputStream, outputStream = null;
    options = options || {};
    this._lists = options.lists;
    if (!outputStream) {
      let output = "";
      this._outputStream = {
        write(chunk, encoding, done) {
          output += chunk;
          done && done();
        },
        end: (done) => {
          done && done(null, output);
        }
      };
      this._endStream = true;
    } else {
      this._outputStream = outputStream;
      this._endStream = options.end === undefined ? true : !!options.end;
    }
    this._subject = null;
    if (!/triple|quad/i.test(options.format)) {
      this._lineMode = false;
      this._graph = DEFAULTGRAPH2;
      this._prefixIRIs = Object.create(null);
      options.prefixes && this.addPrefixes(options.prefixes);
      if (options.baseIRI) {
        this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)}${options.baseIRI.endsWith("/") ? "" : "[#?]"}`);
        this._baseLength = options.baseIRI.length;
      }
    } else {
      this._lineMode = true;
      this._writeQuad = this._writeQuadLine;
    }
  }
  get _inDefaultGraph() {
    return DEFAULTGRAPH2.equals(this._graph);
  }
  _write(string, callback) {
    this._outputStream.write(string, "utf8", callback);
  }
  _writeQuad(subject, predicate, object, graph, done) {
    try {
      if (!graph.equals(this._graph)) {
        this._write((this._subject === null ? "" : this._inDefaultGraph ? `.
` : `
}
`) + (DEFAULTGRAPH2.equals(graph) ? "" : `${this._encodeIriOrBlank(graph)} {
`));
        this._graph = graph;
        this._subject = null;
      }
      if (subject.equals(this._subject)) {
        if (predicate.equals(this._predicate))
          this._write(`, ${this._encodeObject(object)}`, done);
        else
          this._write(`;
    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
      } else
        this._write(`${(this._subject === null ? "" : `.
`) + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
    } catch (error) {
      done && done(error);
    }
  }
  _writeQuadLine(subject, predicate, object, graph, done) {
    delete this._prefixMatch;
    this._write(this.quadToString(subject, predicate, object, graph), done);
  }
  quadToString(subject, predicate, object, graph) {
    return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .
` : ` .
`}`;
  }
  quadsToString(quads) {
    return quads.map((t) => {
      return this.quadToString(t.subject, t.predicate, t.object, t.graph);
    }).join("");
  }
  _encodeSubject(entity) {
    return entity.termType === "Quad" ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
  }
  _encodeIriOrBlank(entity) {
    if (entity.termType !== "NamedNode") {
      if (this._lists && entity.value in this._lists)
        entity = this.list(this._lists[entity.value]);
      return "id" in entity ? entity.id : `_:${entity.value}`;
    }
    let iri = entity.value;
    if (this._baseMatcher && this._baseMatcher.test(iri))
      iri = iri.substr(this._baseLength);
    if (escape.test(iri))
      iri = iri.replace(escapeAll, characterReplacer);
    const prefixMatch = this._prefixRegex.exec(iri);
    return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
  }
  _encodeLiteral(literal2) {
    let value = literal2.value;
    if (escape.test(value))
      value = value.replace(escapeAll, characterReplacer);
    if (literal2.language)
      return `"${value}"@${literal2.language}`;
    if (this._lineMode) {
      if (literal2.datatype.value === xsd3.string)
        return `"${value}"`;
    } else {
      switch (literal2.datatype.value) {
        case xsd3.string:
          return `"${value}"`;
        case xsd3.boolean:
          if (value === "true" || value === "false")
            return value;
          break;
        case xsd3.integer:
          if (/^[+-]?\d+$/.test(value))
            return value;
          break;
        case xsd3.decimal:
          if (/^[+-]?\d*\.\d+$/.test(value))
            return value;
          break;
        case xsd3.double:
          if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
            return value;
          break;
      }
    }
    return `"${value}"^^${this._encodeIriOrBlank(literal2.datatype)}`;
  }
  _encodePredicate(predicate) {
    return predicate.value === rdf2.type ? "a" : this._encodeIriOrBlank(predicate);
  }
  _encodeObject(object) {
    switch (object.termType) {
      case "Quad":
        return this._encodeQuad(object);
      case "Literal":
        return this._encodeLiteral(object);
      default:
        return this._encodeIriOrBlank(object);
    }
  }
  _encodeQuad({ subject, predicate, object, graph }) {
    return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${isDefaultGraph(graph) ? "" : ` ${this._encodeIriOrBlank(graph)}`}>>`;
  }
  _blockedWrite() {
    throw new Error("Cannot write because the writer has been closed.");
  }
  addQuad(subject, predicate, object, graph, done) {
    if (object === undefined)
      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);
    else if (typeof graph === "function")
      this._writeQuad(subject, predicate, object, DEFAULTGRAPH2, graph);
    else
      this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH2, done);
  }
  addQuads(quads) {
    for (let i = 0;i < quads.length; i++)
      this.addQuad(quads[i]);
  }
  addPrefix(prefix2, iri, done) {
    const prefixes2 = {};
    prefixes2[prefix2] = iri;
    this.addPrefixes(prefixes2, done);
  }
  addPrefixes(prefixes2, done) {
    if (!this._prefixIRIs)
      return done && done();
    let hasPrefixes = false;
    for (let prefix2 in prefixes2) {
      let iri = prefixes2[prefix2];
      if (typeof iri !== "string")
        iri = iri.value;
      hasPrefixes = true;
      if (this._subject !== null) {
        this._write(this._inDefaultGraph ? `.
` : `
}
`);
        this._subject = null, this._graph = "";
      }
      this._prefixIRIs[iri] = prefix2 += ":";
      this._write(`@prefix ${prefix2} <${iri}>.
`);
    }
    if (hasPrefixes) {
      let IRIlist = "", prefixList = "";
      for (const prefixIRI in this._prefixIRIs) {
        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
        prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
      }
      IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
      this._prefixRegex = new RegExp(`^(?:${prefixList})[^/]*$|` + `^(${IRIlist})([_a-zA-Z][\\-_a-zA-Z0-9]*)$`);
    }
    this._write(hasPrefixes ? `
` : "", done);
  }
  blank(predicate, object) {
    let children = predicate, child, length;
    if (predicate === undefined)
      children = [];
    else if (predicate.termType)
      children = [{ predicate, object }];
    else if (!("length" in predicate))
      children = [predicate];
    switch (length = children.length) {
      case 0:
        return new SerializedTerm("[]");
      case 1:
        child = children[0];
        if (!(child.object instanceof SerializedTerm))
          return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);
      default:
        let contents = "[";
        for (let i = 0;i < length; i++) {
          child = children[i];
          if (child.predicate.equals(predicate))
            contents += `, ${this._encodeObject(child.object)}`;
          else {
            contents += `${(i ? `;
  ` : `
  `) + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;
            predicate = child.predicate;
          }
        }
        return new SerializedTerm(`${contents}
]`);
    }
  }
  list(elements) {
    const length = elements && elements.length || 0, contents = new Array(length);
    for (let i = 0;i < length; i++)
      contents[i] = this._encodeObject(elements[i]);
    return new SerializedTerm(`(${contents.join(" ")})`);
  }
  end(done) {
    if (this._subject !== null) {
      this._write(this._inDefaultGraph ? `.
` : `
}
`);
      this._subject = null;
    }
    this._write = this._blockedWrite;
    let singleDone = done && ((error, result) => {
      singleDone = null, done(error, result);
    });
    if (this._endStream) {
      try {
        return this._outputStream.end(singleDone);
      } catch (error) {
      }
    }
    singleDone && singleDone();
  }
}
function characterReplacer(character) {
  let result = escapedCharacters[character];
  if (result === undefined) {
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = "\\u0000".substr(0, 6 - result.length) + result;
    } else {
      result = ((character.charCodeAt(0) - 55296) * 1024 + character.charCodeAt(1) + 9216).toString(16);
      result = "\\U00000000".substr(0, 10 - result.length) + result;
    }
  }
  return result;
}
function escapeRegex(regex) {
  return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
}

// node_modules/n3/src/N3Store.js
var import_readable_stream = __toESM(require_browser3(), 1);
class N3Store {
  constructor(quads, options) {
    this._size = 0;
    this._graphs = Object.create(null);
    this._id = 0;
    this._ids = Object.create(null);
    this._entities = Object.create(null);
    this._blankNodeIndex = 0;
    if (!options && quads && !quads[0])
      options = quads, quads = null;
    options = options || {};
    this._factory = options.factory || N3DataFactory_default;
    if (quads)
      this.addQuads(quads);
  }
  _termFromId(id, factory) {
    if (id[0] === ".") {
      const entities = this._entities;
      const terms = id.split(".");
      const q = this._factory.quad(this._termFromId(entities[terms[1]]), this._termFromId(entities[terms[2]]), this._termFromId(entities[terms[3]]), terms[4] && this._termFromId(entities[terms[4]]));
      return q;
    }
    return termFromId(id, factory);
  }
  _termToNumericId(term) {
    if (term.termType === "Quad") {
      const s = this._termToNumericId(term.subject), p = this._termToNumericId(term.predicate), o2 = this._termToNumericId(term.object);
      let g2;
      return s && p && o2 && (isDefaultGraph(term.graph) || (g2 = this._termToNumericId(term.graph))) && this._ids[g2 ? `.${s}.${p}.${o2}.${g2}` : `.${s}.${p}.${o2}`];
    }
    return this._ids[termToId(term)];
  }
  _termToNewNumericId(term) {
    const str = term && term.termType === "Quad" ? `.${this._termToNewNumericId(term.subject)}.${this._termToNewNumericId(term.predicate)}.${this._termToNewNumericId(term.object)}${isDefaultGraph(term.graph) ? "" : `.${this._termToNewNumericId(term.graph)}`}` : termToId(term);
    return this._ids[str] || (this._ids[this._entities[++this._id] = str] = this._id);
  }
  get size() {
    let size = this._size;
    if (size !== null)
      return size;
    size = 0;
    const graphs = this._graphs;
    let subjects, subject;
    for (const graphKey in graphs)
      for (const subjectKey in subjects = graphs[graphKey].subjects)
        for (const predicateKey in subject = subjects[subjectKey])
          size += Object.keys(subject[predicateKey]).length;
    return this._size = size;
  }
  _addToIndex(index0, key0, key1, key2) {
    const index1 = index0[key0] || (index0[key0] = {});
    const index2 = index1[key1] || (index1[key1] = {});
    const existed = key2 in index2;
    if (!existed)
      index2[key2] = null;
    return !existed;
  }
  _removeFromIndex(index0, key0, key1, key2) {
    const index1 = index0[key0], index2 = index1[key1];
    delete index2[key2];
    for (const key in index2)
      return;
    delete index1[key1];
    for (const key in index1)
      return;
    delete index0[key0];
  }
  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
    let tmp, index1, index2;
    const entityKeys = this._entities;
    const graph = this._termFromId(graphId, this._factory);
    const parts = { subject: null, predicate: null, object: null };
    if (key0)
      (tmp = index0, index0 = {})[key0] = tmp[key0];
    for (const value0 in index0) {
      if (index1 = index0[value0]) {
        parts[name0] = this._termFromId(entityKeys[value0], this._factory);
        if (key1)
          (tmp = index1, index1 = {})[key1] = tmp[key1];
        for (const value1 in index1) {
          if (index2 = index1[value1]) {
            parts[name1] = this._termFromId(entityKeys[value1], this._factory);
            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);
            for (let l2 = 0;l2 < values.length; l2++) {
              parts[name2] = this._termFromId(entityKeys[values[l2]], this._factory);
              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);
            }
          }
        }
      }
    }
  }
  _loop(index0, callback) {
    for (const key0 in index0)
      callback(key0);
  }
  _loopByKey0(index0, key0, callback) {
    let index1, key1;
    if (index1 = index0[key0]) {
      for (key1 in index1)
        callback(key1);
    }
  }
  _loopByKey1(index0, key1, callback) {
    let key0, index1;
    for (key0 in index0) {
      index1 = index0[key0];
      if (index1[key1])
        callback(key0);
    }
  }
  _loopBy2Keys(index0, key0, key1, callback) {
    let index1, index2, key2;
    if ((index1 = index0[key0]) && (index2 = index1[key1])) {
      for (key2 in index2)
        callback(key2);
    }
  }
  _countInIndex(index0, key0, key1, key2) {
    let count = 0, tmp, index1, index2;
    if (key0)
      (tmp = index0, index0 = {})[key0] = tmp[key0];
    for (const value0 in index0) {
      if (index1 = index0[value0]) {
        if (key1)
          (tmp = index1, index1 = {})[key1] = tmp[key1];
        for (const value1 in index1) {
          if (index2 = index1[value1]) {
            if (key2)
              key2 in index2 && count++;
            else
              count += Object.keys(index2).length;
          }
        }
      }
    }
    return count;
  }
  _getGraphs(graph) {
    if (!isString(graph))
      return this._graphs;
    const graphs = {};
    graphs[graph] = this._graphs[graph];
    return graphs;
  }
  _uniqueEntities(callback) {
    const uniqueIds = Object.create(null);
    return (id) => {
      if (!(id in uniqueIds)) {
        uniqueIds[id] = true;
        callback(this._termFromId(this._entities[id], this._factory));
      }
    };
  }
  add(quad2) {
    this.addQuad(quad2);
    return this;
  }
  addQuad(subject, predicate, object, graph) {
    if (!predicate)
      graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
    graph = termToId(graph);
    let graphItem = this._graphs[graph];
    if (!graphItem) {
      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
      Object.freeze(graphItem);
    }
    subject = this._termToNewNumericId(subject);
    predicate = this._termToNewNumericId(predicate);
    object = this._termToNewNumericId(object);
    const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);
    this._addToIndex(graphItem.predicates, predicate, object, subject);
    this._addToIndex(graphItem.objects, object, subject, predicate);
    this._size = null;
    return changed;
  }
  addQuads(quads) {
    for (let i = 0;i < quads.length; i++)
      this.addQuad(quads[i]);
  }
  delete(quad2) {
    this.removeQuad(quad2);
    return this;
  }
  has(subjectOrQuad, predicate, object, graph) {
    if (subjectOrQuad && subjectOrQuad.subject)
      ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);
    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;
  }
  import(stream) {
    stream.on("data", (quad2) => {
      this.addQuad(quad2);
    });
    return stream;
  }
  removeQuad(subject, predicate, object, graph) {
    if (!predicate)
      graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
    graph = termToId(graph);
    const graphs = this._graphs;
    let graphItem, subjects, predicates;
    if (!(subject = subject && this._termToNumericId(subject)) || !(predicate = predicate && this._termToNumericId(predicate)) || !(object = object && this._termToNumericId(object)) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates))
      return false;
    this._removeFromIndex(graphItem.subjects, subject, predicate, object);
    this._removeFromIndex(graphItem.predicates, predicate, object, subject);
    this._removeFromIndex(graphItem.objects, object, subject, predicate);
    if (this._size !== null)
      this._size--;
    for (subject in graphItem.subjects)
      return true;
    delete graphs[graph];
    return true;
  }
  removeQuads(quads) {
    for (let i = 0;i < quads.length; i++)
      this.removeQuad(quads[i]);
  }
  remove(stream) {
    stream.on("data", (quad2) => {
      this.removeQuad(quad2);
    });
    return stream;
  }
  removeMatches(subject, predicate, object, graph) {
    const stream = new import_readable_stream.Readable({ objectMode: true });
    stream._read = () => {
      for (const quad2 of this.readQuads(subject, predicate, object, graph))
        stream.push(quad2);
      stream.push(null);
    };
    return this.remove(stream);
  }
  deleteGraph(graph) {
    return this.removeMatches(null, null, null, graph);
  }
  getQuads(subject, predicate, object, graph) {
    return [...this.readQuads(subject, predicate, object, graph)];
  }
  *readQuads(subject, predicate, object, graph) {
    graph = graph && termToId(graph);
    const graphs = this._getGraphs(graph);
    let content, subjectId, predicateId, objectId;
    if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
      return;
    for (const graphId in graphs) {
      if (content = graphs[graphId]) {
        if (subjectId) {
          if (objectId)
            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, "object", "subject", "predicate", graphId);
          else
            yield* this._findInIndex(content.subjects, subjectId, predicateId, null, "subject", "predicate", "object", graphId);
        } else if (predicateId)
          yield* this._findInIndex(content.predicates, predicateId, objectId, null, "predicate", "object", "subject", graphId);
        else if (objectId)
          yield* this._findInIndex(content.objects, objectId, null, null, "object", "subject", "predicate", graphId);
        else
          yield* this._findInIndex(content.subjects, null, null, null, "subject", "predicate", "object", graphId);
      }
    }
  }
  match(subject, predicate, object, graph) {
    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);
  }
  countQuads(subject, predicate, object, graph) {
    graph = graph && termToId(graph);
    const graphs = this._getGraphs(graph);
    let count = 0, content, subjectId, predicateId, objectId;
    if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
      return 0;
    for (const graphId in graphs) {
      if (content = graphs[graphId]) {
        if (subject) {
          if (object)
            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
          else
            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
        } else if (predicate) {
          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
        } else {
          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
        }
      }
    }
    return count;
  }
  forEach(callback, subject, predicate, object, graph) {
    this.some((quad2) => {
      callback(quad2);
      return false;
    }, subject, predicate, object, graph);
  }
  every(callback, subject, predicate, object, graph) {
    let some = false;
    const every = !this.some((quad2) => {
      some = true;
      return !callback(quad2);
    }, subject, predicate, object, graph);
    return some && every;
  }
  some(callback, subject, predicate, object, graph) {
    for (const quad2 of this.readQuads(subject, predicate, object, graph))
      if (callback(quad2))
        return true;
    return false;
  }
  getSubjects(predicate, object, graph) {
    const results = [];
    this.forSubjects((s) => {
      results.push(s);
    }, predicate, object, graph);
    return results;
  }
  forSubjects(callback, predicate, object, graph) {
    graph = graph && termToId(graph);
    const graphs = this._getGraphs(graph);
    let content, predicateId, objectId;
    callback = this._uniqueEntities(callback);
    if (predicate && !(predicateId = this._termToNumericId(predicate)) || object && !(objectId = this._termToNumericId(object)))
      return;
    for (graph in graphs) {
      if (content = graphs[graph]) {
        if (predicateId) {
          if (objectId)
            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
          else
            this._loopByKey1(content.subjects, predicateId, callback);
        } else if (objectId)
          this._loopByKey0(content.objects, objectId, callback);
        else
          this._loop(content.subjects, callback);
      }
    }
  }
  getPredicates(subject, object, graph) {
    const results = [];
    this.forPredicates((p) => {
      results.push(p);
    }, subject, object, graph);
    return results;
  }
  forPredicates(callback, subject, object, graph) {
    graph = graph && termToId(graph);
    const graphs = this._getGraphs(graph);
    let content, subjectId, objectId;
    callback = this._uniqueEntities(callback);
    if (subject && !(subjectId = this._termToNumericId(subject)) || object && !(objectId = this._termToNumericId(object)))
      return;
    for (graph in graphs) {
      if (content = graphs[graph]) {
        if (subjectId) {
          if (objectId)
            this._loopBy2Keys(content.objects, objectId, subjectId, callback);
          else
            this._loopByKey0(content.subjects, subjectId, callback);
        } else if (objectId)
          this._loopByKey1(content.predicates, objectId, callback);
        else
          this._loop(content.predicates, callback);
      }
    }
  }
  getObjects(subject, predicate, graph) {
    const results = [];
    this.forObjects((o2) => {
      results.push(o2);
    }, subject, predicate, graph);
    return results;
  }
  forObjects(callback, subject, predicate, graph) {
    graph = graph && termToId(graph);
    const graphs = this._getGraphs(graph);
    let content, subjectId, predicateId;
    callback = this._uniqueEntities(callback);
    if (subject && !(subjectId = this._termToNumericId(subject)) || predicate && !(predicateId = this._termToNumericId(predicate)))
      return;
    for (graph in graphs) {
      if (content = graphs[graph]) {
        if (subjectId) {
          if (predicateId)
            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
          else
            this._loopByKey1(content.objects, subjectId, callback);
        } else if (predicateId)
          this._loopByKey0(content.predicates, predicateId, callback);
        else
          this._loop(content.objects, callback);
      }
    }
  }
  getGraphs(subject, predicate, object) {
    const results = [];
    this.forGraphs((g2) => {
      results.push(g2);
    }, subject, predicate, object);
    return results;
  }
  forGraphs(callback, subject, predicate, object) {
    for (const graph in this._graphs) {
      this.some((quad2) => {
        callback(quad2.graph);
        return true;
      }, subject, predicate, object, graph);
    }
  }
  createBlankNode(suggestedName) {
    let name, index;
    if (suggestedName) {
      name = suggestedName = `_:${suggestedName}`, index = 1;
      while (this._ids[name])
        name = suggestedName + index++;
    } else {
      do {
        name = `_:b${this._blankNodeIndex++}`;
      } while (this._ids[name]);
    }
    this._ids[name] = ++this._id;
    this._entities[this._id] = name;
    return this._factory.blankNode(name.substr(2));
  }
  extractLists({ remove = false, ignoreErrors = false } = {}) {
    const lists = {};
    const onError = ignoreErrors ? () => true : (node, message) => {
      throw new Error(`${node.value} ${message}`);
    };
    const tails = this.getQuads(null, IRIs_default.rdf.rest, IRIs_default.rdf.nil, null);
    const toRemove = remove ? [...tails] : [];
    tails.forEach((tailQuad) => {
      const items = [];
      let malformed = false;
      let head;
      let headPos;
      const graph = tailQuad.graph;
      let current = tailQuad.subject;
      while (current && !malformed) {
        const objectQuads = this.getQuads(null, null, current, null);
        const subjectQuads = this.getQuads(current, null, null, null);
        let quad2, first = null, rest = null, parent = null;
        for (let i = 0;i < subjectQuads.length && !malformed; i++) {
          quad2 = subjectQuads[i];
          if (!quad2.graph.equals(graph))
            malformed = onError(current, "not confined to single graph");
          else if (head)
            malformed = onError(current, "has non-list arcs out");
          else if (quad2.predicate.value === IRIs_default.rdf.first) {
            if (first)
              malformed = onError(current, "has multiple rdf:first arcs");
            else
              toRemove.push(first = quad2);
          } else if (quad2.predicate.value === IRIs_default.rdf.rest) {
            if (rest)
              malformed = onError(current, "has multiple rdf:rest arcs");
            else
              toRemove.push(rest = quad2);
          } else if (objectQuads.length)
            malformed = onError(current, "can't be subject and object");
          else {
            head = quad2;
            headPos = "subject";
          }
        }
        for (let i = 0;i < objectQuads.length && !malformed; ++i) {
          quad2 = objectQuads[i];
          if (head)
            malformed = onError(current, "can't have coreferences");
          else if (quad2.predicate.value === IRIs_default.rdf.rest) {
            if (parent)
              malformed = onError(current, "has incoming rdf:rest arcs");
            else
              parent = quad2;
          } else {
            head = quad2;
            headPos = "object";
          }
        }
        if (!first)
          malformed = onError(current, "has no list head");
        else
          items.unshift(first.object);
        current = parent && parent.subject;
      }
      if (malformed)
        remove = false;
      else if (head)
        lists[head[headPos].value] = items;
    });
    if (remove)
      this.removeQuads(toRemove);
    return lists;
  }
  *[Symbol.iterator]() {
    yield* this.readQuads();
  }
}
function isString(s) {
  return typeof s === "string" || s instanceof String;
}

class DatasetCoreAndReadableStream extends import_readable_stream.Readable {
  constructor(n3Store, subject, predicate, object, graph) {
    super({ objectMode: true });
    Object.assign(this, { n3Store, subject, predicate, object, graph });
  }
  get filtered() {
    if (!this._filtered) {
      const { n3Store, graph, object, predicate, subject } = this;
      const newStore = this._filtered = new N3Store({ factory: n3Store._factory });
      for (const quad2 of n3Store.readQuads(subject, predicate, object, graph))
        newStore.addQuad(quad2);
    }
    return this._filtered;
  }
  get size() {
    return this.filtered.size;
  }
  _read() {
    for (const quad2 of this)
      this.push(quad2);
    this.push(null);
  }
  add(quad2) {
    return this.filtered.add(quad2);
  }
  delete(quad2) {
    return this.filtered.delete(quad2);
  }
  has(quad2) {
    return this.filtered.has(quad2);
  }
  match(subject, predicate, object, graph) {
    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);
  }
  *[Symbol.iterator]() {
    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
  }
}

// node_modules/n3/src/N3StreamParser.js
var import_readable_stream2 = __toESM(require_browser3(), 1);
class N3StreamParser extends import_readable_stream2.Transform {
  constructor(options) {
    super({ decodeStrings: true });
    this._readableState.objectMode = true;
    const parser = new N3Parser(options);
    let onData, onEnd;
    parser.parse({
      on: (event, callback) => {
        switch (event) {
          case "data":
            onData = callback;
            break;
          case "end":
            onEnd = callback;
            break;
        }
      }
    }, (error, quad2) => {
      error && this.emit("error", error) || quad2 && this.push(quad2);
    }, (prefix2, uri) => {
      this.emit("prefix", prefix2, uri);
    });
    this._transform = (chunk, encoding, done) => {
      onData(chunk);
      done();
    };
    this._flush = (done) => {
      onEnd();
      done();
    };
  }
  import(stream) {
    stream.on("data", (chunk) => {
      this.write(chunk);
    });
    stream.on("end", () => {
      this.end();
    });
    stream.on("error", (error) => {
      this.emit("error", error);
    });
    return this;
  }
}

// node_modules/n3/src/N3StreamWriter.js
var import_readable_stream3 = __toESM(require_browser3(), 1);
class N3StreamWriter extends import_readable_stream3.Transform {
  constructor(options) {
    super({ encoding: "utf8", writableObjectMode: true });
    const writer = this._writer = new N3Writer({
      write: (quad2, encoding, callback) => {
        this.push(quad2);
        callback && callback();
      },
      end: (callback) => {
        this.push(null);
        callback && callback();
      }
    }, options);
    this._transform = (quad2, encoding, done) => {
      writer.addQuad(quad2, done);
    };
    this._flush = (done) => {
      writer.end(done);
    };
  }
  import(stream) {
    stream.on("data", (quad2) => {
      this.write(quad2);
    });
    stream.on("end", () => {
      this.end();
    });
    stream.on("error", (error) => {
      this.emit("error", error);
    });
    stream.on("prefix", (prefix2, iri) => {
      this._writer.addPrefix(prefix2, iri);
    });
    return this;
  }
}

// node_modules/n3/src/index.js
var src_default = {
  Lexer: N3Lexer,
  Parser: N3Parser,
  Writer: N3Writer,
  Store: N3Store,
  StreamParser: N3StreamParser,
  StreamWriter: N3StreamWriter,
  Util: exports_N3Util,
  DataFactory: N3DataFactory_default,
  Term,
  NamedNode,
  Literal,
  BlankNode,
  Variable,
  DefaultGraph,
  Quad,
  Triple: Quad,
  termFromId,
  termToId
};

// node_modules/url-join/lib/url-join.js
function normalize(strArray) {
  var resultArray = [];
  if (strArray.length === 0) {
    return "";
  }
  if (typeof strArray[0] !== "string") {
    throw new TypeError("Url must be a string. Received " + strArray[0]);
  }
  if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
    var first = strArray.shift();
    strArray[0] = first + strArray[0];
  }
  if (strArray[0].match(/^file:\/\/\//)) {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
  } else {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
  }
  for (var i = 0;i < strArray.length; i++) {
    var component = strArray[i];
    if (typeof component !== "string") {
      throw new TypeError("Url must be a string. Received " + component);
    }
    if (component === "") {
      continue;
    }
    if (i > 0) {
      component = component.replace(/^[\/]+/, "");
    }
    if (i < strArray.length - 1) {
      component = component.replace(/[\/]+$/, "");
    } else {
      component = component.replace(/[\/]+$/, "/");
    }
    resultArray.push(component);
  }
  var str = resultArray.join("/");
  str = str.replace(/\/(\?|&|#[^!])/g, "$1");
  var parts = str.split("?");
  str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
  return str;
}
function urlJoin() {
  var input;
  if (typeof arguments[0] === "object") {
    input = arguments[0];
  } else {
    input = [].slice.call(arguments);
  }
  return normalize(input);
}

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};

// node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}
class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types) {
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types) => {
  return message("Key must be ", actual, ...types);
};
function withAlg(alg, actual, ...types) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK = async (key) => {
  if (key instanceof Uint8Array) {
    return {
      kty: "oct",
      k: encode(key)
    };
  }
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
  }
  if (!key.extractable) {
    throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
  }
  const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
  return jwk;
};
var key_to_jwk_default = keyToJWK;

// node_modules/jose/dist/browser/key/export.js
async function exportJWK(key) {
  return key_to_jwk_default(key);
}

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1000);

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}

class ProduceJWT {
  constructor(payload = {}) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
    } else if (typeof input === "string") {
      this._payload = {
        ...this._payload,
        iat: validateInput("setIssuedAt", epoch_default(new Date) + secs_default(input))
      };
    } else {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
    }
    return this;
  }
}

// node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/jose/dist/browser/runtime/generate.js
function getModulusLengthOption(options) {
  const modulusLength = options?.modulusLength ?? 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA": {
      keyUsages = ["sign", "verify"];
      const crv = options?.crv ?? "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv = options?.crv ?? "P-256";
      switch (crv) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages);
}

// node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
// node_modules/@inrupt/solid-client-authn-core/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@inrupt/solid-client-authn-core/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0;i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/@inrupt/solid-client-authn-core/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@inrupt/solid-client-authn-core/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0;i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;
// node_modules/@inrupt/solid-client-authn-core/dist/index.mjs
var PREFERRED_SIGNING_ALG = ["ES256", "RS256"];
var EVENTS = {
  ERROR: "error",
  LOGIN: "login",
  LOGOUT: "logout",
  NEW_REFRESH_TOKEN: "newRefreshToken",
  SESSION_EXPIRED: "sessionExpired",
  SESSION_EXTENDED: "sessionExtended",
  SESSION_RESTORED: "sessionRestore",
  TIMEOUT_SET: "timeoutSet"
};
var REFRESH_BEFORE_EXPIRATION_SECONDS = 5;
var SCOPE_OPENID = "openid";
var SCOPE_OFFLINE = "offline_access";
var SCOPE_WEBID = "webid";
var DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID].join(" ");
class InvalidResponseError extends Error {
  constructor(missingFields) {
    super(`Invalid response from OIDC provider: missing fields ${missingFields}`);
    this.missingFields = missingFields;
  }
}

class OidcProviderError extends Error {
  constructor(message2, error, errorDescription) {
    super(message2);
    this.error = error;
    this.errorDescription = errorDescription;
  }
}
function normalizeHTU(audience) {
  const audienceUrl = new URL(audience);
  return new URL(audienceUrl.pathname, audienceUrl.origin).toString();
}
async function createDpopHeader(audience, method, dpopKey) {
  return new SignJWT({
    htu: normalizeHTU(audience),
    htm: method.toUpperCase(),
    jti: v4_default()
  }).setProtectedHeader({
    alg: PREFERRED_SIGNING_ALG[0],
    jwk: dpopKey.publicKey,
    typ: "dpop+jwt"
  }).setIssuedAt().sign(dpopKey.privateKey, {});
}
async function generateDpopKeyPair() {
  const { privateKey, publicKey } = await generateKeyPair2(PREFERRED_SIGNING_ALG[0]);
  const dpopKeyPair = {
    privateKey,
    publicKey: await exportJWK(publicKey)
  };
  [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;
  return dpopKeyPair;
}
var DEFAULT_EXPIRATION_TIME_SECONDS = 600;
function isExpectedAuthError(statusCode) {
  return [401, 403].includes(statusCode);
}
async function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {
  var _a;
  const headers = new Headers(defaultOptions === null || defaultOptions === undefined ? undefined : defaultOptions.headers);
  headers.set("Authorization", `DPoP ${authToken}`);
  headers.set("DPoP", await createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === undefined ? undefined : defaultOptions.method) !== null && _a !== undefined ? _a : "get", dpopKey));
  return {
    ...defaultOptions,
    headers
  };
}
async function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {
  if (dpopKey !== undefined) {
    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);
  }
  const headers = new Headers(defaultOptions === null || defaultOptions === undefined ? undefined : defaultOptions.headers);
  headers.set("Authorization", `Bearer ${authToken}`);
  return {
    ...defaultOptions,
    headers
  };
}
async function makeAuthenticatedRequest(accessToken, url, defaultRequestInit, dpopKey) {
  return fetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));
}
async function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {
  var _a;
  const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);
  eventEmitter === null || eventEmitter === undefined || eventEmitter.emit(EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== undefined ? _a : DEFAULT_EXPIRATION_TIME_SECONDS);
  if (typeof tokenSet.refreshToken === "string") {
    eventEmitter === null || eventEmitter === undefined || eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);
  }
  return {
    accessToken: tokenSet.accessToken,
    refreshToken: tokenSet.refreshToken,
    expiresIn: tokenSet.expiresIn
  };
}
var computeRefreshDelay = (expiresIn) => {
  if (expiresIn !== undefined) {
    return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0 ? expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS : expiresIn;
  }
  return DEFAULT_EXPIRATION_TIME_SECONDS;
};
async function buildAuthenticatedFetch(accessToken, options) {
  var _a;
  let currentAccessToken = accessToken;
  let latestTimeout;
  const currentRefreshOptions = options === null || options === undefined ? undefined : options.refreshOptions;
  if (currentRefreshOptions !== undefined) {
    const proactivelyRefreshToken = async () => {
      var _a2, _b, _c, _d;
      try {
        const { accessToken: refreshedAccessToken, refreshToken, expiresIn } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);
        currentAccessToken = refreshedAccessToken;
        if (refreshToken !== undefined) {
          currentRefreshOptions.refreshToken = refreshToken;
        }
        clearTimeout(latestTimeout);
        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);
        (_a2 = options.eventEmitter) === null || _a2 === undefined || _a2.emit(EVENTS.TIMEOUT_SET, latestTimeout);
      } catch (e) {
        if (e instanceof OidcProviderError) {
          (_b = options === null || options === undefined ? undefined : options.eventEmitter) === null || _b === undefined || _b.emit(EVENTS.ERROR, e.error, e.errorDescription);
          (_c = options === null || options === undefined ? undefined : options.eventEmitter) === null || _c === undefined || _c.emit(EVENTS.SESSION_EXPIRED);
        }
        if (e instanceof InvalidResponseError && e.missingFields.includes("access_token")) {
          (_d = options === null || options === undefined ? undefined : options.eventEmitter) === null || _d === undefined || _d.emit(EVENTS.SESSION_EXPIRED);
        }
      }
    };
    latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);
    (_a = options.eventEmitter) === null || _a === undefined || _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);
  } else if (options !== undefined && options.eventEmitter !== undefined) {
    const expirationTimeout = setTimeout(() => {
      options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);
    }, computeRefreshDelay(options.expiresIn) * 1000);
    options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);
  }
  return async (url, requestInit) => {
    let response = await makeAuthenticatedRequest(currentAccessToken, url, requestInit, options === null || options === undefined ? undefined : options.dpopKey);
    const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);
    if (response.ok || failedButNotExpectedAuthError) {
      return response;
    }
    const hasBeenRedirected = response.url !== url;
    if (hasBeenRedirected && (options === null || options === undefined ? undefined : options.dpopKey) !== undefined) {
      response = await makeAuthenticatedRequest(currentAccessToken, response.url, requestInit, options.dpopKey);
    }
    return response;
  };
}

// node:util
var pt2 = Object.create;
var dr = Object.defineProperty;
var lt2 = Object.getOwnPropertyDescriptor;
var gt = Object.getOwnPropertyNames;
var dt = Object.getPrototypeOf;
var bt = Object.prototype.hasOwnProperty;
var p = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var At2 = (r, e) => {
  for (var t in e)
    dr(r, t, { get: e[t], enumerable: true });
};
var gr2 = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o2 of gt(e))
      !bt.call(r, o2) && o2 !== t && dr(r, o2, { get: () => e[o2], enumerable: !(n = lt2(e, o2)) || n.enumerable });
  return r;
};
var F = (r, e, t) => (gr2(r, e, "default"), t && gr2(t, e, "default"));
var mt2 = (r, e, t) => (t = r != null ? pt2(dt(r)) : {}, gr2(e || !r || !r.__esModule ? dr(t, "default", { value: r, enumerable: true }) : t, r));
var br = p((po, Vr) => {
  Vr.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var e = {}, t = Symbol("test"), n = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return false;
    var o2 = 42;
    e[t] = o2;
    for (t in e)
      return false;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return false;
    var i = Object.getOwnPropertySymbols(e);
    if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a2 = Object.getOwnPropertyDescriptor(e, t);
      if (a2.value !== o2 || a2.enumerable !== true)
        return false;
    }
    return true;
  };
});
var N2 = p((lo, Jr) => {
  var ht2 = br();
  Jr.exports = function() {
    return ht2() && !!Symbol.toStringTag;
  };
});
var Zr = p((go, Hr) => {
  var Lr = typeof Symbol < "u" && Symbol, St2 = br();
  Hr.exports = function() {
    return typeof Lr != "function" || typeof Symbol != "function" || typeof Lr("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : St2();
  };
});
var Kr = p((bo, Yr) => {
  var vt = "Function.prototype.bind called on incompatible ", Ar2 = Array.prototype.slice, Ot = Object.prototype.toString, jt = "[object Function]";
  Yr.exports = function(e) {
    var t = this;
    if (typeof t != "function" || Ot.call(t) !== jt)
      throw new TypeError(vt + t);
    for (var n = Ar2.call(arguments, 1), o2, i = function() {
      if (this instanceof o2) {
        var g2 = t.apply(this, n.concat(Ar2.call(arguments)));
        return Object(g2) === g2 ? g2 : this;
      } else
        return t.apply(e, n.concat(Ar2.call(arguments)));
    }, a2 = Math.max(0, t.length - n.length), f = [], c = 0;c < a2; c++)
      f.push("$" + c);
    if (o2 = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
      var l2 = function() {
      };
      l2.prototype = t.prototype, o2.prototype = new l2, l2.prototype = null;
    }
    return o2;
  };
});
var V = p((Ao, Qr) => {
  var Pt = Kr();
  Qr.exports = Function.prototype.bind || Pt;
});
var re = p((mo, Xr) => {
  var wt = V();
  Xr.exports = wt.call(Function.call, Object.prototype.hasOwnProperty);
});
var H = p((ho, ie) => {
  var s, x3 = SyntaxError, oe = Function, U = TypeError, mr2 = function(r) {
    try {
      return oe('"use strict"; return (' + r + ").constructor;")();
    } catch {
    }
  }, v3 = Object.getOwnPropertyDescriptor;
  if (v3)
    try {
      v3({}, "");
    } catch {
      v3 = null;
    }
  var hr = function() {
    throw new U;
  }, Et = v3 ? function() {
    try {
      return arguments.callee, hr;
    } catch {
      try {
        return v3(arguments, "callee").get;
      } catch {
        return hr;
      }
    }
  }() : hr, I = Zr()(), m2 = Object.getPrototypeOf || function(r) {
    return r.__proto__;
  }, B = {}, Tt2 = typeof Uint8Array > "u" ? s : m2(Uint8Array), O2 = { "%AggregateError%": typeof AggregateError > "u" ? s : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? s : ArrayBuffer, "%ArrayIteratorPrototype%": I ? m2([][Symbol.iterator]()) : s, "%AsyncFromSyncIteratorPrototype%": s, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? s : Atomics, "%BigInt%": typeof BigInt > "u" ? s : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? s : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? s : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? s : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? s : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? s : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? s : FinalizationRegistry, "%Function%": oe, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? s : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? s : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? s : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I ? m2(m2([][Symbol.iterator]())) : s, "%JSON%": typeof JSON == "object" ? JSON : s, "%Map%": typeof Map > "u" ? s : Map, "%MapIteratorPrototype%": typeof Map > "u" || !I ? s : m2(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? s : Promise, "%Proxy%": typeof Proxy > "u" ? s : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? s : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? s : Set, "%SetIteratorPrototype%": typeof Set > "u" || !I ? s : m2(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? s : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I ? m2(""[Symbol.iterator]()) : s, "%Symbol%": I ? Symbol : s, "%SyntaxError%": x3, "%ThrowTypeError%": Et, "%TypedArray%": Tt2, "%TypeError%": U, "%Uint8Array%": typeof Uint8Array > "u" ? s : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? s : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? s : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? s : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? s : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? s : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? s : WeakSet };
  try {
    null.error;
  } catch (r) {
    ee = m2(m2(r)), O2["%Error.prototype%"] = ee;
  }
  var ee, Ft = function r(e) {
    var t;
    if (e === "%AsyncFunction%")
      t = mr2("async function () {}");
    else if (e === "%GeneratorFunction%")
      t = mr2("function* () {}");
    else if (e === "%AsyncGeneratorFunction%")
      t = mr2("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var n = r("%AsyncGeneratorFunction%");
      n && (t = n.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var o2 = r("%AsyncGenerator%");
      o2 && (t = m2(o2.prototype));
    }
    return O2[e] = t, t;
  }, te = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C2 = V(), J = re(), It = C2.call(Function.call, Array.prototype.concat), Bt2 = C2.call(Function.apply, Array.prototype.splice), ne = C2.call(Function.call, String.prototype.replace), L2 = C2.call(Function.call, String.prototype.slice), Ut2 = C2.call(Function.call, RegExp.prototype.exec), xt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Dt = /\\(\\)?/g, Rt2 = function(e) {
    var t = L2(e, 0, 1), n = L2(e, -1);
    if (t === "%" && n !== "%")
      throw new x3("invalid intrinsic syntax, expected closing `%`");
    if (n === "%" && t !== "%")
      throw new x3("invalid intrinsic syntax, expected opening `%`");
    var o2 = [];
    return ne(e, xt, function(i, a2, f, c) {
      o2[o2.length] = f ? ne(c, Dt, "$1") : a2 || i;
    }), o2;
  }, kt2 = function(e, t) {
    var n = e, o2;
    if (J(te, n) && (o2 = te[n], n = "%" + o2[0] + "%"), J(O2, n)) {
      var i = O2[n];
      if (i === B && (i = Ft(n)), typeof i > "u" && !t)
        throw new U("intrinsic " + e + " exists, but is not available. Please file an issue!");
      return { alias: o2, name: n, value: i };
    }
    throw new x3("intrinsic " + e + " does not exist!");
  };
  ie.exports = function(e, t) {
    if (typeof e != "string" || e.length === 0)
      throw new U("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean")
      throw new U('"allowMissing" argument must be a boolean');
    if (Ut2(/^%?[^%]*%?$/, e) === null)
      throw new x3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n = Rt2(e), o2 = n.length > 0 ? n[0] : "", i = kt2("%" + o2 + "%", t), a2 = i.name, f = i.value, c = false, l2 = i.alias;
    l2 && (o2 = l2[0], Bt2(n, It([0, 1], l2)));
    for (var g2 = 1, S = true;g2 < n.length; g2 += 1) {
      var d2 = n[g2], T = L2(d2, 0, 1), _2 = L2(d2, -1);
      if ((T === '"' || T === "'" || T === "`" || _2 === '"' || _2 === "'" || _2 === "`") && T !== _2)
        throw new x3("property names with quotes must have matching quotes");
      if ((d2 === "constructor" || !S) && (c = true), o2 += "." + d2, a2 = "%" + o2 + "%", J(O2, a2))
        f = O2[a2];
      else if (f != null) {
        if (!(d2 in f)) {
          if (!t)
            throw new U("base intrinsic for " + e + " exists, but the property is not available.");
          return;
        }
        if (v3 && g2 + 1 >= n.length) {
          var z = v3(f, d2);
          S = !!z, S && "get" in z && !("originalValue" in z.get) ? f = z.get : f = f[d2];
        } else
          S = J(f, d2), f = f[d2];
        S && !c && (O2[a2] = f);
      }
    }
    return f;
  };
});
var ce = p((So, Z2) => {
  var Sr = V(), D2 = H(), ue = D2("%Function.prototype.apply%"), ye = D2("%Function.prototype.call%"), se = D2("%Reflect.apply%", true) || Sr.call(ye, ue), ae = D2("%Object.getOwnPropertyDescriptor%", true), j2 = D2("%Object.defineProperty%", true), Mt = D2("%Math.max%");
  if (j2)
    try {
      j2({}, "a", { value: 1 });
    } catch {
      j2 = null;
    }
  Z2.exports = function(e) {
    var t = se(Sr, ye, arguments);
    if (ae && j2) {
      var n = ae(t, "length");
      n.configurable && j2(t, "length", { value: 1 + Mt(0, e.length - (arguments.length - 1)) });
    }
    return t;
  };
  var fe = function() {
    return se(Sr, ue, arguments);
  };
  j2 ? j2(Z2.exports, "apply", { value: fe }) : Z2.exports.apply = fe;
});
var Y = p((vo, ge) => {
  var pe = H(), le = ce(), Nt2 = le(pe("String.prototype.indexOf"));
  ge.exports = function(e, t) {
    var n = pe(e, !!t);
    return typeof n == "function" && Nt2(e, ".prototype.") > -1 ? le(n) : n;
  };
});
var Ae = p((Oo, be) => {
  var Ct = N2()(), $t = Y(), vr = $t("Object.prototype.toString"), K2 = function(e) {
    return Ct && e && typeof e == "object" && Symbol.toStringTag in e ? false : vr(e) === "[object Arguments]";
  }, de = function(e) {
    return K2(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && vr(e) !== "[object Array]" && vr(e.callee) === "[object Function]";
  }, qt = function() {
    return K2(arguments);
  }();
  K2.isLegacyArguments = de;
  be.exports = qt ? K2 : de;
});
var Se = p((jo, he) => {
  var Gt = Object.prototype.toString, Wt = Function.prototype.toString, _t2 = /^\s*(?:function)?\*/, me = N2()(), Or = Object.getPrototypeOf, zt = function() {
    if (!me)
      return false;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, jr;
  he.exports = function(e) {
    if (typeof e != "function")
      return false;
    if (_t2.test(Wt.call(e)))
      return true;
    if (!me) {
      var t = Gt.call(e);
      return t === "[object GeneratorFunction]";
    }
    if (!Or)
      return false;
    if (typeof jr > "u") {
      var n = zt();
      jr = n ? Or(n) : false;
    }
    return Or(e) === jr;
  };
});
var Pe = p((Po, je) => {
  var Oe = Function.prototype.toString, R3 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, wr, Q;
  if (typeof R3 == "function" && typeof Object.defineProperty == "function")
    try {
      wr = Object.defineProperty({}, "length", { get: function() {
        throw Q;
      } }), Q = {}, R3(function() {
        throw 42;
      }, null, wr);
    } catch (r) {
      r !== Q && (R3 = null);
    }
  else
    R3 = null;
  var Vt = /^\s*class\b/, Er2 = function(e) {
    try {
      var t = Oe.call(e);
      return Vt.test(t);
    } catch {
      return false;
    }
  }, Pr = function(e) {
    try {
      return Er2(e) ? false : (Oe.call(e), true);
    } catch {
      return false;
    }
  }, X = Object.prototype.toString, Jt = "[object Object]", Lt2 = "[object Function]", Ht = "[object GeneratorFunction]", Zt = "[object HTMLAllCollection]", Yt = "[object HTML document.all class]", Kt = "[object HTMLCollection]", Qt = typeof Symbol == "function" && !!Symbol.toStringTag, Xt = !(0 in [,]), Tr = function() {
    return false;
  };
  typeof document == "object" && (ve = document.all, X.call(ve) === X.call(document.all) && (Tr = function(e) {
    if ((Xt || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var t = X.call(e);
        return (t === Zt || t === Yt || t === Kt || t === Jt) && e("") == null;
      } catch {
      }
    return false;
  }));
  var ve;
  je.exports = R3 ? function(e) {
    if (Tr(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    try {
      R3(e, null, wr);
    } catch (t) {
      if (t !== Q)
        return false;
    }
    return !Er2(e) && Pr(e);
  } : function(e) {
    if (Tr(e))
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    if (Qt)
      return Pr(e);
    if (Er2(e))
      return false;
    var t = X.call(e);
    return t !== Lt2 && t !== Ht && !/^\[object HTML/.test(t) ? false : Pr(e);
  };
});
var Fr2 = p((wo, Ee) => {
  var rn = Pe(), en = Object.prototype.toString, we = Object.prototype.hasOwnProperty, tn = function(e, t, n) {
    for (var o2 = 0, i = e.length;o2 < i; o2++)
      we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
  }, nn = function(e, t, n) {
    for (var o2 = 0, i = e.length;o2 < i; o2++)
      n == null ? t(e.charAt(o2), o2, e) : t.call(n, e.charAt(o2), o2, e);
  }, on = function(e, t, n) {
    for (var o2 in e)
      we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
  }, an = function(e, t, n) {
    if (!rn(t))
      throw new TypeError("iterator must be a function");
    var o2;
    arguments.length >= 3 && (o2 = n), en.call(e) === "[object Array]" ? tn(e, t, o2) : typeof e == "string" ? nn(e, t, o2) : on(e, t, o2);
  };
  Ee.exports = an;
});
var Br2 = p((Eo, Te) => {
  var Ir2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], fn = typeof globalThis > "u" ? global : globalThis;
  Te.exports = function() {
    for (var e = [], t = 0;t < Ir2.length; t++)
      typeof fn[Ir2[t]] == "function" && (e[e.length] = Ir2[t]);
    return e;
  };
});
var Ur2 = p((To, Fe) => {
  var un = H(), rr2 = un("%Object.getOwnPropertyDescriptor%", true);
  if (rr2)
    try {
      rr2([], "length");
    } catch {
      rr2 = null;
    }
  Fe.exports = rr2;
});
var Rr = p((Fo, De) => {
  var Ie = Fr2(), yn = Br2(), Dr = Y(), sn = Dr("Object.prototype.toString"), Be = N2()(), er = Ur2(), cn = typeof globalThis > "u" ? global : globalThis, Ue = yn(), pn = Dr("Array.prototype.indexOf", true) || function(e, t) {
    for (var n = 0;n < e.length; n += 1)
      if (e[n] === t)
        return n;
    return -1;
  }, ln = Dr("String.prototype.slice"), xe = {}, xr = Object.getPrototypeOf;
  Be && er && xr && Ie(Ue, function(r) {
    var e = new cn[r];
    if (Symbol.toStringTag in e) {
      var t = xr(e), n = er(t, Symbol.toStringTag);
      if (!n) {
        var o2 = xr(t);
        n = er(o2, Symbol.toStringTag);
      }
      xe[r] = n.get;
    }
  });
  var gn = function(e) {
    var t = false;
    return Ie(xe, function(n, o2) {
      if (!t)
        try {
          t = n.call(e) === o2;
        } catch {
        }
    }), t;
  };
  De.exports = function(e) {
    if (!e || typeof e != "object")
      return false;
    if (!Be || !(Symbol.toStringTag in e)) {
      var t = ln(sn(e), 8, -1);
      return pn(Ue, t) > -1;
    }
    return er ? gn(e) : false;
  };
});
var qe = p((Io, $e) => {
  var ke = Fr2(), dn = Br2(), Me = Y(), kr = Ur2(), bn = Me("Object.prototype.toString"), Ne = N2()(), Re = typeof globalThis > "u" ? global : globalThis, An = dn(), mn = Me("String.prototype.slice"), Ce = {}, Mr = Object.getPrototypeOf;
  Ne && kr && Mr && ke(An, function(r) {
    if (typeof Re[r] == "function") {
      var e = new Re[r];
      if (Symbol.toStringTag in e) {
        var t = Mr(e), n = kr(t, Symbol.toStringTag);
        if (!n) {
          var o2 = Mr(t);
          n = kr(o2, Symbol.toStringTag);
        }
        Ce[r] = n.get;
      }
    }
  });
  var hn = function(e) {
    var t = false;
    return ke(Ce, function(n, o2) {
      if (!t)
        try {
          var i = n.call(e);
          i === o2 && (t = i);
        } catch {
        }
    }), t;
  }, Sn = Rr();
  $e.exports = function(e) {
    return Sn(e) ? !Ne || !(Symbol.toStringTag in e) ? mn(bn(e), 8, -1) : hn(e) : false;
  };
});
var rt2 = p((u) => {
  var vn = Ae(), On = Se(), A2 = qe(), Ge = Rr();
  function k(r) {
    return r.call.bind(r);
  }
  var We = typeof BigInt < "u", _e = typeof Symbol < "u", b3 = k(Object.prototype.toString), jn = k(Number.prototype.valueOf), Pn = k(String.prototype.valueOf), wn = k(Boolean.prototype.valueOf);
  We && (ze = k(BigInt.prototype.valueOf));
  var ze;
  _e && (Ve = k(Symbol.prototype.valueOf));
  var Ve;
  function q(r, e) {
    if (typeof r != "object")
      return false;
    try {
      return e(r), true;
    } catch {
      return false;
    }
  }
  u.isArgumentsObject = vn;
  u.isGeneratorFunction = On;
  u.isTypedArray = Ge;
  function En(r) {
    return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
  }
  u.isPromise = En;
  function Tn(r) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ge(r) || Le(r);
  }
  u.isArrayBufferView = Tn;
  function Fn(r) {
    return A2(r) === "Uint8Array";
  }
  u.isUint8Array = Fn;
  function In(r) {
    return A2(r) === "Uint8ClampedArray";
  }
  u.isUint8ClampedArray = In;
  function Bn(r) {
    return A2(r) === "Uint16Array";
  }
  u.isUint16Array = Bn;
  function Un(r) {
    return A2(r) === "Uint32Array";
  }
  u.isUint32Array = Un;
  function xn(r) {
    return A2(r) === "Int8Array";
  }
  u.isInt8Array = xn;
  function Dn(r) {
    return A2(r) === "Int16Array";
  }
  u.isInt16Array = Dn;
  function Rn(r) {
    return A2(r) === "Int32Array";
  }
  u.isInt32Array = Rn;
  function kn(r) {
    return A2(r) === "Float32Array";
  }
  u.isFloat32Array = kn;
  function Mn(r) {
    return A2(r) === "Float64Array";
  }
  u.isFloat64Array = Mn;
  function Nn(r) {
    return A2(r) === "BigInt64Array";
  }
  u.isBigInt64Array = Nn;
  function Cn(r) {
    return A2(r) === "BigUint64Array";
  }
  u.isBigUint64Array = Cn;
  function tr(r) {
    return b3(r) === "[object Map]";
  }
  tr.working = typeof Map < "u" && tr(new Map);
  function $n(r) {
    return typeof Map > "u" ? false : tr.working ? tr(r) : r instanceof Map;
  }
  u.isMap = $n;
  function nr(r) {
    return b3(r) === "[object Set]";
  }
  nr.working = typeof Set < "u" && nr(new Set);
  function qn(r) {
    return typeof Set > "u" ? false : nr.working ? nr(r) : r instanceof Set;
  }
  u.isSet = qn;
  function or(r) {
    return b3(r) === "[object WeakMap]";
  }
  or.working = typeof WeakMap < "u" && or(new WeakMap);
  function Gn(r) {
    return typeof WeakMap > "u" ? false : or.working ? or(r) : r instanceof WeakMap;
  }
  u.isWeakMap = Gn;
  function Cr(r) {
    return b3(r) === "[object WeakSet]";
  }
  Cr.working = typeof WeakSet < "u" && Cr(new WeakSet);
  function Wn(r) {
    return Cr(r);
  }
  u.isWeakSet = Wn;
  function ir(r) {
    return b3(r) === "[object ArrayBuffer]";
  }
  ir.working = typeof ArrayBuffer < "u" && ir(new ArrayBuffer);
  function Je(r) {
    return typeof ArrayBuffer > "u" ? false : ir.working ? ir(r) : r instanceof ArrayBuffer;
  }
  u.isArrayBuffer = Je;
  function ar(r) {
    return b3(r) === "[object DataView]";
  }
  ar.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ar(new DataView(new ArrayBuffer(1), 0, 1));
  function Le(r) {
    return typeof DataView > "u" ? false : ar.working ? ar(r) : r instanceof DataView;
  }
  u.isDataView = Le;
  var Nr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
  function $2(r) {
    return b3(r) === "[object SharedArrayBuffer]";
  }
  function He(r) {
    return typeof Nr > "u" ? false : (typeof $2.working > "u" && ($2.working = $2(new Nr)), $2.working ? $2(r) : r instanceof Nr);
  }
  u.isSharedArrayBuffer = He;
  function _n(r) {
    return b3(r) === "[object AsyncFunction]";
  }
  u.isAsyncFunction = _n;
  function zn(r) {
    return b3(r) === "[object Map Iterator]";
  }
  u.isMapIterator = zn;
  function Vn(r) {
    return b3(r) === "[object Set Iterator]";
  }
  u.isSetIterator = Vn;
  function Jn(r) {
    return b3(r) === "[object Generator]";
  }
  u.isGeneratorObject = Jn;
  function Ln(r) {
    return b3(r) === "[object WebAssembly.Module]";
  }
  u.isWebAssemblyCompiledModule = Ln;
  function Ze(r) {
    return q(r, jn);
  }
  u.isNumberObject = Ze;
  function Ye(r) {
    return q(r, Pn);
  }
  u.isStringObject = Ye;
  function Ke(r) {
    return q(r, wn);
  }
  u.isBooleanObject = Ke;
  function Qe(r) {
    return We && q(r, ze);
  }
  u.isBigIntObject = Qe;
  function Xe(r) {
    return _e && q(r, Ve);
  }
  u.isSymbolObject = Xe;
  function Hn(r) {
    return Ze(r) || Ye(r) || Ke(r) || Qe(r) || Xe(r);
  }
  u.isBoxedPrimitive = Hn;
  function Zn(r) {
    return typeof Uint8Array < "u" && (Je(r) || He(r));
  }
  u.isAnyArrayBuffer = Zn;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
    Object.defineProperty(u, r, { enumerable: false, value: function() {
      throw new Error(r + " is not supported in userland");
    } });
  });
});
var tt2 = p((Uo, et) => {
  et.exports = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  };
});
var nt2 = p((xo, $r) => {
  typeof Object.create == "function" ? $r.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : $r.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var n = function() {
      };
      n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
    }
  };
});
var yt = p((y2) => {
  var ot2 = Object.getOwnPropertyDescriptors || function(e) {
    for (var t = Object.keys(e), n = {}, o2 = 0;o2 < t.length; o2++)
      n[t[o2]] = Object.getOwnPropertyDescriptor(e, t[o2]);
    return n;
  }, Yn = /%[sdj%]/g;
  y2.format = function(r) {
    if (!lr(r)) {
      for (var e = [], t = 0;t < arguments.length; t++)
        e.push(h2(arguments[t]));
      return e.join(" ");
    }
    for (var t = 1, n = arguments, o2 = n.length, i = String(r).replace(Yn, function(f) {
      if (f === "%%")
        return "%";
      if (t >= o2)
        return f;
      switch (f) {
        case "%s":
          return String(n[t++]);
        case "%d":
          return Number(n[t++]);
        case "%j":
          try {
            return JSON.stringify(n[t++]);
          } catch {
            return "[Circular]";
          }
        default:
          return f;
      }
    }), a2 = n[t];t < o2; a2 = n[++t])
      pr(a2) || !M2(a2) ? i += " " + a2 : i += " " + h2(a2);
    return i;
  };
  y2.deprecate = function(r, e) {
    if (typeof process < "u" && process.noDeprecation === true)
      return r;
    if (typeof process > "u")
      return function() {
        return y2.deprecate(r, e).apply(this, arguments);
      };
    var t = false;
    function n() {
      if (!t) {
        if (process.throwDeprecation)
          throw new Error(e);
        process.traceDeprecation ? console.trace(e) : console.error(e), t = true;
      }
      return r.apply(this, arguments);
    }
    return n;
  };
  var fr = {}, it = /^$/;
  process.env.NODE_DEBUG && (ur = process.env.NODE_DEBUG, ur = ur.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), it = new RegExp("^" + ur + "$", "i"));
  var ur;
  y2.debuglog = function(r) {
    if (r = r.toUpperCase(), !fr[r])
      if (it.test(r)) {
        var e = process.pid;
        fr[r] = function() {
          var t = y2.format.apply(y2, arguments);
          console.error("%s %d: %s", r, e, t);
        };
      } else
        fr[r] = function() {
        };
    return fr[r];
  };
  function h2(r, e) {
    var t = { seen: [], stylize: Qn };
    return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), _r(e) ? t.showHidden = e : e && y2._extend(t, e), w3(t.showHidden) && (t.showHidden = false), w3(t.depth) && (t.depth = 2), w3(t.colors) && (t.colors = false), w3(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Kn), sr(t, r, t.depth);
  }
  y2.inspect = h2;
  h2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
  h2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function Kn(r, e) {
    var t = h2.styles[e];
    return t ? "\x1B[" + h2.colors[t][0] + "m" + r + "\x1B[" + h2.colors[t][1] + "m" : r;
  }
  function Qn(r, e) {
    return r;
  }
  function Xn(r) {
    var e = {};
    return r.forEach(function(t, n) {
      e[t] = true;
    }), e;
  }
  function sr(r, e, t) {
    if (r.customInspect && e && yr(e.inspect) && e.inspect !== y2.inspect && !(e.constructor && e.constructor.prototype === e)) {
      var n = e.inspect(t, r);
      return lr(n) || (n = sr(r, n, t)), n;
    }
    var o2 = ro(r, e);
    if (o2)
      return o2;
    var i = Object.keys(e), a2 = Xn(i);
    if (r.showHidden && (i = Object.getOwnPropertyNames(e)), W(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
      return qr(e);
    if (i.length === 0) {
      if (yr(e)) {
        var f = e.name ? ": " + e.name : "";
        return r.stylize("[Function" + f + "]", "special");
      }
      if (G(e))
        return r.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (cr(e))
        return r.stylize(Date.prototype.toString.call(e), "date");
      if (W(e))
        return qr(e);
    }
    var c = "", l2 = false, g2 = ["{", "}"];
    if (at2(e) && (l2 = true, g2 = ["[", "]"]), yr(e)) {
      var S = e.name ? ": " + e.name : "";
      c = " [Function" + S + "]";
    }
    if (G(e) && (c = " " + RegExp.prototype.toString.call(e)), cr(e) && (c = " " + Date.prototype.toUTCString.call(e)), W(e) && (c = " " + qr(e)), i.length === 0 && (!l2 || e.length == 0))
      return g2[0] + c + g2[1];
    if (t < 0)
      return G(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
    r.seen.push(e);
    var d2;
    return l2 ? d2 = eo(r, e, t, a2, i) : d2 = i.map(function(T) {
      return Wr(r, e, t, a2, T, l2);
    }), r.seen.pop(), to(d2, c, g2);
  }
  function ro(r, e) {
    if (w3(e))
      return r.stylize("undefined", "undefined");
    if (lr(e)) {
      var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return r.stylize(t, "string");
    }
    if (ft2(e))
      return r.stylize("" + e, "number");
    if (_r(e))
      return r.stylize("" + e, "boolean");
    if (pr(e))
      return r.stylize("null", "null");
  }
  function qr(r) {
    return "[" + Error.prototype.toString.call(r) + "]";
  }
  function eo(r, e, t, n, o2) {
    for (var i = [], a2 = 0, f = e.length;a2 < f; ++a2)
      ut2(e, String(a2)) ? i.push(Wr(r, e, t, n, String(a2), true)) : i.push("");
    return o2.forEach(function(c) {
      c.match(/^\d+$/) || i.push(Wr(r, e, t, n, c, true));
    }), i;
  }
  function Wr(r, e, t, n, o2, i) {
    var a2, f, c;
    if (c = Object.getOwnPropertyDescriptor(e, o2) || { value: e[o2] }, c.get ? c.set ? f = r.stylize("[Getter/Setter]", "special") : f = r.stylize("[Getter]", "special") : c.set && (f = r.stylize("[Setter]", "special")), ut2(n, o2) || (a2 = "[" + o2 + "]"), f || (r.seen.indexOf(c.value) < 0 ? (pr(t) ? f = sr(r, c.value, null) : f = sr(r, c.value, t - 1), f.indexOf(`
`) > -1 && (i ? f = f.split(`
`).map(function(l2) {
      return "  " + l2;
    }).join(`
`).slice(2) : f = `
` + f.split(`
`).map(function(l2) {
      return "   " + l2;
    }).join(`
`))) : f = r.stylize("[Circular]", "special")), w3(a2)) {
      if (i && o2.match(/^\d+$/))
        return f;
      a2 = JSON.stringify("" + o2), a2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a2 = a2.slice(1, -1), a2 = r.stylize(a2, "name")) : (a2 = a2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a2 = r.stylize(a2, "string"));
    }
    return a2 + ": " + f;
  }
  function to(r, e, t) {
    var n = 0, o2 = r.reduce(function(i, a2) {
      return n++, a2.indexOf(`
`) >= 0 && n++, i + a2.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return o2 > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
  }
  y2.types = rt2();
  function at2(r) {
    return Array.isArray(r);
  }
  y2.isArray = at2;
  function _r(r) {
    return typeof r == "boolean";
  }
  y2.isBoolean = _r;
  function pr(r) {
    return r === null;
  }
  y2.isNull = pr;
  function no(r) {
    return r == null;
  }
  y2.isNullOrUndefined = no;
  function ft2(r) {
    return typeof r == "number";
  }
  y2.isNumber = ft2;
  function lr(r) {
    return typeof r == "string";
  }
  y2.isString = lr;
  function oo(r) {
    return typeof r == "symbol";
  }
  y2.isSymbol = oo;
  function w3(r) {
    return r === undefined;
  }
  y2.isUndefined = w3;
  function G(r) {
    return M2(r) && zr(r) === "[object RegExp]";
  }
  y2.isRegExp = G;
  y2.types.isRegExp = G;
  function M2(r) {
    return typeof r == "object" && r !== null;
  }
  y2.isObject = M2;
  function cr(r) {
    return M2(r) && zr(r) === "[object Date]";
  }
  y2.isDate = cr;
  y2.types.isDate = cr;
  function W(r) {
    return M2(r) && (zr(r) === "[object Error]" || r instanceof Error);
  }
  y2.isError = W;
  y2.types.isNativeError = W;
  function yr(r) {
    return typeof r == "function";
  }
  y2.isFunction = yr;
  function io(r) {
    return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
  }
  y2.isPrimitive = io;
  y2.isBuffer = tt2();
  function zr(r) {
    return Object.prototype.toString.call(r);
  }
  function Gr(r) {
    return r < 10 ? "0" + r.toString(10) : r.toString(10);
  }
  var ao = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function fo() {
    var r = new Date, e = [Gr(r.getHours()), Gr(r.getMinutes()), Gr(r.getSeconds())].join(":");
    return [r.getDate(), ao[r.getMonth()], e].join(" ");
  }
  y2.log = function() {
    console.log("%s - %s", fo(), y2.format.apply(y2, arguments));
  };
  y2.inherits = nt2();
  y2._extend = function(r, e) {
    if (!e || !M2(e))
      return r;
    for (var t = Object.keys(e), n = t.length;n--; )
      r[t[n]] = e[t[n]];
    return r;
  };
  function ut2(r, e) {
    return Object.prototype.hasOwnProperty.call(r, e);
  }
  var P3 = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
  y2.promisify = function(e) {
    if (typeof e != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (P3 && e[P3]) {
      var t = e[P3];
      if (typeof t != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t, P3, { value: t, enumerable: false, writable: false, configurable: true }), t;
    }
    function t() {
      for (var n, o2, i = new Promise(function(c, l2) {
        n = c, o2 = l2;
      }), a2 = [], f = 0;f < arguments.length; f++)
        a2.push(arguments[f]);
      a2.push(function(c, l2) {
        c ? o2(c) : n(l2);
      });
      try {
        e.apply(this, a2);
      } catch (c) {
        o2(c);
      }
      return i;
    }
    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P3 && Object.defineProperty(t, P3, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, ot2(e));
  };
  y2.promisify.custom = P3;
  function uo(r, e) {
    if (!r) {
      var t = new Error("Promise was rejected with a falsy value");
      t.reason = r, r = t;
    }
    return e(r);
  }
  function yo(r) {
    if (typeof r != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var t = [], n = 0;n < arguments.length; n++)
        t.push(arguments[n]);
      var o2 = t.pop();
      if (typeof o2 != "function")
        throw new TypeError("The last argument must be of type Function");
      var i = this, a2 = function() {
        return o2.apply(i, arguments);
      };
      r.apply(this, t).then(function(f) {
        process.nextTick(a2.bind(null, null, f));
      }, function(f) {
        process.nextTick(uo.bind(null, f, a2));
      });
    }
    return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, ot2(r)), e;
  }
  y2.callbackify = yo;
});
var E2 = {};
At2(E2, { TextDecoder: () => ct2, TextEncoder: () => st2, default: () => so });
F(E2, mt2(yt()));
var st2 = globalThis.TextEncoder;
var ct2 = globalThis.TextDecoder;
var so = { TextEncoder: st2, TextDecoder: ct2 };

// src/utils/index.ts
async function convertNQuadsToJSONLD(nquads) {
  return new Promise(async (resolve, reject) => {
    try {
      const jsonldData = await import_jsonld.default.fromRDF(nquads, { format: "application/n-quads" });
      resolve(jsonldData);
    } catch (error) {
      reject(error);
    }
  });
}
async function ttl2jld(ttl, baseIri) {
  const store = await ttl2store(ttl, baseIri);
  const jld = await import_jsonld.default.fromRDF(store);
  return jld;
}
async function ttl2store(ttl, baseIRI) {
  const quads = new src_default.Parser({
    format: "text/turtle",
    baseIRI
  }).parse(ttl);
  return new src_default.Store(quads);
}
async function getAuthorisation(email, password, serverUrl) {
  const indexResponse = await fetch(urlJoin(serverUrl, ".account/"));
  const { controls } = await indexResponse.json();
  const response = await fetch(controls.password.login, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ email, password })
  });
  const { authorization } = await response.json();
  return authorization;
}
async function generateToken(webId, serverUrl, authorization) {
  const indexResponse = await fetch(urlJoin(serverUrl + ".account/"), {
    headers: { authorization: `CSS-Account-Token ${authorization}` }
  });
  const { controls } = await indexResponse.json();
  const response = await fetch(controls.account.clientCredentials, {
    method: "POST",
    headers: { authorization: `CSS-Account-Token ${authorization}`, "content-type": "application/json" },
    body: JSON.stringify({ name: "my-token", webId })
  });
  const token = await response.json();
  return token;
}
async function requestAccessToken(token, serverUrl) {
  const { id, secret } = token;
  const dpopKey = await generateDpopKeyPair();
  const authString = `${encodeURIComponent(id)}:${encodeURIComponent(secret)}`;
  const tokenUrl = urlJoin(serverUrl, ".oidc/token");
  const response = await fetch(tokenUrl, {
    method: "POST",
    headers: {
      authorization: `Basic ${Buffer.from(authString).toString("base64")}`,
      "content-type": "application/x-www-form-urlencoded",
      dpop: await createDpopHeader(tokenUrl, "POST", dpopKey)
    },
    body: "grant_type=client_credentials&scope=webid"
  });
  const { access_token, expires_in } = await response.json();
  const today = new Date;
  today.setSeconds(today.getSeconds() + expires_in);
  return {
    accessToken: access_token,
    expiresOn: today,
    dpopKey
  };
}
async function getAuthenticatedFetch(email, password, serverUrl, webId) {
  console.log("Generating access token");
  const authorisation = await getAuthorisation(email, password, serverUrl);
  const token = await generateToken(webId, serverUrl, authorisation);
  const { accessToken, dpopKey } = await requestAccessToken(token, serverUrl);
  const authFetch = await buildAuthenticatedFetch(accessToken, { dpopKey });
  console.log("authFetch ready");
  return authFetch;
}
async function parseToJsonLD(data, contentType) {
  let parsedData = undefined;
  switch (contentType) {
    case "application/n-quads":
      parsedData = await convertNQuadsToJSONLD(data);
      break;
    case "text/turtle":
      parsedData = await ttl2jld(data);
      break;
    case "application/json":
    case "application/ld+json":
      parsedData = JSON.parse(data);
      break;
    default:
      throw new Error(`Content-type: ${contentType} not yet supported!`);
  }
  return parsedData;
}
function getCurrentDateTime() {
  const now = new Date;
  const year2 = now.getUTCFullYear();
  const month = String(now.getUTCMonth() + 1).padStart(2, "0");
  const day2 = String(now.getUTCDate()).padStart(2, "0");
  const hours = String(now.getUTCHours()).padStart(2, "0");
  const minutes = String(now.getUTCMinutes()).padStart(2, "0");
  const seconds = String(now.getUTCSeconds()).padStart(2, "0");
  return `${year2}-${month}-${day2}T${hours}:${minutes}:${seconds}Z`;
}
function createDocumentLoader(jdl) {
  const dl = jdl.build();
  return async (url) => {
    let resolvedDocument = undefined;
    try {
      console.log(`\uD83D\uDD17	${url}`);
      resolvedDocument = await dl(url);
    } catch (error) {
      let document2 = await (await fetch(url, { headers: { accept: "application/json" } })).json();
      resolvedDocument = {
        contextUrl: null,
        document: document2,
        documentUrl: url
      };
    }
    if (!resolvedDocument)
      throw new Error(`COULD NOT RESOLVE DOCUMENT FOR ${url}`);
    return resolvedDocument;
  };
}

// node_modules/credentials-context/dist/context.esm.js
function unwrapExports(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var context = createCommonjsModule(function(module, exports) {
  /*! For license information please see context.js.LICENSE.txt */
  (() => {
    var e = { 717: (e2) => {
      e2.exports = { CONTEXT_FILENAME: "credentials-v1.jsonld", CONTEXT_URL: "https://www.w3.org/2018/credentials/v1", CREDENTIALS_CONTEXT_V1_URL: "https://www.w3.org/2018/credentials/v1" };
    }, 869: (e2) => {
      e2.exports = { "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", VerifiableCredential: { "@id": "https://www.w3.org/2018/credentials#VerifiableCredential", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", credentialSchema: { "@id": "cred:credentialSchema", "@type": "@id", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", JsonSchemaValidator2018: "cred:JsonSchemaValidator2018" } }, credentialStatus: { "@id": "cred:credentialStatus", "@type": "@id" }, credentialSubject: { "@id": "cred:credentialSubject", "@type": "@id" }, evidence: { "@id": "cred:evidence", "@type": "@id" }, expirationDate: { "@id": "cred:expirationDate", "@type": "xsd:dateTime" }, holder: { "@id": "cred:holder", "@type": "@id" }, issued: { "@id": "cred:issued", "@type": "xsd:dateTime" }, issuer: { "@id": "cred:issuer", "@type": "@id" }, issuanceDate: { "@id": "cred:issuanceDate", "@type": "xsd:dateTime" }, proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" }, refreshService: { "@id": "cred:refreshService", "@type": "@id", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", ManualRefreshService2018: "cred:ManualRefreshService2018" } }, termsOfUse: { "@id": "cred:termsOfUse", "@type": "@id" }, validFrom: { "@id": "cred:validFrom", "@type": "xsd:dateTime" }, validUntil: { "@id": "cred:validUntil", "@type": "xsd:dateTime" } } }, VerifiablePresentation: { "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", cred: "https://www.w3.org/2018/credentials#", sec: "https://w3id.org/security#", holder: { "@id": "cred:holder", "@type": "@id" }, proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" }, verifiableCredential: { "@id": "cred:verifiableCredential", "@type": "@id", "@container": "@graph" } } }, EcdsaSecp256k1Signature2019: { "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, EcdsaSecp256r1Signature2019: { "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, Ed25519Signature2018: { "@id": "https://w3id.org/security#Ed25519Signature2018", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", xsd: "http://www.w3.org/2001/XMLSchema#", challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, RsaSignature2018: { "@id": "https://w3id.org/security#RsaSignature2018", "@context": { "@version": 1.1, "@protected": true, challenge: "sec:challenge", created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" }, domain: "sec:domain", expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" }, jws: "sec:jws", nonce: "sec:nonce", proofPurpose: { "@id": "sec:proofPurpose", "@type": "@vocab", "@context": { "@version": 1.1, "@protected": true, id: "@id", type: "@type", sec: "https://w3id.org/security#", assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" }, authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" } } }, proofValue: "sec:proofValue", verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" } } }, proof: { "@id": "https://w3id.org/security#proof", "@type": "@id", "@container": "@graph" } } };
    }, 858: (e2, t2, i2) => {
      const { CONTEXT_URL: d3 } = i2(717), r2 = i2(869);
      e2.exports = { documentLoader(e3) {
        if (e3 !== d3)
          throw new Error(`Loading document "${e3}" is not allowed.`);
        return { contextUrl: null, document: r2, documentUrl: e3 };
      } };
    }, 243: (e2, t2, i2) => {
      const d3 = i2(869), r2 = i2(717), { documentLoader: o2 } = i2(858), { CONTEXT_URL: c } = r2, s = new Map;
      s.set(r2.CONTEXT_URL, d3), e2.exports = { constants: r2, contexts: s, documentLoader: o2, CONTEXT_URL: c, CREDENTIALS_CONTEXT_V1_URL: c, CONTEXT_URL_V1: c, CONTEXT: d3 };
    } }, t = {}, i = function i(d3) {
      var r2 = t[d3];
      if (r2 !== undefined)
        return r2.exports;
      var o2 = t[d3] = { exports: {} };
      return e[d3](o2, o2.exports, i), o2.exports;
    }(243), d2 = exports;
    for (var r in i)
      d2[r] = i[r];
    i.__esModule && Object.defineProperty(d2, "__esModule", { value: true });
  })();
});
var context$1 = unwrapExports(context);
var context_1 = context.contexts;
var context_2 = context.constants;
var context_3 = context.CONTEXT;
var context_4 = context.CONTEXT_URL;
var context_5 = context.CONTEXT_URL_V1;
var context_6 = context.CREDENTIALS_CONTEXT_V1_URL;

// src/controller/index.ts
var import_jsonld_signatures2 = __toESM(require_jsonld_signatures(), 1);

// node_modules/@digitalbazaar/eddsa-2022-cryptosuite/lib/canonize.js
var import_jsonld2 = __toESM(require_jsonld(), 1);
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
function canonize(input, options) {
  return import_jsonld2.default.canonize(input, {
    algorithm: "URDNA2015",
    format: "application/n-quads",
    ...options
  });
}

// node_modules/base64url-universal/lib/base64url.js
/*!
 * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
 */
var _alphabetIdx = [
  62,
  -1,
  -1,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  -1,
  -1,
  -1,
  -1,
  63,
  -1,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
function decode(input) {
  let length = input.length;
  const mod4 = length % 4;
  if (mod4 === 1) {
    throw new Error("Illegal base64 string.");
  }
  let diff = 0;
  if (mod4 > 0) {
    diff = 4 - mod4;
    length += diff;
  }
  const output = new Uint8Array(length / 4 * 3 - diff);
  let enc1;
  let enc2;
  let enc3;
  let enc4;
  let i = 0;
  let j2 = 0;
  while (i < length) {
    enc1 = _alphabetIdx[input.charCodeAt(i++) - 45];
    enc2 = _alphabetIdx[input.charCodeAt(i++) - 45];
    output[j2++] = enc1 << 2 | enc2 >> 4;
    if (i < input.length) {
      enc3 = _alphabetIdx[input.charCodeAt(i++) - 45];
      output[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (i < input.length) {
        enc4 = _alphabetIdx[input.charCodeAt(i++) - 45];
        output[j2++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output;
}

// node_modules/base64url-universal/lib/browser.js
/*!
 * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.
 */

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
var pw = Object.create;
var Xa = Object.defineProperty;
var vw = Object.getOwnPropertyDescriptor;
var bw = Object.getOwnPropertyNames;
var mw = Object.getPrototypeOf;
var gw = Object.prototype.hasOwnProperty;
var R0 = (t, e) => () => (t && (e = t(t = 0)), e);
var T = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
};
var Ya = (t, e, r, o2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f of bw(e))
      !gw.call(t, f) && f !== r && Xa(t, f, { get: () => e[f], enumerable: !(o2 = vw(e, f)) || o2.enumerable });
  return t;
};
var ot2 = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default"));
var rn = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t));
var ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t);
var Nd = T((Qa) => {
  Qa.byteLength = ww;
  Qa.toByteArray = _w;
  Qa.fromByteArray = Ew;
  var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (nn = 0, kd = B0.length;nn < kd; ++nn)
    jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
  var nn, kd;
  lr[45] = 62;
  lr[95] = 63;
  function Ld(t) {
    var e = t.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t.indexOf("=");
    r === -1 && (r = e);
    var o2 = r === e ? 0 : 4 - r % 4;
    return [r, o2];
  }
  function ww(t) {
    var e = Ld(t), r = e[0], o2 = e[1];
    return (r + o2) * 3 / 4 - o2;
  }
  function Mw(t, e, r) {
    return (e + r) * 3 / 4 - r;
  }
  function _w(t) {
    var e, r = Ld(t), o2 = r[0], f = r[1], p2 = new yw(Mw(t, o2, f)), m2 = 0, y2 = f > 0 ? o2 - 4 : o2, M2;
    for (M2 = 0;M2 < y2; M2 += 4)
      e = lr[t.charCodeAt(M2)] << 18 | lr[t.charCodeAt(M2 + 1)] << 12 | lr[t.charCodeAt(M2 + 2)] << 6 | lr[t.charCodeAt(M2 + 3)], p2[m2++] = e >> 16 & 255, p2[m2++] = e >> 8 & 255, p2[m2++] = e & 255;
    return f === 2 && (e = lr[t.charCodeAt(M2)] << 2 | lr[t.charCodeAt(M2 + 1)] >> 4, p2[m2++] = e & 255), f === 1 && (e = lr[t.charCodeAt(M2)] << 10 | lr[t.charCodeAt(M2 + 1)] << 4 | lr[t.charCodeAt(M2 + 2)] >> 2, p2[m2++] = e >> 8 & 255, p2[m2++] = e & 255), p2;
  }
  function xw(t) {
    return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
  }
  function Sw(t, e, r) {
    for (var o2, f = [], p2 = e;p2 < r; p2 += 3)
      o2 = (t[p2] << 16 & 16711680) + (t[p2 + 1] << 8 & 65280) + (t[p2 + 2] & 255), f.push(xw(o2));
    return f.join("");
  }
  function Ew(t) {
    for (var e, r = t.length, o2 = r % 3, f = [], p2 = 16383, m2 = 0, y2 = r - o2;m2 < y2; m2 += p2)
      f.push(Sw(t, m2, m2 + p2 > y2 ? y2 : m2 + p2));
    return o2 === 1 ? (e = t[r - 1], f.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o2 === 2 && (e = (t[r - 2] << 8) + t[r - 1], f.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f.join("");
  }
});
var Dd = T((q0) => {
  q0.read = function(t, e, r, o2, f) {
    var p2, m2, y2 = f * 8 - o2 - 1, M2 = (1 << y2) - 1, x3 = M2 >> 1, S = -7, E3 = r ? f - 1 : 0, B = r ? -1 : 1, q = t[e + E3];
    for (E3 += B, p2 = q & (1 << -S) - 1, q >>= -S, S += y2;S > 0; p2 = p2 * 256 + t[e + E3], E3 += B, S -= 8)
      ;
    for (m2 = p2 & (1 << -S) - 1, p2 >>= -S, S += o2;S > 0; m2 = m2 * 256 + t[e + E3], E3 += B, S -= 8)
      ;
    if (p2 === 0)
      p2 = 1 - x3;
    else {
      if (p2 === M2)
        return m2 ? NaN : (q ? -1 : 1) * (1 / 0);
      m2 = m2 + Math.pow(2, o2), p2 = p2 - x3;
    }
    return (q ? -1 : 1) * m2 * Math.pow(2, p2 - o2);
  };
  q0.write = function(t, e, r, o2, f, p2) {
    var m2, y2, M2, x3 = p2 * 8 - f - 1, S = (1 << x3) - 1, E3 = S >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o2 ? 0 : p2 - 1, L2 = o2 ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y2 = isNaN(e) ? 1 : 0, m2 = S) : (m2 = Math.floor(Math.log(e) / Math.LN2), e * (M2 = Math.pow(2, -m2)) < 1 && (m2--, M2 *= 2), m2 + E3 >= 1 ? e += B / M2 : e += B * Math.pow(2, 1 - E3), e * M2 >= 2 && (m2++, M2 /= 2), m2 + E3 >= S ? (y2 = 0, m2 = S) : m2 + E3 >= 1 ? (y2 = (e * M2 - 1) * Math.pow(2, f), m2 = m2 + E3) : (y2 = e * Math.pow(2, E3 - 1) * Math.pow(2, f), m2 = 0));f >= 8; t[r + q] = y2 & 255, q += L2, y2 /= 256, f -= 8)
      ;
    for (m2 = m2 << f | y2, x3 += f;x3 > 0; t[r + q] = m2 & 255, q += L2, m2 /= 256, x3 -= 8)
      ;
    t[r + q - L2] |= ge * 128;
  };
});
var Ut2 = T((Xn) => {
  var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Xn.Buffer = me;
  Xn.SlowBuffer = Tw;
  Xn.INSPECT_MAX_BYTES = 50;
  var eo = 2147483647;
  Xn.kMaxLength = eo;
  me.TYPED_ARRAY_SUPPORT = Aw();
  !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Aw() {
    try {
      let t = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
    if (!!me.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
    if (!!me.isBuffer(this))
      return this.byteOffset;
  } });
  function li(t) {
    if (t > eo)
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    let e = new Uint8Array(t);
    return Object.setPrototypeOf(e, me.prototype), e;
  }
  function me(t, e, r) {
    if (typeof t == "number") {
      if (typeof e == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return N0(t);
    }
    return Ud(t, e, r);
  }
  me.poolSize = 8192;
  function Ud(t, e, r) {
    if (typeof t == "string")
      return Bw(t, e);
    if (ArrayBuffer.isView(t))
      return qw(t);
    if (t == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    if (Zr2(t, ArrayBuffer) || t && Zr2(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr2(t, SharedArrayBuffer) || t && Zr2(t.buffer, SharedArrayBuffer)))
      return k0(t, e, r);
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let o2 = t.valueOf && t.valueOf();
    if (o2 != null && o2 !== t)
      return me.from(o2, e, r);
    let f = Iw(t);
    if (f)
      return f;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
      return me.from(t[Symbol.toPrimitive]("string"), e, r);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  }
  me.from = function(t, e, r) {
    return Ud(t, e, r);
  };
  Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(me, Uint8Array);
  function zd(t) {
    if (typeof t != "number")
      throw new TypeError('"size" argument must be of type number');
    if (t < 0)
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
  }
  function Rw(t, e, r) {
    return zd(t), t <= 0 ? li(t) : e !== undefined ? typeof r == "string" ? li(t).fill(e, r) : li(t).fill(e) : li(t);
  }
  me.alloc = function(t, e, r) {
    return Rw(t, e, r);
  };
  function N0(t) {
    return zd(t), li(t < 0 ? 0 : D0(t) | 0);
  }
  me.allocUnsafe = function(t) {
    return N0(t);
  };
  me.allocUnsafeSlow = function(t) {
    return N0(t);
  };
  function Bw(t, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    let r = Hd(t, e) | 0, o2 = li(r), f = o2.write(t, e);
    return f !== r && (o2 = o2.slice(0, f)), o2;
  }
  function T0(t) {
    let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e);
    for (let o2 = 0;o2 < e; o2 += 1)
      r[o2] = t[o2] & 255;
    return r;
  }
  function qw(t) {
    if (Zr2(t, Uint8Array)) {
      let e = new Uint8Array(t);
      return k0(e.buffer, e.byteOffset, e.byteLength);
    }
    return T0(t);
  }
  function k0(t, e, r) {
    if (e < 0 || t.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t.byteLength < e + (r || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let o2;
    return e === undefined && r === undefined ? o2 = new Uint8Array(t) : r === undefined ? o2 = new Uint8Array(t, e) : o2 = new Uint8Array(t, e, r), Object.setPrototypeOf(o2, me.prototype), o2;
  }
  function Iw(t) {
    if (me.isBuffer(t)) {
      let e = D0(t.length) | 0, r = li(e);
      return r.length === 0 || t.copy(r, 0, 0, e), r;
    }
    if (t.length !== undefined)
      return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
    if (t.type === "Buffer" && Array.isArray(t.data))
      return T0(t.data);
  }
  function D0(t) {
    if (t >= eo)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
    return t | 0;
  }
  function Tw(t) {
    return +t != t && (t = 0), me.alloc(+t);
  }
  me.isBuffer = function(e) {
    return e != null && e._isBuffer === true && e !== me.prototype;
  };
  me.compare = function(e, r) {
    if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr2(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e === r)
      return 0;
    let o2 = e.length, f = r.length;
    for (let p2 = 0, m2 = Math.min(o2, f);p2 < m2; ++p2)
      if (e[p2] !== r[p2]) {
        o2 = e[p2], f = r[p2];
        break;
      }
    return o2 < f ? -1 : f < o2 ? 1 : 0;
  };
  me.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  me.concat = function(e, r) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return me.alloc(0);
    let o2;
    if (r === undefined)
      for (r = 0, o2 = 0;o2 < e.length; ++o2)
        r += e[o2].length;
    let f = me.allocUnsafe(r), p2 = 0;
    for (o2 = 0;o2 < e.length; ++o2) {
      let m2 = e[o2];
      if (Zr2(m2, Uint8Array))
        p2 + m2.length > f.length ? (me.isBuffer(m2) || (m2 = me.from(m2)), m2.copy(f, p2)) : Uint8Array.prototype.set.call(f, m2, p2);
      else if (me.isBuffer(m2))
        m2.copy(f, p2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      p2 += m2.length;
    }
    return f;
  };
  function Hd(t, e) {
    if (me.isBuffer(t))
      return t.length;
    if (ArrayBuffer.isView(t) || Zr2(t, ArrayBuffer))
      return t.byteLength;
    if (typeof t != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
    let r = t.length, o2 = arguments.length > 2 && arguments[2] === true;
    if (!o2 && r === 0)
      return 0;
    let f = false;
    for (;; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return r;
        case "utf8":
        case "utf-8":
          return L0(t).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return r * 2;
        case "hex":
          return r >>> 1;
        case "base64":
          return Xd(t).length;
        default:
          if (f)
            return o2 ? -1 : L0(t).length;
          e = ("" + e).toLowerCase(), f = true;
      }
  }
  me.byteLength = Hd;
  function kw(t, e, r) {
    let o2 = false;
    if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
      return "";
    for (t || (t = "utf8");; )
      switch (t) {
        case "hex":
          return Hw(this, e, r);
        case "utf8":
        case "utf-8":
          return Kd(this, e, r);
        case "ascii":
          return Uw(this, e, r);
        case "latin1":
        case "binary":
          return zw(this, e, r);
        case "base64":
          return Ow(this, e, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ww(this, e, r);
        default:
          if (o2)
            throw new TypeError("Unknown encoding: " + t);
          t = (t + "").toLowerCase(), o2 = true;
      }
  }
  me.prototype._isBuffer = true;
  function fn(t, e, r) {
    let o2 = t[e];
    t[e] = t[r], t[r] = o2;
  }
  me.prototype.swap16 = function() {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let r = 0;r < e; r += 2)
      fn(this, r, r + 1);
    return this;
  };
  me.prototype.swap32 = function() {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let r = 0;r < e; r += 4)
      fn(this, r, r + 3), fn(this, r + 1, r + 2);
    return this;
  };
  me.prototype.swap64 = function() {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let r = 0;r < e; r += 8)
      fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
    return this;
  };
  me.prototype.toString = function() {
    let e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
  };
  me.prototype.toLocaleString = me.prototype.toString;
  me.prototype.equals = function(e) {
    if (!me.isBuffer(e))
      throw new TypeError("Argument must be a Buffer");
    return this === e ? true : me.compare(this, e) === 0;
  };
  me.prototype.inspect = function() {
    let e = "", r = Xn.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
  };
  Pd && (me.prototype[Pd] = me.prototype.inspect);
  me.prototype.compare = function(e, r, o2, f, p2) {
    if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
    if (r === undefined && (r = 0), o2 === undefined && (o2 = e ? e.length : 0), f === undefined && (f = 0), p2 === undefined && (p2 = this.length), r < 0 || o2 > e.length || f < 0 || p2 > this.length)
      throw new RangeError("out of range index");
    if (f >= p2 && r >= o2)
      return 0;
    if (f >= p2)
      return -1;
    if (r >= o2)
      return 1;
    if (r >>>= 0, o2 >>>= 0, f >>>= 0, p2 >>>= 0, this === e)
      return 0;
    let m2 = p2 - f, y2 = o2 - r, M2 = Math.min(m2, y2), x3 = this.slice(f, p2), S = e.slice(r, o2);
    for (let E3 = 0;E3 < M2; ++E3)
      if (x3[E3] !== S[E3]) {
        m2 = x3[E3], y2 = S[E3];
        break;
      }
    return m2 < y2 ? -1 : y2 < m2 ? 1 : 0;
  };
  function Wd(t, e, r, o2, f) {
    if (t.length === 0)
      return -1;
    if (typeof r == "string" ? (o2 = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
      if (f)
        return -1;
      r = t.length - 1;
    } else if (r < 0)
      if (f)
        r = 0;
      else
        return -1;
    if (typeof e == "string" && (e = me.from(e, o2)), me.isBuffer(e))
      return e.length === 0 ? -1 : Cd(t, e, r, o2, f);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o2, f);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Cd(t, e, r, o2, f) {
    let p2 = 1, m2 = t.length, y2 = e.length;
    if (o2 !== undefined && (o2 = String(o2).toLowerCase(), o2 === "ucs2" || o2 === "ucs-2" || o2 === "utf16le" || o2 === "utf-16le")) {
      if (t.length < 2 || e.length < 2)
        return -1;
      p2 = 2, m2 /= 2, y2 /= 2, r /= 2;
    }
    function M2(S, E3) {
      return p2 === 1 ? S[E3] : S.readUInt16BE(E3 * p2);
    }
    let x3;
    if (f) {
      let S = -1;
      for (x3 = r;x3 < m2; x3++)
        if (M2(t, x3) === M2(e, S === -1 ? 0 : x3 - S)) {
          if (S === -1 && (S = x3), x3 - S + 1 === y2)
            return S * p2;
        } else
          S !== -1 && (x3 -= x3 - S), S = -1;
    } else
      for (r + y2 > m2 && (r = m2 - y2), x3 = r;x3 >= 0; x3--) {
        let S = true;
        for (let E3 = 0;E3 < y2; E3++)
          if (M2(t, x3 + E3) !== M2(e, E3)) {
            S = false;
            break;
          }
        if (S)
          return x3;
      }
    return -1;
  }
  me.prototype.includes = function(e, r, o2) {
    return this.indexOf(e, r, o2) !== -1;
  };
  me.prototype.indexOf = function(e, r, o2) {
    return Wd(this, e, r, o2, true);
  };
  me.prototype.lastIndexOf = function(e, r, o2) {
    return Wd(this, e, r, o2, false);
  };
  function Lw(t, e, r, o2) {
    r = Number(r) || 0;
    let f = t.length - r;
    o2 ? (o2 = Number(o2), o2 > f && (o2 = f)) : o2 = f;
    let p2 = e.length;
    o2 > p2 / 2 && (o2 = p2 / 2);
    let m2;
    for (m2 = 0;m2 < o2; ++m2) {
      let y2 = parseInt(e.substr(m2 * 2, 2), 16);
      if (C0(y2))
        return m2;
      t[r + m2] = y2;
    }
    return m2;
  }
  function Nw(t, e, r, o2) {
    return to(L0(e, t.length - r), t, r, o2);
  }
  function Dw(t, e, r, o2) {
    return to(Vw(e), t, r, o2);
  }
  function Pw(t, e, r, o2) {
    return to(Xd(e), t, r, o2);
  }
  function Cw(t, e, r, o2) {
    return to($w(e, t.length - r), t, r, o2);
  }
  me.prototype.write = function(e, r, o2, f) {
    if (r === undefined)
      f = "utf8", o2 = this.length, r = 0;
    else if (o2 === undefined && typeof r == "string")
      f = r, o2 = this.length, r = 0;
    else if (isFinite(r))
      r = r >>> 0, isFinite(o2) ? (o2 = o2 >>> 0, f === undefined && (f = "utf8")) : (f = o2, o2 = undefined);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let p2 = this.length - r;
    if ((o2 === undefined || o2 > p2) && (o2 = p2), e.length > 0 && (o2 < 0 || r < 0) || r > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    f || (f = "utf8");
    let m2 = false;
    for (;; )
      switch (f) {
        case "hex":
          return Lw(this, e, r, o2);
        case "utf8":
        case "utf-8":
          return Nw(this, e, r, o2);
        case "ascii":
        case "latin1":
        case "binary":
          return Dw(this, e, r, o2);
        case "base64":
          return Pw(this, e, r, o2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Cw(this, e, r, o2);
        default:
          if (m2)
            throw new TypeError("Unknown encoding: " + f);
          f = ("" + f).toLowerCase(), m2 = true;
      }
  };
  me.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Ow(t, e, r) {
    return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
  }
  function Kd(t, e, r) {
    r = Math.min(t.length, r);
    let o2 = [], f = e;
    for (;f < r; ) {
      let p2 = t[f], m2 = null, y2 = p2 > 239 ? 4 : p2 > 223 ? 3 : p2 > 191 ? 2 : 1;
      if (f + y2 <= r) {
        let M2, x3, S, E3;
        switch (y2) {
          case 1:
            p2 < 128 && (m2 = p2);
            break;
          case 2:
            M2 = t[f + 1], (M2 & 192) === 128 && (E3 = (p2 & 31) << 6 | M2 & 63, E3 > 127 && (m2 = E3));
            break;
          case 3:
            M2 = t[f + 1], x3 = t[f + 2], (M2 & 192) === 128 && (x3 & 192) === 128 && (E3 = (p2 & 15) << 12 | (M2 & 63) << 6 | x3 & 63, E3 > 2047 && (E3 < 55296 || E3 > 57343) && (m2 = E3));
            break;
          case 4:
            M2 = t[f + 1], x3 = t[f + 2], S = t[f + 3], (M2 & 192) === 128 && (x3 & 192) === 128 && (S & 192) === 128 && (E3 = (p2 & 15) << 18 | (M2 & 63) << 12 | (x3 & 63) << 6 | S & 63, E3 > 65535 && E3 < 1114112 && (m2 = E3));
        }
      }
      m2 === null ? (m2 = 65533, y2 = 1) : m2 > 65535 && (m2 -= 65536, o2.push(m2 >>> 10 & 1023 | 55296), m2 = 56320 | m2 & 1023), o2.push(m2), f += y2;
    }
    return Fw(o2);
  }
  var Od = 4096;
  function Fw(t) {
    let e = t.length;
    if (e <= Od)
      return String.fromCharCode.apply(String, t);
    let r = "", o2 = 0;
    for (;o2 < e; )
      r += String.fromCharCode.apply(String, t.slice(o2, o2 += Od));
    return r;
  }
  function Uw(t, e, r) {
    let o2 = "";
    r = Math.min(t.length, r);
    for (let f = e;f < r; ++f)
      o2 += String.fromCharCode(t[f] & 127);
    return o2;
  }
  function zw(t, e, r) {
    let o2 = "";
    r = Math.min(t.length, r);
    for (let f = e;f < r; ++f)
      o2 += String.fromCharCode(t[f]);
    return o2;
  }
  function Hw(t, e, r) {
    let o2 = t.length;
    (!e || e < 0) && (e = 0), (!r || r < 0 || r > o2) && (r = o2);
    let f = "";
    for (let p2 = e;p2 < r; ++p2)
      f += Gw[t[p2]];
    return f;
  }
  function Ww(t, e, r) {
    let o2 = t.slice(e, r), f = "";
    for (let p2 = 0;p2 < o2.length - 1; p2 += 2)
      f += String.fromCharCode(o2[p2] + o2[p2 + 1] * 256);
    return f;
  }
  me.prototype.slice = function(e, r) {
    let o2 = this.length;
    e = ~~e, r = r === undefined ? o2 : ~~r, e < 0 ? (e += o2, e < 0 && (e = 0)) : e > o2 && (e = o2), r < 0 ? (r += o2, r < 0 && (r = 0)) : r > o2 && (r = o2), r < e && (r = e);
    let f = this.subarray(e, r);
    return Object.setPrototypeOf(f, me.prototype), f;
  };
  function Dt(t, e, r) {
    if (t % 1 !== 0 || t < 0)
      throw new RangeError("offset is not uint");
    if (t + e > r)
      throw new RangeError("Trying to access beyond buffer length");
  }
  me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o2) {
    e = e >>> 0, r = r >>> 0, o2 || Dt(e, r, this.length);
    let f = this[e], p2 = 1, m2 = 0;
    for (;++m2 < r && (p2 *= 256); )
      f += this[e + m2] * p2;
    return f;
  };
  me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o2) {
    e = e >>> 0, r = r >>> 0, o2 || Dt(e, r, this.length);
    let f = this[e + --r], p2 = 1;
    for (;r > 0 && (p2 *= 256); )
      f += this[e + --r] * p2;
    return f;
  };
  me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
    return e = e >>> 0, r || Dt(e, 1, this.length), this[e];
  };
  me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 2, this.length), this[e] | this[e + 1] << 8;
  };
  me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 2, this.length), this[e] << 8 | this[e + 1];
  };
  me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  };
  me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  };
  me.prototype.readBigUInt64LE = Ti(function(e) {
    e = e >>> 0, Yn(e, "offset");
    let r = this[e], o2 = this[e + 7];
    (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
    let f = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p2 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o2 * 2 ** 24;
    return BigInt(f) + (BigInt(p2) << BigInt(32));
  });
  me.prototype.readBigUInt64BE = Ti(function(e) {
    e = e >>> 0, Yn(e, "offset");
    let r = this[e], o2 = this[e + 7];
    (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
    let f = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p2 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2;
    return (BigInt(f) << BigInt(32)) + BigInt(p2);
  });
  me.prototype.readIntLE = function(e, r, o2) {
    e = e >>> 0, r = r >>> 0, o2 || Dt(e, r, this.length);
    let f = this[e], p2 = 1, m2 = 0;
    for (;++m2 < r && (p2 *= 256); )
      f += this[e + m2] * p2;
    return p2 *= 128, f >= p2 && (f -= Math.pow(2, 8 * r)), f;
  };
  me.prototype.readIntBE = function(e, r, o2) {
    e = e >>> 0, r = r >>> 0, o2 || Dt(e, r, this.length);
    let f = r, p2 = 1, m2 = this[e + --f];
    for (;f > 0 && (p2 *= 256); )
      m2 += this[e + --f] * p2;
    return p2 *= 128, m2 >= p2 && (m2 -= Math.pow(2, 8 * r)), m2;
  };
  me.prototype.readInt8 = function(e, r) {
    return e = e >>> 0, r || Dt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  };
  me.prototype.readInt16LE = function(e, r) {
    e = e >>> 0, r || Dt(e, 2, this.length);
    let o2 = this[e] | this[e + 1] << 8;
    return o2 & 32768 ? o2 | 4294901760 : o2;
  };
  me.prototype.readInt16BE = function(e, r) {
    e = e >>> 0, r || Dt(e, 2, this.length);
    let o2 = this[e + 1] | this[e] << 8;
    return o2 & 32768 ? o2 | 4294901760 : o2;
  };
  me.prototype.readInt32LE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  };
  me.prototype.readInt32BE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  };
  me.prototype.readBigInt64LE = Ti(function(e) {
    e = e >>> 0, Yn(e, "offset");
    let r = this[e], o2 = this[e + 7];
    (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
    let f = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o2 << 24);
    return (BigInt(f) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  });
  me.prototype.readBigInt64BE = Ti(function(e) {
    e = e >>> 0, Yn(e, "offset");
    let r = this[e], o2 = this[e + 7];
    (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
    let f = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(f) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2);
  });
  me.prototype.readFloatLE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, true, 23, 4);
  };
  me.prototype.readFloatBE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, false, 23, 4);
  };
  me.prototype.readDoubleLE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, true, 52, 8);
  };
  me.prototype.readDoubleBE = function(e, r) {
    return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, false, 52, 8);
  };
  function er(t, e, r, o2, f, p2) {
    if (!me.isBuffer(t))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > f || e < p2)
      throw new RangeError('"value" argument is out of bounds');
    if (r + o2 > t.length)
      throw new RangeError("Index out of range");
  }
  me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o2, f) {
    if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f) {
      let y2 = Math.pow(2, 8 * o2) - 1;
      er(this, e, r, o2, y2, 0);
    }
    let p2 = 1, m2 = 0;
    for (this[r] = e & 255;++m2 < o2 && (p2 *= 256); )
      this[r + m2] = e / p2 & 255;
    return r + o2;
  };
  me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o2, f) {
    if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f) {
      let y2 = Math.pow(2, 8 * o2) - 1;
      er(this, e, r, o2, y2, 0);
    }
    let p2 = o2 - 1, m2 = 1;
    for (this[r + p2] = e & 255;--p2 >= 0 && (m2 *= 256); )
      this[r + p2] = e / m2 & 255;
    return r + o2;
  };
  me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
  };
  me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  };
  me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  };
  me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
  };
  me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  };
  function jd(t, e, r, o2, f) {
    Yd(e, o2, f, t, r, 7);
    let p2 = Number(e & BigInt(4294967295));
    t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2;
    let m2 = Number(e >> BigInt(32) & BigInt(4294967295));
    return t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, r;
  }
  function Zd(t, e, r, o2, f) {
    Yd(e, o2, f, t, r, 7);
    let p2 = Number(e & BigInt(4294967295));
    t[r + 7] = p2, p2 = p2 >> 8, t[r + 6] = p2, p2 = p2 >> 8, t[r + 5] = p2, p2 = p2 >> 8, t[r + 4] = p2;
    let m2 = Number(e >> BigInt(32) & BigInt(4294967295));
    return t[r + 3] = m2, m2 = m2 >> 8, t[r + 2] = m2, m2 = m2 >> 8, t[r + 1] = m2, m2 = m2 >> 8, t[r] = m2, r + 8;
  }
  me.prototype.writeBigUInt64LE = Ti(function(e, r = 0) {
    return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  me.prototype.writeBigUInt64BE = Ti(function(e, r = 0) {
    return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  me.prototype.writeIntLE = function(e, r, o2, f) {
    if (e = +e, r = r >>> 0, !f) {
      let M2 = Math.pow(2, 8 * o2 - 1);
      er(this, e, r, o2, M2 - 1, -M2);
    }
    let p2 = 0, m2 = 1, y2 = 0;
    for (this[r] = e & 255;++p2 < o2 && (m2 *= 256); )
      e < 0 && y2 === 0 && this[r + p2 - 1] !== 0 && (y2 = 1), this[r + p2] = (e / m2 >> 0) - y2 & 255;
    return r + o2;
  };
  me.prototype.writeIntBE = function(e, r, o2, f) {
    if (e = +e, r = r >>> 0, !f) {
      let M2 = Math.pow(2, 8 * o2 - 1);
      er(this, e, r, o2, M2 - 1, -M2);
    }
    let p2 = o2 - 1, m2 = 1, y2 = 0;
    for (this[r + p2] = e & 255;--p2 >= 0 && (m2 *= 256); )
      e < 0 && y2 === 0 && this[r + p2 + 1] !== 0 && (y2 = 1), this[r + p2] = (e / m2 >> 0) - y2 & 255;
    return r + o2;
  };
  me.prototype.writeInt8 = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
  };
  me.prototype.writeInt16LE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  };
  me.prototype.writeInt16BE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  };
  me.prototype.writeInt32LE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
  };
  me.prototype.writeInt32BE = function(e, r, o2) {
    return e = +e, r = r >>> 0, o2 || er(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  };
  me.prototype.writeBigInt64LE = Ti(function(e, r = 0) {
    return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  me.prototype.writeBigInt64BE = Ti(function(e, r = 0) {
    return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Vd(t, e, r, o2, f, p2) {
    if (r + o2 > t.length)
      throw new RangeError("Index out of range");
    if (r < 0)
      throw new RangeError("Index out of range");
  }
  function $d(t, e, r, o2, f) {
    return e = +e, r = r >>> 0, f || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o2, 23, 4), r + 4;
  }
  me.prototype.writeFloatLE = function(e, r, o2) {
    return $d(this, e, r, true, o2);
  };
  me.prototype.writeFloatBE = function(e, r, o2) {
    return $d(this, e, r, false, o2);
  };
  function Gd(t, e, r, o2, f) {
    return e = +e, r = r >>> 0, f || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o2, 52, 8), r + 8;
  }
  me.prototype.writeDoubleLE = function(e, r, o2) {
    return Gd(this, e, r, true, o2);
  };
  me.prototype.writeDoubleBE = function(e, r, o2) {
    return Gd(this, e, r, false, o2);
  };
  me.prototype.copy = function(e, r, o2, f) {
    if (!me.isBuffer(e))
      throw new TypeError("argument should be a Buffer");
    if (o2 || (o2 = 0), !f && f !== 0 && (f = this.length), r >= e.length && (r = e.length), r || (r = 0), f > 0 && f < o2 && (f = o2), f === o2 || e.length === 0 || this.length === 0)
      return 0;
    if (r < 0)
      throw new RangeError("targetStart out of bounds");
    if (o2 < 0 || o2 >= this.length)
      throw new RangeError("Index out of range");
    if (f < 0)
      throw new RangeError("sourceEnd out of bounds");
    f > this.length && (f = this.length), e.length - r < f - o2 && (f = e.length - r + o2);
    let p2 = f - o2;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o2, f) : Uint8Array.prototype.set.call(e, this.subarray(o2, f), r), p2;
  };
  me.prototype.fill = function(e, r, o2, f) {
    if (typeof e == "string") {
      if (typeof r == "string" ? (f = r, r = 0, o2 = this.length) : typeof o2 == "string" && (f = o2, o2 = this.length), f !== undefined && typeof f != "string")
        throw new TypeError("encoding must be a string");
      if (typeof f == "string" && !me.isEncoding(f))
        throw new TypeError("Unknown encoding: " + f);
      if (e.length === 1) {
        let m2 = e.charCodeAt(0);
        (f === "utf8" && m2 < 128 || f === "latin1") && (e = m2);
      }
    } else
      typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (r < 0 || this.length < r || this.length < o2)
      throw new RangeError("Out of range index");
    if (o2 <= r)
      return this;
    r = r >>> 0, o2 = o2 === undefined ? this.length : o2 >>> 0, e || (e = 0);
    let p2;
    if (typeof e == "number")
      for (p2 = r;p2 < o2; ++p2)
        this[p2] = e;
    else {
      let m2 = me.isBuffer(e) ? e : me.from(e, f), y2 = m2.length;
      if (y2 === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (p2 = 0;p2 < o2 - r; ++p2)
        this[p2 + r] = m2[p2 % y2];
    }
    return this;
  };
  var $n = {};
  function P0(t, e, r) {
    $n[t] = class extends r {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
      }
      get code() {
        return t;
      }
      set code(f) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f, writable: true });
      }
      toString() {
        return `${this.name} [${t}]: ${this.message}`;
      }
    };
  }
  P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
    return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  P0("ERR_INVALID_ARG_TYPE", function(t, e) {
    return `The "${t}" argument must be of type number. Received type ${typeof e}`;
  }, TypeError);
  P0("ERR_OUT_OF_RANGE", function(t, e, r) {
    let o2 = `The value of "${t}" is out of range.`, f = r;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f = Fd(String(r)) : typeof r == "bigint" && (f = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f = Fd(f)), f += "n"), o2 += ` It must be ${e}. Received ${f}`, o2;
  }, RangeError);
  function Fd(t) {
    let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
    for (;r >= o2 + 4; r -= 3)
      e = `_${t.slice(r - 3, r)}${e}`;
    return `${t.slice(0, r)}${e}`;
  }
  function Kw(t, e, r) {
    Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
  }
  function Yd(t, e, r, o2, f, p2) {
    if (t > r || t < e) {
      let m2 = typeof e == "bigint" ? "n" : "", y2;
      throw p2 > 3 ? e === 0 || e === BigInt(0) ? y2 = `>= 0${m2} and < 2${m2} ** ${(p2 + 1) * 8}${m2}` : y2 = `>= -(2${m2} ** ${(p2 + 1) * 8 - 1}${m2}) and < 2 ** ${(p2 + 1) * 8 - 1}${m2}` : y2 = `>= ${e}${m2} and <= ${r}${m2}`, new $n.ERR_OUT_OF_RANGE("value", y2, t);
    }
    Kw(o2, f, p2);
  }
  function Yn(t, e) {
    if (typeof t != "number")
      throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
  }
  function Vf(t, e, r) {
    throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
  }
  var jw = /[^+/0-9A-Za-z-_]/g;
  function Zw(t) {
    if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
      return "";
    for (;t.length % 4 !== 0; )
      t = t + "=";
    return t;
  }
  function L0(t, e) {
    e = e || 1 / 0;
    let r, o2 = t.length, f = null, p2 = [];
    for (let m2 = 0;m2 < o2; ++m2) {
      if (r = t.charCodeAt(m2), r > 55295 && r < 57344) {
        if (!f) {
          if (r > 56319) {
            (e -= 3) > -1 && p2.push(239, 191, 189);
            continue;
          } else if (m2 + 1 === o2) {
            (e -= 3) > -1 && p2.push(239, 191, 189);
            continue;
          }
          f = r;
          continue;
        }
        if (r < 56320) {
          (e -= 3) > -1 && p2.push(239, 191, 189), f = r;
          continue;
        }
        r = (f - 55296 << 10 | r - 56320) + 65536;
      } else
        f && (e -= 3) > -1 && p2.push(239, 191, 189);
      if (f = null, r < 128) {
        if ((e -= 1) < 0)
          break;
        p2.push(r);
      } else if (r < 2048) {
        if ((e -= 2) < 0)
          break;
        p2.push(r >> 6 | 192, r & 63 | 128);
      } else if (r < 65536) {
        if ((e -= 3) < 0)
          break;
        p2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
      } else if (r < 1114112) {
        if ((e -= 4) < 0)
          break;
        p2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return p2;
  }
  function Vw(t) {
    let e = [];
    for (let r = 0;r < t.length; ++r)
      e.push(t.charCodeAt(r) & 255);
    return e;
  }
  function $w(t, e) {
    let r, o2, f, p2 = [];
    for (let m2 = 0;m2 < t.length && !((e -= 2) < 0); ++m2)
      r = t.charCodeAt(m2), o2 = r >> 8, f = r % 256, p2.push(f), p2.push(o2);
    return p2;
  }
  function Xd(t) {
    return I0.toByteArray(Zw(t));
  }
  function to(t, e, r, o2) {
    let f;
    for (f = 0;f < o2 && !(f + r >= e.length || f >= t.length); ++f)
      e[f + r] = t[f];
    return f;
  }
  function Zr2(t, e) {
    return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
  }
  function C0(t) {
    return t !== t;
  }
  var Gw = function() {
    let t = "0123456789abcdef", e = new Array(256);
    for (let r = 0;r < 16; ++r) {
      let o2 = r * 16;
      for (let f = 0;f < 16; ++f)
        e[o2 + f] = t[r] + t[f];
    }
    return e;
  }();
  function Ti(t) {
    return typeof BigInt > "u" ? Yw : t;
  }
  function Yw() {
    throw new Error("BigInt not supported");
  }
});
var Te = T((O0, Qd) => {
  var ro = Ut2(), Vr = ro.Buffer;
  function Jd(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
  function an(t, e, r) {
    return Vr(t, e, r);
  }
  an.prototype = Object.create(Vr.prototype);
  Jd(Vr, an);
  an.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return Vr(t, e, r);
  };
  an.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var o2 = Vr(t);
    return e !== undefined ? typeof r == "string" ? o2.fill(e, r) : o2.fill(e) : o2.fill(0), o2;
  };
  an.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Vr(t);
  };
  an.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return ro.SlowBuffer(t);
  };
});
var on = T((Gq, U0) => {
  var F0 = 65536, Xw = 4294967295;
  function Jw() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
  io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
  function e6(t, e) {
    if (t > Xw)
      throw new RangeError("requested too many random bytes");
    var r = Qw.allocUnsafe(t);
    if (t > 0)
      if (t > F0)
        for (var o2 = 0;o2 < t; o2 += F0)
          io.getRandomValues(r.slice(o2, o2 + F0));
      else
        io.getRandomValues(r);
    return typeof e == "function" ? process.nextTick(function() {
      e(null, r);
    }) : r;
  }
});
var Ie = T((Yq, z0) => {
  typeof Object.create == "function" ? z0.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : z0.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var o2 = function() {
      };
      o2.prototype = r.prototype, e.prototype = new o2, e.prototype.constructor = e;
    }
  };
});
var ki = T((Xq, H0) => {
  var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o2) {
    return Function.prototype.apply.call(e, r, o2);
  }, no;
  Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : no = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function t6(t) {
    console && console.warn && console.warn(t);
  }
  var rc = Number.isNaN || function(e) {
    return e !== e;
  };
  function Fe() {
    Fe.init.call(this);
  }
  H0.exports = Fe;
  H0.exports.once = f6;
  Fe.EventEmitter = Fe;
  Fe.prototype._events = undefined;
  Fe.prototype._eventsCount = 0;
  Fe.prototype._maxListeners = undefined;
  var tc = 10;
  function fo(t) {
    if (typeof t != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
  }
  Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
    return tc;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || rc(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    tc = t;
  } });
  Fe.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  Fe.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || rc(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function ic(t) {
    return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
  }
  Fe.prototype.getMaxListeners = function() {
    return ic(this);
  };
  Fe.prototype.emit = function(e) {
    for (var r = [], o2 = 1;o2 < arguments.length; o2++)
      r.push(arguments[o2]);
    var f = e === "error", p2 = this._events;
    if (p2 !== undefined)
      f = f && p2.error === undefined;
    else if (!f)
      return false;
    if (f) {
      var m2;
      if (r.length > 0 && (m2 = r[0]), m2 instanceof Error)
        throw m2;
      var y2 = new Error("Unhandled error." + (m2 ? " (" + m2.message + ")" : ""));
      throw y2.context = m2, y2;
    }
    var M2 = p2[e];
    if (M2 === undefined)
      return false;
    if (typeof M2 == "function")
      ec(M2, this, r);
    else
      for (var x3 = M2.length, S = sc(M2, x3), o2 = 0;o2 < x3; ++o2)
        ec(S[o2], this, r);
    return true;
  };
  function nc(t, e, r, o2) {
    var f, p2, m2;
    if (fo(r), p2 = t._events, p2 === undefined ? (p2 = t._events = Object.create(null), t._eventsCount = 0) : (p2.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p2 = t._events), m2 = p2[e]), m2 === undefined)
      m2 = p2[e] = r, ++t._eventsCount;
    else if (typeof m2 == "function" ? m2 = p2[e] = o2 ? [r, m2] : [m2, r] : o2 ? m2.unshift(r) : m2.push(r), f = ic(t), f > 0 && m2.length > f && !m2.warned) {
      m2.warned = true;
      var y2 = new Error("Possible EventEmitter memory leak detected. " + m2.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      y2.name = "MaxListenersExceededWarning", y2.emitter = t, y2.type = e, y2.count = m2.length, t6(y2);
    }
    return t;
  }
  Fe.prototype.addListener = function(e, r) {
    return nc(this, e, r, false);
  };
  Fe.prototype.on = Fe.prototype.addListener;
  Fe.prototype.prependListener = function(e, r) {
    return nc(this, e, r, true);
  };
  function r6() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function fc(t, e, r) {
    var o2 = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f = r6.bind(o2);
    return f.listener = r, o2.wrapFn = f, f;
  }
  Fe.prototype.once = function(e, r) {
    return fo(r), this.on(e, fc(this, e, r)), this;
  };
  Fe.prototype.prependOnceListener = function(e, r) {
    return fo(r), this.prependListener(e, fc(this, e, r)), this;
  };
  Fe.prototype.removeListener = function(e, r) {
    var o2, f, p2, m2, y2;
    if (fo(r), f = this._events, f === undefined)
      return this;
    if (o2 = f[e], o2 === undefined)
      return this;
    if (o2 === r || o2.listener === r)
      --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f[e], f.removeListener && this.emit("removeListener", e, o2.listener || r));
    else if (typeof o2 != "function") {
      for (p2 = -1, m2 = o2.length - 1;m2 >= 0; m2--)
        if (o2[m2] === r || o2[m2].listener === r) {
          y2 = o2[m2].listener, p2 = m2;
          break;
        }
      if (p2 < 0)
        return this;
      p2 === 0 ? o2.shift() : i6(o2, p2), o2.length === 1 && (f[e] = o2[0]), f.removeListener !== undefined && this.emit("removeListener", e, y2 || r);
    }
    return this;
  };
  Fe.prototype.off = Fe.prototype.removeListener;
  Fe.prototype.removeAllListeners = function(e) {
    var r, o2, f;
    if (o2 = this._events, o2 === undefined)
      return this;
    if (o2.removeListener === undefined)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o2[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o2[e]), this;
    if (arguments.length === 0) {
      var p2 = Object.keys(o2), m2;
      for (f = 0;f < p2.length; ++f)
        m2 = p2[f], m2 !== "removeListener" && this.removeAllListeners(m2);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (r = o2[e], typeof r == "function")
      this.removeListener(e, r);
    else if (r !== undefined)
      for (f = r.length - 1;f >= 0; f--)
        this.removeListener(e, r[f]);
    return this;
  };
  function ac(t, e, r) {
    var o2 = t._events;
    if (o2 === undefined)
      return [];
    var f = o2[e];
    return f === undefined ? [] : typeof f == "function" ? r ? [f.listener || f] : [f] : r ? n6(f) : sc(f, f.length);
  }
  Fe.prototype.listeners = function(e) {
    return ac(this, e, true);
  };
  Fe.prototype.rawListeners = function(e) {
    return ac(this, e, false);
  };
  Fe.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
  };
  Fe.prototype.listenerCount = oc;
  function oc(t) {
    var e = this._events;
    if (e !== undefined) {
      var r = e[t];
      if (typeof r == "function")
        return 1;
      if (r !== undefined)
        return r.length;
    }
    return 0;
  }
  Fe.prototype.eventNames = function() {
    return this._eventsCount > 0 ? no(this._events) : [];
  };
  function sc(t, e) {
    for (var r = new Array(e), o2 = 0;o2 < e; ++o2)
      r[o2] = t[o2];
    return r;
  }
  function i6(t, e) {
    for (;e + 1 < t.length; e++)
      t[e] = t[e + 1];
    t.pop();
  }
  function n6(t) {
    for (var e = new Array(t.length), r = 0;r < e.length; ++r)
      e[r] = t[r].listener || t[r];
    return e;
  }
  function f6(t, e) {
    return new Promise(function(r, o2) {
      function f(m2) {
        t.removeListener(e, p2), o2(m2);
      }
      function p2() {
        typeof t.removeListener == "function" && t.removeListener("error", f), r([].slice.call(arguments));
      }
      hc(t, e, p2, { once: true }), e !== "error" && a6(t, f, { once: true });
    });
  }
  function a6(t, e, r) {
    typeof t.on == "function" && hc(t, "error", e, r);
  }
  function hc(t, e, r, o2) {
    if (typeof t.on == "function")
      o2.once ? t.once(e, r) : t.on(e, r);
    else if (typeof t.addEventListener == "function")
      t.addEventListener(e, function f(p2) {
        o2.once && t.removeEventListener(e, f), r(p2);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
  }
});
var W0 = T((Jq, uc) => {
  uc.exports = ki().EventEmitter;
});
var $f = T(() => {
});
var pc = T((tI, cc) => {
  function lc(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(t);
      e && (o2 = o2.filter(function(f) {
        return Object.getOwnPropertyDescriptor(t, f).enumerable;
      })), r.push.apply(r, o2);
    }
    return r;
  }
  function o6(t) {
    for (var e = 1;e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? lc(Object(r), true).forEach(function(o2) {
        s6(t, o2, r[o2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o2) {
        Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
      });
    }
    return t;
  }
  function s6(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function h6(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function dc(t, e) {
    for (var r = 0;r < e.length; r++) {
      var o2 = e[r];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
    }
  }
  function u6(t, e, r) {
    return e && dc(t.prototype, e), r && dc(t, r), t;
  }
  var l6 = Ut2(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
  function p6(t, e, r) {
    ao.prototype.copy.call(t, e, r);
  }
  cc.exports = function() {
    function t() {
      h6(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return u6(t, [{ key: "push", value: function(r) {
      var o2 = { data: r, next: null };
      this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var o2 = { data: r, next: this.head };
      this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var o2 = this.head, f = "" + o2.data;o2 = o2.next; )
        f += r + o2.data;
      return f;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return ao.alloc(0);
      for (var o2 = ao.allocUnsafe(r >>> 0), f = this.head, p2 = 0;f; )
        p6(f.data, o2, p2), p2 += f.data.length, f = f.next;
      return o2;
    } }, { key: "consume", value: function(r, o2) {
      var f;
      return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o2 ? this._getString(r) : this._getBuffer(r), f;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var o2 = this.head, f = 1, p2 = o2.data;
      for (r -= p2.length;o2 = o2.next; ) {
        var m2 = o2.data, y2 = r > m2.length ? m2.length : r;
        if (y2 === m2.length ? p2 += m2 : p2 += m2.slice(0, r), r -= y2, r === 0) {
          y2 === m2.length ? (++f, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m2.slice(y2));
          break;
        }
        ++f;
      }
      return this.length -= f, p2;
    } }, { key: "_getBuffer", value: function(r) {
      var o2 = ao.allocUnsafe(r), f = this.head, p2 = 1;
      for (f.data.copy(o2), r -= f.data.length;f = f.next; ) {
        var m2 = f.data, y2 = r > m2.length ? m2.length : r;
        if (m2.copy(o2, o2.length - r, 0, y2), r -= y2, r === 0) {
          y2 === m2.length ? (++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m2.slice(y2));
          break;
        }
        ++p2;
      }
      return this.length -= p2, o2;
    } }, { key: c6, value: function(r, o2) {
      return K0(this, o6({}, o2, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var Z0 = T((rI, bc) => {
  function v6(t, e) {
    var r = this, o2 = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return o2 || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
      !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p2)) : process.nextTick(vc, r, p2) : e ? (process.nextTick(oo, r), e(p2)) : process.nextTick(oo, r);
    }), this);
  }
  function vc(t, e) {
    j0(t, e), oo(t);
  }
  function oo(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function b6() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function j0(t, e) {
    t.emit("error", e);
  }
  function m6(t, e) {
    var { _readableState: r, _writableState: o2 } = t;
    r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
});
var sn = T((iI, yc) => {
  function g6(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var gc = {};
  function dr2(t, e, r) {
    r || (r = Error);
    function o2(p2, m2, y2) {
      return typeof e == "string" ? e : e(p2, m2, y2);
    }
    var f = function(p2) {
      g6(m2, p2);
      function m2(y2, M2, x3) {
        return p2.call(this, o2(y2, M2, x3)) || this;
      }
      return m2;
    }(r);
    f.prototype.name = r.name, f.prototype.code = t, gc[t] = f;
  }
  function mc(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(o2) {
        return String(o2);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function y6(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function w6(t, e, r) {
    return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function M6(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  dr2("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  dr2("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var o2;
    typeof e == "string" && y6(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
    var f;
    if (w6(t, " argument"))
      f = "The ".concat(t, " ").concat(o2, " ").concat(mc(e, "type"));
    else {
      var p2 = M6(t, ".") ? "property" : "argument";
      f = 'The "'.concat(t, '" ').concat(p2, " ").concat(o2, " ").concat(mc(e, "type"));
    }
    return f += ". Received type ".concat(typeof r), f;
  }, TypeError);
  dr2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  dr2("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  dr2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  dr2("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  dr2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  dr2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  dr2("ERR_STREAM_WRITE_AFTER_END", "write after end");
  dr2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  dr2("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  dr2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  yc.exports.codes = gc;
});
var V0 = T((nI, wc) => {
  var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
  function x6(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function S6(t, e, r, o2) {
    var f = x6(e, o2, r);
    if (f != null) {
      if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
        var p2 = o2 ? r : "highWaterMark";
        throw new _6(p2, f);
      }
      return Math.floor(f);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  wc.exports = { getHighWaterMark: S6 };
});
var G0 = T((fI, Mc) => {
  Mc.exports = E6;
  function E6(t, e) {
    if ($0("noDeprecation"))
      return t;
    var r = false;
    function o2() {
      if (!r) {
        if ($0("throwDeprecation"))
          throw new Error(e);
        $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return o2;
  }
  function $0(t) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = global.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var J0 = T((aI, Rc) => {
  Rc.exports = ht2;
  function xc(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      J6(e, t);
    };
  }
  var Qn;
  ht2.WritableState = Yf;
  var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut2().Buffer, R6 = global.Uint8Array || function() {
  };
  function B6(t) {
    return ho.from(t);
  }
  function q6(t) {
    return ho.isBuffer(t) || t instanceof R6;
  }
  var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
  Ie()(ht2, Sc);
  function U6() {
  }
  function Yf(t, e, r) {
    Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o2 = t.decodeStrings === false;
    this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
      V6(e, f);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
  }
  Yf.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = [];e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var so2;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht2, Symbol.hasInstance, { value: function(e) {
    return so2.call(this, e) ? true : this !== ht2 ? false : e && e._writableState instanceof Yf;
  } })) : so2 = function(e) {
    return e instanceof this;
  };
  function ht2(t) {
    Qn = Qn || hn();
    var e = this instanceof Qn;
    if (!e && !so2.call(ht2, this))
      return new ht2(t);
    this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
  }
  ht2.prototype.pipe = function() {
    ef(this, new D6);
  };
  function z6(t, e) {
    var r = new O6;
    ef(t, r), process.nextTick(e, r);
  }
  function H6(t, e, r, o2) {
    var f;
    return r === null ? f = new C6 : typeof r != "string" && !e.objectMode && (f = new k6("chunk", ["string", "Buffer"], r)), f ? (ef(t, f), process.nextTick(o2, f), false) : true;
  }
  ht2.prototype.write = function(t, e, r) {
    var o2 = this._writableState, f = false, p2 = !o2.objectMode && q6(t);
    return p2 && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = U6), o2.ending ? z6(this, r) : (p2 || H6(this, o2, t, r)) && (o2.pendingcb++, f = K6(this, o2, p2, t, e, r)), f;
  };
  ht2.prototype.cork = function() {
    this._writableState.corked++;
  };
  ht2.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
  };
  ht2.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new F6(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(ht2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function W6(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
  }
  Object.defineProperty(ht2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function K6(t, e, r, o2, f, p2) {
    if (!r) {
      var m2 = W6(e, o2, f);
      o2 !== m2 && (r = true, f = "buffer", o2 = m2);
    }
    var y2 = e.objectMode ? 1 : o2.length;
    e.length += y2;
    var M2 = e.length < e.highWaterMark;
    if (M2 || (e.needDrain = true), e.writing || e.corked) {
      var x3 = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: o2, encoding: f, isBuf: r, callback: p2, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      Y0(t, e, false, y2, o2, f, p2);
    return M2;
  }
  function Y0(t, e, r, o2, f, p2, m2) {
    e.writelen = o2, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
  }
  function j6(t, e, r, o2, f) {
    --e.pendingcb, r ? (process.nextTick(f, o2), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef(t, o2)) : (f(o2), t._writableState.errorEmitted = true, ef(t, o2), Gf(t, e));
  }
  function Z6(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function V6(t, e) {
    var r = t._writableState, o2 = r.sync, f = r.writecb;
    if (typeof f != "function")
      throw new N6;
    if (Z6(r), e)
      j6(t, r, o2, e, f);
    else {
      var p2 = Ac(r) || t.destroyed;
      !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o2 ? process.nextTick(_c, t, r, p2, f) : _c(t, r, p2, f);
    }
  }
  function _c(t, e, r, o2) {
    r || $6(t, e), e.pendingcb--, o2(), Gf(t, e);
  }
  function $6(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function Ec(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var o2 = e.bufferedRequestCount, f = new Array(o2), p2 = e.corkedRequestsFree;
      p2.entry = r;
      for (var m2 = 0, y2 = true;r; )
        f[m2] = r, r.isBuf || (y2 = false), r = r.next, m2 += 1;
      f.allBuffers = y2, Y0(t, e, true, e.length, f, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
    } else {
      for (;r; ) {
        var { chunk: M2, encoding: x3, callback: S } = r, E3 = e.objectMode ? 1 : M2.length;
        if (Y0(t, e, false, E3, M2, x3, S), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  ht2.prototype._write = function(t, e, r) {
    r(new L6("_write()"));
  };
  ht2.prototype._writev = null;
  ht2.prototype.end = function(t, e, r) {
    var o2 = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || X6(this, o2, r), this;
  };
  Object.defineProperty(ht2.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function Ac(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function G6(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && ef(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
    });
  }
  function Y6(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function Gf(t, e) {
    var r = Ac(e);
    if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var o2 = t._readableState;
      (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
    }
    return r;
  }
  function X6(t, e, r) {
    e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function J6(t, e, r) {
    var o2 = t.entry;
    for (t.entry = null;o2; ) {
      var f = o2.callback;
      e.pendingcb--, f(r), o2 = o2.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(ht2.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === undefined ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  ht2.prototype.destroy = X0.destroy;
  ht2.prototype._undestroy = X0.undestroy;
  ht2.prototype._destroy = function(t, e) {
    e(t);
  };
});
var hn = T((oI, qc) => {
  var Q6 = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  qc.exports = $r;
  var Bc = th(), eh = J0();
  Ie()($r, Bc);
  for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
    lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
  var Q0, lo, uo;
  function $r(t) {
    if (!(this instanceof $r))
      return new $r(t);
    Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
  }
  Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function eM() {
    this._writableState.ended || process.nextTick(tM, this);
  }
  function tM(t) {
    t.end();
  }
  Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var co = T((Tc) => {
  var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
    switch (t = "" + t, t && t.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function rM(t) {
    if (!t)
      return "utf8";
    for (var e;; )
      switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e)
            return;
          t = ("" + t).toLowerCase(), e = true;
      }
  }
  function iM(t) {
    var e = rM(t);
    if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
      throw new Error("Unknown encoding: " + t);
    return e || t;
  }
  Tc.StringDecoder = Xf;
  function Xf(t) {
    this.encoding = iM(t);
    var e;
    switch (this.encoding) {
      case "utf16le":
        this.text = hM, this.end = uM, e = 4;
        break;
      case "utf8":
        this.fillLast = aM, e = 4;
        break;
      case "base64":
        this.text = lM, this.end = dM, e = 3;
        break;
      default:
        this.write = cM, this.end = pM;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
  }
  Xf.prototype.write = function(t) {
    if (t.length === 0)
      return "";
    var e, r;
    if (this.lastNeed) {
      if (e = this.fillLast(t), e === undefined)
        return "";
      r = this.lastNeed, this.lastNeed = 0;
    } else
      r = 0;
    return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
  };
  Xf.prototype.end = sM;
  Xf.prototype.text = oM;
  Xf.prototype.fillLast = function(t) {
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
  };
  function rh(t) {
    return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
  }
  function nM(t, e, r) {
    var o2 = e.length - 1;
    if (o2 < r)
      return 0;
    var f = rh(e[o2]);
    return f >= 0 ? (f > 0 && (t.lastNeed = f - 1), f) : --o2 < r || f === -2 ? 0 : (f = rh(e[o2]), f >= 0 ? (f > 0 && (t.lastNeed = f - 2), f) : --o2 < r || f === -2 ? 0 : (f = rh(e[o2]), f >= 0 ? (f > 0 && (f === 2 ? f = 0 : t.lastNeed = f - 3), f) : 0));
  }
  function fM(t, e, r) {
    if ((e[0] & 192) !== 128)
      return t.lastNeed = 0, "�";
    if (t.lastNeed > 1 && e.length > 1) {
      if ((e[1] & 192) !== 128)
        return t.lastNeed = 1, "�";
      if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
        return t.lastNeed = 2, "�";
    }
  }
  function aM(t) {
    var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
  }
  function oM(t, e) {
    var r = nM(this, t, e);
    if (!this.lastNeed)
      return t.toString("utf8", e);
    this.lastTotal = r;
    var o2 = t.length - (r - this.lastNeed);
    return t.copy(this.lastChar, 0, o2), t.toString("utf8", e, o2);
  }
  function sM(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + "�" : e;
  }
  function hM(t, e) {
    if ((t.length - e) % 2 === 0) {
      var r = t.toString("utf16le", e);
      if (r) {
        var o2 = r.charCodeAt(r.length - 1);
        if (o2 >= 55296 && o2 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
      }
      return r;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
  }
  function uM(t) {
    var e = t && t.length ? this.write(t) : "";
    if (this.lastNeed) {
      var r = this.lastTotal - this.lastNeed;
      return e + this.lastChar.toString("utf16le", 0, r);
    }
    return e;
  }
  function lM(t, e) {
    var r = (t.length - e) % 3;
    return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
  }
  function dM(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
  }
  function cM(t) {
    return t.toString(this.encoding);
  }
  function pM(t) {
    return t && t.length ? this.write(t) : "";
  }
});
var Jf = {};
Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
var po;
var Qf = R0(() => {
  po = rn(co());
});
var vo = T((hI, Nc) => {
  var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
  function vM(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, o2 = new Array(r), f = 0;f < r; f++)
          o2[f] = arguments[f];
        t.apply(this, o2);
      }
    };
  }
  function bM() {
  }
  function mM(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function Lc(t, e, r) {
    if (typeof e == "function")
      return Lc(t, null, e);
    e || (e = {}), r = vM(r || bM);
    var o2 = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p2 = function() {
      t.writable || y2();
    }, m2 = t._writableState && t._writableState.finished, y2 = function() {
      f = false, m2 = true, o2 || r.call(t);
    }, M2 = t._readableState && t._readableState.endEmitted, x3 = function() {
      o2 = false, M2 = true, f || r.call(t);
    }, S = function(L2) {
      r.call(t, L2);
    }, E3 = function() {
      var L2;
      if (o2 && !M2)
        return (!t._readableState || !t._readableState.ended) && (L2 = new kc), r.call(t, L2);
      if (f && !m2)
        return (!t._writableState || !t._writableState.ended) && (L2 = new kc), r.call(t, L2);
    }, B = function() {
      t.req.on("finish", y2);
    };
    return mM(t) ? (t.on("complete", y2), t.on("abort", E3), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x3), t.on("finish", y2), e.error !== false && t.on("error", S), t.on("close", E3), function() {
      t.removeListener("complete", y2), t.removeListener("abort", E3), t.removeListener("request", B), t.req && t.req.removeListener("finish", y2), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y2), t.removeListener("end", x3), t.removeListener("error", S), t.removeListener("close", E3);
    };
  }
  Nc.exports = Lc;
});
var Pc = T((uI, Dc) => {
  var bo;
  function Ni(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
  function Pi(t, e) {
    return { value: t, done: e };
  }
  function yM(t) {
    var e = t[Di];
    if (e !== null) {
      var r = t[dn].read();
      r !== null && (t[ln] = null, t[Di] = null, t[un] = null, e(Pi(r, false)));
    }
  }
  function wM(t) {
    process.nextTick(yM, t);
  }
  function MM(t, e) {
    return function(r, o2) {
      t.then(function() {
        if (e[mo]) {
          r(Pi(undefined, true));
          return;
        }
        e[nh](r, o2);
      }, o2);
    };
  }
  var _M = Object.getPrototypeOf(function() {
  }), xM = Object.setPrototypeOf((bo = { get stream() {
    return this[dn];
  }, next: function() {
    var e = this, r = this[ea];
    if (r !== null)
      return Promise.reject(r);
    if (this[mo])
      return Promise.resolve(Pi(undefined, true));
    if (this[dn].destroyed)
      return new Promise(function(m2, y2) {
        process.nextTick(function() {
          e[ea] ? y2(e[ea]) : m2(Pi(undefined, true));
        });
      });
    var o2 = this[ln], f;
    if (o2)
      f = new Promise(MM(o2, this));
    else {
      var p2 = this[dn].read();
      if (p2 !== null)
        return Promise.resolve(Pi(p2, false));
      f = new Promise(this[nh]);
    }
    return this[ln] = f, f;
  } }, Ni(bo, Symbol.asyncIterator, function() {
    return this;
  }), Ni(bo, "return", function() {
    var e = this;
    return new Promise(function(r, o2) {
      e[dn].destroy(null, function(f) {
        if (f) {
          o2(f);
          return;
        }
        r(Pi(undefined, true));
      });
    });
  }), bo), _M), SM = function(e) {
    var r, o2 = Object.create(xM, (r = {}, Ni(r, dn, { value: e, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p2, m2) {
      var y2 = o2[dn].read();
      y2 ? (o2[ln] = null, o2[Di] = null, o2[un] = null, p2(Pi(y2, false))) : (o2[Di] = p2, o2[un] = m2);
    }, writable: true }), r));
    return o2[ln] = null, gM(e, function(f) {
      if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var p2 = o2[un];
        p2 !== null && (o2[ln] = null, o2[Di] = null, o2[un] = null, p2(f)), o2[ea] = f;
        return;
      }
      var m2 = o2[Di];
      m2 !== null && (o2[ln] = null, o2[Di] = null, o2[un] = null, m2(Pi(undefined, true))), o2[mo] = true;
    }), e.on("readable", wM.bind(null, o2)), o2;
  };
  Dc.exports = SM;
});
var Oc = T((lI, Cc) => {
  Cc.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var th = T((cI, $c) => {
  $c.exports = Ce;
  var tf;
  Ce.ReadableState = Hc;
  var dI = ki().EventEmitter, zc = function(e, r) {
    return e.listeners(r).length;
  }, ra = W0(), go = Ut2().Buffer, EM = global.Uint8Array || function() {
  };
  function AM(t) {
    return go.from(t);
  }
  function RM(t) {
    return go.isBuffer(t) || t instanceof EM;
  }
  var fh = $f(), Ne;
  fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
  };
  var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
  Ie()(Ce, ra);
  var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
  function DM(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function Hc(t, e, r) {
    tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
  }
  function Ce(t) {
    if (tf = tf || hn(), !(this instanceof Ce))
      return new Ce(t);
    var e = this instanceof tf;
    this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
  }
  Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === undefined ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  Ce.prototype.destroy = dh.destroy;
  Ce.prototype._undestroy = dh.undestroy;
  Ce.prototype._destroy = function(t, e) {
    e(t);
  };
  Ce.prototype.push = function(t, e) {
    var r = this._readableState, o2;
    return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o2 = true), Wc(this, t, e, false, o2);
  };
  Ce.prototype.unshift = function(t) {
    return Wc(this, t, null, true, false);
  };
  function Wc(t, e, r, o2, f) {
    Ne("readableAddChunk", e);
    var p2 = t._readableState;
    if (e === null)
      p2.reading = false, OM(t, p2);
    else {
      var m2;
      if (f || (m2 = PM(p2, e)), m2)
        ta(t, m2);
      else if (p2.objectMode || e && e.length > 0)
        if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o2)
          p2.endEmitted ? ta(t, new NM) : hh(t, p2, e, true);
        else if (p2.ended)
          ta(t, new kM);
        else {
          if (p2.destroyed)
            return false;
          p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? hh(t, p2, e, false) : lh(t, p2)) : hh(t, p2, e, false);
        }
      else
        o2 || (p2.reading = false, lh(t, p2));
    }
    return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
  }
  function hh(t, e, r, o2) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
  }
  function PM(t, e) {
    var r;
    return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  Ce.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Ce.prototype.setEncoding = function(t) {
    rf || (rf = (Qf(), ur(Jf)).StringDecoder);
    var e = new rf(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
      o2 += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
  };
  var Fc = 1073741824;
  function CM(t) {
    return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function Uc(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  Ce.prototype.read = function(t) {
    Ne("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
    if (t = Uc(t, e), t === 0 && e.ended)
      return e.length === 0 && uh(this), null;
    var o2 = e.needReadable;
    Ne("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Ne("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, Ne("reading or ended", o2)) : o2 && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc(r, e)));
    var f;
    return t > 0 ? f = Zc(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f !== null && this.emit("data", f), f;
  };
  function OM(t, e) {
    if (Ne("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
    }
  }
  function wo(t) {
    var e = t._readableState;
    Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
  }
  function Kc(t) {
    var e = t._readableState;
    Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
  }
  function lh(t, e) {
    e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
  }
  function FM(t, e) {
    for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Ce.prototype._read = function(t) {
    ta(this, new LM("_read()"));
  };
  Ce.prototype.pipe = function(t, e) {
    var r = this, o2 = this._readableState;
    switch (o2.pipesCount) {
      case 0:
        o2.pipes = t;
        break;
      case 1:
        o2.pipes = [o2.pipes, t];
        break;
      default:
        o2.pipes.push(t);
        break;
    }
    o2.pipesCount += 1, Ne("pipe count=%d opts=%j", o2.pipesCount, e);
    var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f ? y2 : ge;
    o2.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
    function m2(_e, N3) {
      Ne("onunpipe"), _e === r && N3 && N3.hasUnpiped === false && (N3.hasUnpiped = true, S());
    }
    function y2() {
      Ne("onend"), t.end();
    }
    var M2 = UM(r);
    t.on("drain", M2);
    var x3 = false;
    function S() {
      Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L2), t.removeListener("drain", M2), t.removeListener("error", B), t.removeListener("unpipe", m2), r.removeListener("end", y2), r.removeListener("end", ge), r.removeListener("data", E3), x3 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M2();
    }
    r.on("data", E3);
    function E3(_e) {
      Ne("ondata");
      var N3 = t.write(_e);
      Ne("dest.write", N3), N3 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Vc(o2.pipes, t) !== -1) && !x3 && (Ne("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
    }
    function B(_e) {
      Ne("onerror", _e), ge(), t.removeListener("error", B), zc(t, "error") === 0 && ta(t, _e);
    }
    DM(t, "error", B);
    function q() {
      t.removeListener("finish", L2), ge();
    }
    t.once("close", q);
    function L2() {
      Ne("onfinish"), t.removeListener("close", q), ge();
    }
    t.once("finish", L2);
    function ge() {
      Ne("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), o2.flowing || (Ne("pipe resume"), r.resume()), t;
  };
  function UM(t) {
    return function() {
      var r = t._readableState;
      Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
    };
  }
  Ce.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var { pipes: o2, pipesCount: f } = e;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var p2 = 0;p2 < f; p2++)
        o2[p2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var m2 = Vc(e.pipes, t);
    return m2 === -1 ? this : (e.pipes.splice(m2, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  Ce.prototype.on = function(t, e) {
    var r = ra.prototype.on.call(this, t, e), o2 = this._readableState;
    return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Ne("on readable", o2.length, o2.reading), o2.length ? wo(this) : o2.reading || process.nextTick(zM, this)), r;
  };
  Ce.prototype.addListener = Ce.prototype.on;
  Ce.prototype.removeListener = function(t, e) {
    var r = ra.prototype.removeListener.call(this, t, e);
    return t === "readable" && process.nextTick(jc, this), r;
  };
  Ce.prototype.removeAllListeners = function(t) {
    var e = ra.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
  };
  function jc(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function zM(t) {
    Ne("readable nexttick read 0"), t.read(0);
  }
  Ce.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
  };
  function HM(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
  }
  function WM(t, e) {
    Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
  }
  Ce.prototype.pause = function() {
    return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function ch(t) {
    var e = t._readableState;
    for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
      ;
  }
  Ce.prototype.wrap = function(t) {
    var e = this, r = this._readableState, o2 = false;
    t.on("end", function() {
      if (Ne("wrapped end"), r.decoder && !r.ended) {
        var m2 = r.decoder.end();
        m2 && m2.length && e.push(m2);
      }
      e.push(null);
    }), t.on("data", function(m2) {
      if (Ne("wrapped data"), r.decoder && (m2 = r.decoder.write(m2)), !(r.objectMode && m2 == null) && !(!r.objectMode && (!m2 || !m2.length))) {
        var y2 = e.push(m2);
        y2 || (o2 = true, t.pause());
      }
    });
    for (var f in t)
      this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y2) {
        return function() {
          return t[y2].apply(t, arguments);
        };
      }(f));
    for (var p2 = 0;p2 < sh.length; p2++)
      t.on(sh[p2], this.emit.bind(this, sh[p2]));
    return this._read = function(m2) {
      Ne("wrapped _read", m2), o2 && (o2 = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
    return ah === undefined && (ah = Pc()), ah(this);
  });
  Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  Ce._fromList = Zc;
  Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Zc(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function uh(t) {
    var e = t._readableState;
    Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
  }
  function KM(t, e) {
    if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (Ce.from = function(t, e) {
    return oh === undefined && (oh = Oc()), oh(Ce, t, e);
  });
  function Vc(t, e) {
    for (var r = 0, o2 = t.length;r < o2; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var ph = T((pI, Yc) => {
  Yc.exports = di;
  var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
  Ie()(di, _o);
  function GM(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var o2 = r.writecb;
    if (o2 === null)
      return this.emit("error", new ZM);
    r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
    var f = this._readableState;
    f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
  }
  function di(t) {
    if (!(this instanceof di))
      return new di(t);
    _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
  }
  function YM() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Gc(t, e, r);
    }) : Gc(this, null, null);
  }
  di.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
  };
  di.prototype._transform = function(t, e, r) {
    r(new jM("_transform()"));
  };
  di.prototype._write = function(t, e, r) {
    var o2 = this._transformState;
    if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
      var f = this._readableState;
      (o2.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
  };
  di.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  di.prototype._destroy = function(t, e) {
    _o.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Gc(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new $M;
    if (t._transformState.transforming)
      throw new VM;
    return t.push(null);
  }
});
var Qc = T((vI, Jc) => {
  Jc.exports = ia;
  var Xc = ph();
  Ie()(ia, Xc);
  function ia(t) {
    if (!(this instanceof ia))
      return new ia(t);
    Xc.call(this, t);
  }
  ia.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var np = T((bI, ip) => {
  var vh;
  function XM(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(undefined, arguments));
    };
  }
  var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
  function ep(t) {
    if (t)
      throw t;
  }
  function e4(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function t4(t, e, r, o2) {
    o2 = XM(o2);
    var f = false;
    t.on("close", function() {
      f = true;
    }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m2) {
      if (m2)
        return o2(m2);
      f = true, o2();
    });
    var p2 = false;
    return function(m2) {
      if (!f && !p2) {
        if (p2 = true, e4(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        o2(m2 || new QM("pipe"));
      }
    };
  }
  function tp(t) {
    t();
  }
  function r4(t, e) {
    return t.pipe(e);
  }
  function i4(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
  }
  function n4() {
    for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
      e[r] = arguments[r];
    var o2 = i4(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new JM("streams");
    var f, p2 = e.map(function(m2, y2) {
      var M2 = y2 < e.length - 1, x3 = y2 > 0;
      return t4(m2, M2, x3, function(S) {
        f || (f = S), S && p2.forEach(tp), !M2 && (p2.forEach(tp), o2(f));
      });
    });
    return e.reduce(r4);
  }
  ip.exports = n4;
});
var ap = T((cr, fp) => {
  cr = fp.exports = th();
  cr.Stream = cr;
  cr.Readable = cr;
  cr.Writable = J0();
  cr.Duplex = hn();
  cr.Transform = ph();
  cr.PassThrough = Qc();
  cr.finished = vo();
  cr.pipeline = np();
});
var bh = T((mI, sp) => {
  var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
  function a4(t, e) {
    if (!xo.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function Ci(t) {
    op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  f4(Ci, op);
  Ci.prototype._transform = function(t, e, r) {
    var o2 = null;
    try {
      this.update(t, e);
    } catch (f) {
      o2 = f;
    }
    r(o2);
  };
  Ci.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Ci.prototype.update = function(t, e) {
    if (a4(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    xo.isBuffer(t) || (t = xo.from(t, e));
    for (var r = this._block, o2 = 0;this._blockOffset + t.length - o2 >= this._blockSize; ) {
      for (var f = this._blockOffset;f < this._blockSize; )
        r[f++] = t[o2++];
      this._update(), this._blockOffset = 0;
    }
    for (;o2 < t.length; )
      r[this._blockOffset++] = t[o2++];
    for (var p2 = 0, m2 = t.length * 8;m2 > 0; ++p2)
      this._length[p2] += m2, m2 = this._length[p2] / 4294967296 | 0, m2 > 0 && (this._length[p2] -= 4294967296 * m2);
    return this;
  };
  Ci.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  Ci.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0;r < 4; ++r)
      this._length[r] = 0;
    return e;
  };
  Ci.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  sp.exports = Ci;
});
var Ao = T((gI, up) => {
  var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
  function So() {
    hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  o4(So, hp);
  So.prototype._update = function() {
    for (var t = h4, e = 0;e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, o2 = this._b, f = this._c, p2 = this._d;
    r = jt(r, o2, f, p2, t[0], 3614090360, 7), p2 = jt(p2, r, o2, f, t[1], 3905402710, 12), f = jt(f, p2, r, o2, t[2], 606105819, 17), o2 = jt(o2, f, p2, r, t[3], 3250441966, 22), r = jt(r, o2, f, p2, t[4], 4118548399, 7), p2 = jt(p2, r, o2, f, t[5], 1200080426, 12), f = jt(f, p2, r, o2, t[6], 2821735955, 17), o2 = jt(o2, f, p2, r, t[7], 4249261313, 22), r = jt(r, o2, f, p2, t[8], 1770035416, 7), p2 = jt(p2, r, o2, f, t[9], 2336552879, 12), f = jt(f, p2, r, o2, t[10], 4294925233, 17), o2 = jt(o2, f, p2, r, t[11], 2304563134, 22), r = jt(r, o2, f, p2, t[12], 1804603682, 7), p2 = jt(p2, r, o2, f, t[13], 4254626195, 12), f = jt(f, p2, r, o2, t[14], 2792965006, 17), o2 = jt(o2, f, p2, r, t[15], 1236535329, 22), r = Zt(r, o2, f, p2, t[1], 4129170786, 5), p2 = Zt(p2, r, o2, f, t[6], 3225465664, 9), f = Zt(f, p2, r, o2, t[11], 643717713, 14), o2 = Zt(o2, f, p2, r, t[0], 3921069994, 20), r = Zt(r, o2, f, p2, t[5], 3593408605, 5), p2 = Zt(p2, r, o2, f, t[10], 38016083, 9), f = Zt(f, p2, r, o2, t[15], 3634488961, 14), o2 = Zt(o2, f, p2, r, t[4], 3889429448, 20), r = Zt(r, o2, f, p2, t[9], 568446438, 5), p2 = Zt(p2, r, o2, f, t[14], 3275163606, 9), f = Zt(f, p2, r, o2, t[3], 4107603335, 14), o2 = Zt(o2, f, p2, r, t[8], 1163531501, 20), r = Zt(r, o2, f, p2, t[13], 2850285829, 5), p2 = Zt(p2, r, o2, f, t[2], 4243563512, 9), f = Zt(f, p2, r, o2, t[7], 1735328473, 14), o2 = Zt(o2, f, p2, r, t[12], 2368359562, 20), r = Vt(r, o2, f, p2, t[5], 4294588738, 4), p2 = Vt(p2, r, o2, f, t[8], 2272392833, 11), f = Vt(f, p2, r, o2, t[11], 1839030562, 16), o2 = Vt(o2, f, p2, r, t[14], 4259657740, 23), r = Vt(r, o2, f, p2, t[1], 2763975236, 4), p2 = Vt(p2, r, o2, f, t[4], 1272893353, 11), f = Vt(f, p2, r, o2, t[7], 4139469664, 16), o2 = Vt(o2, f, p2, r, t[10], 3200236656, 23), r = Vt(r, o2, f, p2, t[13], 681279174, 4), p2 = Vt(p2, r, o2, f, t[0], 3936430074, 11), f = Vt(f, p2, r, o2, t[3], 3572445317, 16), o2 = Vt(o2, f, p2, r, t[6], 76029189, 23), r = Vt(r, o2, f, p2, t[9], 3654602809, 4), p2 = Vt(p2, r, o2, f, t[12], 3873151461, 11), f = Vt(f, p2, r, o2, t[15], 530742520, 16), o2 = Vt(o2, f, p2, r, t[2], 3299628645, 23), r = $t(r, o2, f, p2, t[0], 4096336452, 6), p2 = $t(p2, r, o2, f, t[7], 1126891415, 10), f = $t(f, p2, r, o2, t[14], 2878612391, 15), o2 = $t(o2, f, p2, r, t[5], 4237533241, 21), r = $t(r, o2, f, p2, t[12], 1700485571, 6), p2 = $t(p2, r, o2, f, t[3], 2399980690, 10), f = $t(f, p2, r, o2, t[10], 4293915773, 15), o2 = $t(o2, f, p2, r, t[1], 2240044497, 21), r = $t(r, o2, f, p2, t[8], 1873313359, 6), p2 = $t(p2, r, o2, f, t[15], 4264355552, 10), f = $t(f, p2, r, o2, t[6], 2734768916, 15), o2 = $t(o2, f, p2, r, t[13], 1309151649, 21), r = $t(r, o2, f, p2, t[4], 4149444226, 6), p2 = $t(p2, r, o2, f, t[11], 3174756917, 10), f = $t(f, p2, r, o2, t[2], 718787259, 15), o2 = $t(o2, f, p2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o2 | 0, this._c = this._c + f | 0, this._d = this._d + p2 | 0;
  };
  So.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = s4.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function Eo(t, e) {
    return t << e | t >>> 32 - e;
  }
  function jt(t, e, r, o2, f, p2, m2) {
    return Eo(t + (e & r | ~e & o2) + f + p2 | 0, m2) + e | 0;
  }
  function Zt(t, e, r, o2, f, p2, m2) {
    return Eo(t + (e & o2 | r & ~o2) + f + p2 | 0, m2) + e | 0;
  }
  function Vt(t, e, r, o2, f, p2, m2) {
    return Eo(t + (e ^ r ^ o2) + f + p2 | 0, m2) + e | 0;
  }
  function $t(t, e, r, o2, f, p2, m2) {
    return Eo(t + (r ^ (e | ~o2)) + f + p2 | 0, m2) + e | 0;
  }
  up.exports = So;
});
var Bo = T((yI, mp) => {
  var mh = Ut2().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function Ro() {
    bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  u4(Ro, bp);
  Ro.prototype._update = function() {
    for (var t = l4, e = 0;e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, o2 = this._b | 0, f = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y2 = this._a | 0, M2 = this._b | 0, x3 = this._c | 0, S = this._d | 0, E3 = this._e | 0, B = 0;B < 80; B += 1) {
      var q, L2;
      B < 16 ? (q = lp(r, o2, f, p2, m2, t[na[B]], sa[0], aa[B]), L2 = vp(y2, M2, x3, S, E3, t[fa[B]], ha[0], oa[B])) : B < 32 ? (q = dp(r, o2, f, p2, m2, t[na[B]], sa[1], aa[B]), L2 = pp(y2, M2, x3, S, E3, t[fa[B]], ha[1], oa[B])) : B < 48 ? (q = cp(r, o2, f, p2, m2, t[na[B]], sa[2], aa[B]), L2 = cp(y2, M2, x3, S, E3, t[fa[B]], ha[2], oa[B])) : B < 64 ? (q = pp(r, o2, f, p2, m2, t[na[B]], sa[3], aa[B]), L2 = dp(y2, M2, x3, S, E3, t[fa[B]], ha[3], oa[B])) : (q = vp(r, o2, f, p2, m2, t[na[B]], sa[4], aa[B]), L2 = lp(y2, M2, x3, S, E3, t[fa[B]], ha[4], oa[B])), r = m2, m2 = p2, p2 = cn(f, 10), f = o2, o2 = q, y2 = E3, E3 = S, S = cn(x3, 10), x3 = M2, M2 = L2;
    }
    var ge = this._b + f + S | 0;
    this._b = this._c + p2 + E3 | 0, this._c = this._d + m2 + y2 | 0, this._d = this._e + r + M2 | 0, this._e = this._a + o2 + x3 | 0, this._a = ge;
  };
  Ro.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = mh.alloc ? mh.alloc(20) : new mh(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function cn(t, e) {
    return t << e | t >>> 32 - e;
  }
  function lp(t, e, r, o2, f, p2, m2, y2) {
    return cn(t + (e ^ r ^ o2) + p2 + m2 | 0, y2) + f | 0;
  }
  function dp(t, e, r, o2, f, p2, m2, y2) {
    return cn(t + (e & r | ~e & o2) + p2 + m2 | 0, y2) + f | 0;
  }
  function cp(t, e, r, o2, f, p2, m2, y2) {
    return cn(t + ((e | ~r) ^ o2) + p2 + m2 | 0, y2) + f | 0;
  }
  function pp(t, e, r, o2, f, p2, m2, y2) {
    return cn(t + (e & o2 | r & ~o2) + p2 + m2 | 0, y2) + f | 0;
  }
  function vp(t, e, r, o2, f, p2, m2, y2) {
    return cn(t + (e ^ (r | ~o2)) + p2 + m2 | 0, y2) + f | 0;
  }
  mp.exports = Ro;
});
var pn = T((wI, yp) => {
  var gp = Te().Buffer;
  function qo(t, e) {
    this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  qo.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
    for (var r = this._block, o2 = this._blockSize, f = t.length, p2 = this._len, m2 = 0;m2 < f; ) {
      for (var y2 = p2 % o2, M2 = Math.min(f - m2, o2 - y2), x3 = 0;x3 < M2; x3++)
        r[y2 + x3] = t[m2 + x3];
      p2 += M2, m2 += M2, p2 % o2 === 0 && this._update(r);
    }
    return this._len += f, this;
  };
  qo.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295)
      this._block.writeUInt32BE(r, this._blockSize - 4);
    else {
      var o2 = (r & 4294967295) >>> 0, f = (r - o2) / 4294967296;
      this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(o2, this._blockSize - 4);
    }
    this._update(this._block);
    var p2 = this._hash();
    return t ? p2.toString(t) : p2;
  };
  qo.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  yp.exports = qo;
});
var _p = T((MI, Mp) => {
  var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v42 = new Array(80);
  function ua() {
    this.init(), this._w = v42, wp.call(this, 64, 56);
  }
  d4(ua, wp);
  ua.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function b4(t) {
    return t << 5 | t >>> 27;
  }
  function m4(t) {
    return t << 30 | t >>> 2;
  }
  function g4(t, e, r, o2) {
    return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
  }
  ua.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y2 = 0;y2 < 16; ++y2)
      e[y2] = t.readInt32BE(y2 * 4);
    for (;y2 < 80; ++y2)
      e[y2] = e[y2 - 3] ^ e[y2 - 8] ^ e[y2 - 14] ^ e[y2 - 16];
    for (var M2 = 0;M2 < 80; ++M2) {
      var x3 = ~~(M2 / 20), S = b4(r) + g4(x3, o2, f, p2) + m2 + e[M2] + p4[x3] | 0;
      m2 = p2, p2 = f, f = m4(o2), o2 = r, r = S;
    }
    this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0;
  };
  ua.prototype._hash = function() {
    var t = c4.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Mp.exports = ua;
});
var Ep = T((_I, Sp) => {
  var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
  function la() {
    this.init(), this._w = _4, xp.call(this, 64, 56);
  }
  y4(la, xp);
  la.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function x4(t) {
    return t << 1 | t >>> 31;
  }
  function S4(t) {
    return t << 5 | t >>> 27;
  }
  function E4(t) {
    return t << 30 | t >>> 2;
  }
  function A4(t, e, r, o2) {
    return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
  }
  la.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y2 = 0;y2 < 16; ++y2)
      e[y2] = t.readInt32BE(y2 * 4);
    for (;y2 < 80; ++y2)
      e[y2] = x4(e[y2 - 3] ^ e[y2 - 8] ^ e[y2 - 14] ^ e[y2 - 16]);
    for (var M2 = 0;M2 < 80; ++M2) {
      var x3 = ~~(M2 / 20), S = S4(r) + A4(x3, o2, f, p2) + m2 + e[M2] + M4[x3] | 0;
      m2 = p2, p2 = f, f = E4(o2), o2 = r, r = S;
    }
    this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0;
  };
  la.prototype._hash = function() {
    var t = w4.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Sp.exports = la;
});
var gh = T((xI, Rp) => {
  var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
  function da() {
    this.init(), this._w = I4, Ap.call(this, 64, 56);
  }
  R4(da, Ap);
  da.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function T4(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function k4(t, e, r) {
    return t & e | r & (t | e);
  }
  function L4(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function N4(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function D4(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function P4(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  da.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y2 = this._f | 0, M2 = this._g | 0, x3 = this._h | 0, S = 0;S < 16; ++S)
      e[S] = t.readInt32BE(S * 4);
    for (;S < 64; ++S)
      e[S] = P4(e[S - 2]) + e[S - 7] + D4(e[S - 15]) + e[S - 16] | 0;
    for (var E3 = 0;E3 < 64; ++E3) {
      var B = x3 + N4(m2) + T4(m2, y2, M2) + q4[E3] + e[E3] | 0, q = L4(r) + k4(r, o2, f) | 0;
      x3 = M2, M2 = y2, y2 = m2, m2 = p2 + B | 0, p2 = f, f = o2, o2 = r, r = B + q | 0;
    }
    this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0, this._f = y2 + this._f | 0, this._g = M2 + this._g | 0, this._h = x3 + this._h | 0;
  };
  da.prototype._hash = function() {
    var t = B4.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  Rp.exports = da;
});
var qp = T((SI, Bp) => {
  var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
  function Io() {
    this.init(), this._w = z4, F4.call(this, 64, 56);
  }
  C4(Io, O4);
  Io.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  Io.prototype._hash = function() {
    var t = U4.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  Bp.exports = Io;
});
var yh = T((EI, Pp) => {
  var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
  function ca() {
    this.init(), this._w = K4, Dp.call(this, 128, 112);
  }
  H4(ca, Dp);
  ca.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function Tp(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function kp(t, e, r) {
    return t & e | r & (t | e);
  }
  function Lp(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function Np(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function j4(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function Z4(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function V4(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function $4(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function Pt(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  ca.prototype._update = function(t) {
    for (var e = this._w, r = this._ah | 0, o2 = this._bh | 0, f = this._ch | 0, p2 = this._dh | 0, m2 = this._eh | 0, y2 = this._fh | 0, M2 = this._gh | 0, x3 = this._hh | 0, S = this._al | 0, E3 = this._bl | 0, B = this._cl | 0, q = this._dl | 0, L2 = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N3 = this._hl | 0, we = 0;we < 32; we += 2)
      e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
    for (;we < 160; we += 2) {
      var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
      ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
      var Ae2 = V4(ye, xe), P3 = $4(xe, ye), Se2 = e[we - 7 * 2], v3 = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a2 = e[we - 16 * 2 + 1], h2 = Ee + v3 | 0, s = Re + Se2 + Pt(h2, Ee) | 0;
      h2 = h2 + P3 | 0, s = s + Ae2 + Pt(h2, P3) | 0, h2 = h2 + a2 | 0, s = s + i + Pt(h2, a2) | 0, e[we] = s, e[we + 1] = h2;
    }
    for (var u = 0;u < 160; u += 2) {
      s = e[u], h2 = e[u + 1];
      var c = kp(r, o2, f), b3 = kp(S, E3, B), l2 = Lp(r, S), n = Lp(S, r), d2 = Np(m2, L2), w3 = Np(L2, m2), g2 = Ip[u], _2 = Ip[u + 1], A2 = Tp(m2, y2, M2), R3 = Tp(L2, ge, _e), I = N3 + w3 | 0, Me = x3 + d2 + Pt(I, N3) | 0;
      I = I + R3 | 0, Me = Me + A2 + Pt(I, R3) | 0, I = I + _2 | 0, Me = Me + g2 + Pt(I, _2) | 0, I = I + h2 | 0, Me = Me + s + Pt(I, h2) | 0;
      var k = n + b3 | 0, D2 = l2 + c + Pt(k, n) | 0;
      x3 = M2, N3 = _e, M2 = y2, _e = ge, y2 = m2, ge = L2, L2 = q + I | 0, m2 = p2 + Me + Pt(L2, q) | 0, p2 = f, q = B, f = o2, B = E3, o2 = r, E3 = S, S = I + k | 0, r = Me + D2 + Pt(S, I) | 0;
    }
    this._al = this._al + S | 0, this._bl = this._bl + E3 | 0, this._cl = this._cl + B | 0, this._dl = this._dl + q | 0, this._el = this._el + L2 | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N3 | 0, this._ah = this._ah + r + Pt(this._al, S) | 0, this._bh = this._bh + o2 + Pt(this._bl, E3) | 0, this._ch = this._ch + f + Pt(this._cl, B) | 0, this._dh = this._dh + p2 + Pt(this._dl, q) | 0, this._eh = this._eh + m2 + Pt(this._el, L2) | 0, this._fh = this._fh + y2 + Pt(this._fl, ge) | 0, this._gh = this._gh + M2 + Pt(this._gl, _e) | 0, this._hh = this._hh + x3 + Pt(this._hl, N3) | 0;
  };
  ca.prototype._hash = function() {
    var t = W4.allocUnsafe(64);
    function e(r, o2, f) {
      t.writeInt32BE(r, f), t.writeInt32BE(o2, f + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  Pp.exports = ca;
});
var Op = T((AI, Cp) => {
  var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
  function To() {
    this.init(), this._w = Q4, X4.call(this, 128, 112);
  }
  G4(To, Y4);
  To.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  To.prototype._hash = function() {
    var t = J4.allocUnsafe(48);
    function e(r, o2, f) {
      t.writeInt32BE(r, f), t.writeInt32BE(o2, f + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  Cp.exports = To;
});
var ko = T((ci, Fp) => {
  var ci = Fp.exports = function(e) {
    e = e.toLowerCase();
    var r = ci[e];
    if (!r)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r;
  };
  ci.sha = _p();
  ci.sha1 = Ep();
  ci.sha224 = qp();
  ci.sha256 = gh();
  ci.sha384 = Op();
  ci.sha512 = yh();
});
var Tt2 = T((RI, Up) => {
  Up.exports = { ArrayIsArray(t) {
    return Array.isArray(t);
  }, ArrayPrototypeIncludes(t, e) {
    return t.includes(e);
  }, ArrayPrototypeIndexOf(t, e) {
    return t.indexOf(e);
  }, ArrayPrototypeJoin(t, e) {
    return t.join(e);
  }, ArrayPrototypeMap(t, e) {
    return t.map(e);
  }, ArrayPrototypePop(t, e) {
    return t.pop(e);
  }, ArrayPrototypePush(t, e) {
    return t.push(e);
  }, ArrayPrototypeSlice(t, e, r) {
    return t.slice(e, r);
  }, Error, FunctionPrototypeCall(t, e, ...r) {
    return t.call(e, ...r);
  }, FunctionPrototypeSymbolHasInstance(t, e) {
    return Function.prototype[Symbol.hasInstance].call(t, e);
  }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
    return Object.defineProperties(t, e);
  }, ObjectDefineProperty(t, e, r) {
    return Object.defineProperty(t, e, r);
  }, ObjectGetOwnPropertyDescriptor(t, e) {
    return Object.getOwnPropertyDescriptor(t, e);
  }, ObjectKeys(t) {
    return Object.keys(t);
  }, ObjectSetPrototypeOf(t, e) {
    return Object.setPrototypeOf(t, e);
  }, Promise, PromisePrototypeCatch(t, e) {
    return t.catch(e);
  }, PromisePrototypeThen(t, e, r) {
    return t.then(e, r);
  }, PromiseReject(t) {
    return Promise.reject(t);
  }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
    return t.test(e);
  }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
    return t.slice(e, r);
  }, StringPrototypeToLowerCase(t) {
    return t.toLowerCase();
  }, StringPrototypeToUpperCase(t) {
    return t.toUpperCase();
  }, StringPrototypeTrim(t) {
    return t.trim();
  }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
    return t.set(e, r);
  }, Uint8Array };
});
var Gr = T((BI, Mh) => {
  var e_ = Ut2(), t_ = Object.getPrototypeOf(async function() {
  }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
    return e instanceof zp;
  } : function(e) {
    return false;
  }, wh = class extends Error {
    constructor(e) {
      if (!Array.isArray(e))
        throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
      let r = "";
      for (let o2 = 0;o2 < e.length; o2++)
        r += `    ${e[o2].stack}
`;
      super(r), this.name = "AggregateError", this.errors = e;
    }
  };
  Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
    let e = false;
    return function(...r) {
      e || (e = true, t.apply(this, r));
    };
  }, createDeferredPromise: function() {
    let t, e;
    return { promise: new Promise((o2, f) => {
      t = o2, e = f;
    }), resolve: t, reject: e };
  }, promisify(t) {
    return new Promise((e, r) => {
      t((o2, ...f) => o2 ? r(o2) : e(...f));
    });
  }, debuglog() {
    return function() {
    };
  }, format(t, ...e) {
    return t.replace(/%([sdifj])/g, function(...[r, o2]) {
      let f = e.shift();
      return o2 === "f" ? f.toFixed(6) : o2 === "j" ? JSON.stringify(f) : o2 === "s" && typeof f == "object" ? `${f.constructor !== Object ? f.constructor.name : ""} {}`.trim() : f.toString();
    });
  }, inspect(t) {
    switch (typeof t) {
      case "string":
        if (t.includes("'"))
          if (t.includes('"')) {
            if (!t.includes("`") && !t.includes("${"))
              return `\`${t}\``;
          } else
            return `"${t}"`;
        return `'${t}'`;
      case "number":
        return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
      case "bigint":
        return `${String(t)}n`;
      case "boolean":
      case "undefined":
        return String(t);
      case "object":
        return "{}";
    }
  }, types: { isAsyncFunction(t) {
    return t instanceof t_;
  }, isArrayBufferView(t) {
    return ArrayBuffer.isView(t);
  } }, isBlob: r_ };
  Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});
var No = T((qI, Lo) => {
  var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
  Lo.exports = Hp;
  Lo.exports.AbortSignal = i_;
  Lo.exports.default = Hp;
});
var Jt = T((II, jp) => {
  var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
  function vn(t, e) {
    if (!t)
      throw new Po.ERR_INTERNAL_ASSERTION(e);
  }
  function Wp(t) {
    let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
    for (;r >= o2 + 4; r -= 3)
      e = `_${t.slice(r - 3, r)}${e}`;
    return `${t.slice(0, r)}${e}`;
  }
  function l_(t, e, r) {
    if (typeof e == "function")
      return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
    let o2 = (e.match(/%[dfijoOs]/g) || []).length;
    return vn(o2 === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o2}).`), r.length === 0 ? e : n_(e, ...r);
  }
  function zt(t, e, r) {
    r || (r = Error);

    class o2 extends r {
      constructor(...p2) {
        super(l_(t, e, p2));
      }
      toString() {
        return `${this.name} [${t}]: ${this.message}`;
      }
    }
    Object.defineProperties(o2.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
      return `${this.name} [${t}]: ${this.message}`;
    }, writable: true, enumerable: false, configurable: true } }), o2.prototype.code = t, o2.prototype[o_] = true, Po[t] = o2;
  }
  function Kp(t) {
    let e = u_ + t.name;
    return Object.defineProperty(t, "name", { value: e }), t;
  }
  function d_(t, e) {
    if (t && e && t !== e) {
      if (Array.isArray(e.errors))
        return e.errors.push(t), e;
      let r = new a_([e, t], e.message);
      return r.code = e.code, r;
    }
    return t || e;
  }
  var _h = class extends Error {
    constructor(e = "The operation was aborted", r = undefined) {
      if (r !== undefined && typeof r != "object")
        throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
      super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  zt("ERR_ASSERTION", "%s", Error);
  zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
    vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
    let o2 = "The ";
    t.endsWith(" argument") ? o2 += `${t} ` : o2 += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o2 += "must be ";
    let f = [], p2 = [], m2 = [];
    for (let M2 of e)
      vn(typeof M2 == "string", "All expected entries have to be of type string"), s_.includes(M2) ? f.push(M2.toLowerCase()) : h_.test(M2) ? p2.push(M2) : (vn(M2 !== "object", 'The value "object" should be written as "Object"'), m2.push(M2));
    if (p2.length > 0) {
      let M2 = f.indexOf("object");
      M2 !== -1 && (f.splice(f, M2, 1), p2.push("Object"));
    }
    if (f.length > 0) {
      switch (f.length) {
        case 1:
          o2 += `of type ${f[0]}`;
          break;
        case 2:
          o2 += `one of type ${f[0]} or ${f[1]}`;
          break;
        default: {
          let M2 = f.pop();
          o2 += `one of type ${f.join(", ")}, or ${M2}`;
        }
      }
      (p2.length > 0 || m2.length > 0) && (o2 += " or ");
    }
    if (p2.length > 0) {
      switch (p2.length) {
        case 1:
          o2 += `an instance of ${p2[0]}`;
          break;
        case 2:
          o2 += `an instance of ${p2[0]} or ${p2[1]}`;
          break;
        default: {
          let M2 = p2.pop();
          o2 += `an instance of ${p2.join(", ")}, or ${M2}`;
        }
      }
      m2.length > 0 && (o2 += " or ");
    }
    switch (m2.length) {
      case 0:
        break;
      case 1:
        m2[0].toLowerCase() !== m2[0] && (o2 += "an "), o2 += `${m2[0]}`;
        break;
      case 2:
        o2 += `one of ${m2[0]} or ${m2[1]}`;
        break;
      default: {
        let M2 = m2.pop();
        o2 += `one of ${m2.join(", ")}, or ${M2}`;
      }
    }
    if (r == null)
      o2 += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      o2 += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var y2;
      (y2 = r.constructor) !== null && y2 !== undefined && y2.name ? o2 += `. Received an instance of ${r.constructor.name}` : o2 += `. Received ${Do(r, { depth: -1 })}`;
    } else {
      let M2 = Do(r, { colors: false });
      M2.length > 25 && (M2 = `${M2.slice(0, 25)}...`), o2 += `. Received type ${typeof r} (${M2})`;
    }
    return o2;
  }, TypeError);
  zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
    let o2 = Do(e);
    return o2.length > 128 && (o2 = o2.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o2}`;
  }, TypeError);
  zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
    var o2;
    let f = r != null && (o2 = r.constructor) !== null && o2 !== undefined && o2.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${t} to be returned from the "${e}" function but got ${f}.`;
  }, TypeError);
  zt("ERR_MISSING_ARGS", (...t) => {
    vn(t.length > 0, "At least one arg needs to be specified");
    let e, r = t.length;
    switch (t = (Array.isArray(t) ? t : [t]).map((o2) => `"${o2}"`).join(" or "), r) {
      case 1:
        e += `The ${t[0]} argument`;
        break;
      case 2:
        e += `The ${t[0]} and ${t[1]} arguments`;
        break;
      default:
        {
          let o2 = t.pop();
          e += `The ${t.join(", ")}, and ${o2} arguments`;
        }
        break;
    }
    return `${e} must be specified`;
  }, TypeError);
  zt("ERR_OUT_OF_RANGE", (t, e, r) => {
    vn(e, 'Missing "range" argument');
    let o2;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o2 = Wp(String(r)) : typeof r == "bigint" ? (o2 = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o2 = Wp(o2)), o2 += "n") : o2 = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o2}`;
  }, RangeError);
  zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
});
var pa = T((TI, Qp) => {
  var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt2(), { hideStackFrames: Ir2, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
  function R_(t) {
    return t === (t | 0);
  }
  function B_(t) {
    return t === t >>> 0;
  }
  var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
  function T_(t, e, r) {
    if (typeof t > "u" && (t = r), typeof t == "string") {
      if (y_(q_, t) === null)
        throw new Co(e, t, I_);
      t = m_(t, 8);
    }
    return Xp(t, e), t;
  }
  var k_ = Ir2((t, e, r = b_, o2 = v_) => {
    if (typeof t != "number")
      throw new tr(e, "number", t);
    if (!Sh(t))
      throw new bn(e, "an integer", t);
    if (t < r || t > o2)
      throw new bn(e, `>= ${r} && <= ${o2}`, t);
  }), L_ = Ir2((t, e, r = -2147483648, o2 = 2147483647) => {
    if (typeof t != "number")
      throw new tr(e, "number", t);
    if (!Sh(t))
      throw new bn(e, "an integer", t);
    if (t < r || t > o2)
      throw new bn(e, `>= ${r} && <= ${o2}`, t);
  }), Xp = Ir2((t, e, r = false) => {
    if (typeof t != "number")
      throw new tr(e, "number", t);
    if (!Sh(t))
      throw new bn(e, "an integer", t);
    let o2 = r ? 1 : 0, f = 4294967295;
    if (t < o2 || t > f)
      throw new bn(e, `>= ${o2} && <= ${f}`, t);
  });
  function Jp(t, e) {
    if (typeof t != "string")
      throw new tr(e, "string", t);
  }
  function N_(t, e, r = undefined, o2) {
    if (typeof t != "number")
      throw new tr(e, "number", t);
    if (r != null && t < r || o2 != null && t > o2 || (r != null || o2 != null) && p_(t))
      throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o2 != null ? " && " : ""}${o2 != null ? `<= ${o2}` : ""}`, t);
  }
  var D_ = Ir2((t, e, r) => {
    if (!Gp(r, t)) {
      let o2 = Yp(c_(r, (p2) => typeof p2 == "string" ? `'${p2}'` : w_(p2)), ", "), f = "must be one of: " + o2;
      throw new Co(e, t, f);
    }
  });
  function P_(t, e) {
    if (typeof t != "boolean")
      throw new tr(e, "boolean", t);
  }
  function xh(t, e, r) {
    return t == null || !g_(t, e) ? r : t[e];
  }
  var C_ = Ir2((t, e, r = null) => {
    let o2 = xh(r, "allowArray", false), f = xh(r, "allowFunction", false);
    if (!xh(r, "nullable", false) && t === null || !o2 && $p(t) || typeof t != "object" && (!f || typeof t != "function"))
      throw new tr(e, "Object", t);
  }), O_ = Ir2((t, e, r = 0) => {
    if (!$p(t))
      throw new tr(e, "Array", t);
    if (t.length < r) {
      let o2 = `must be longer than ${r}`;
      throw new Co(e, t, o2);
    }
  });
  function F_(t, e = "signal") {
    if (Jp(t, e), Vp[t] === undefined)
      throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
  }
  var U_ = Ir2((t, e = "buffer") => {
    if (!A_(t))
      throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
  });
  function z_(t, e) {
    let r = S_(e), o2 = t.length;
    if (r === "hex" && o2 % 2 !== 0)
      throw new Co("encoding", e, `is invalid for data of length ${o2}`);
  }
  function H_(t, e = "Port", r = true) {
    if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
      throw new x_(e, t, r);
    return t | 0;
  }
  var W_ = Ir2((t, e) => {
    if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
      throw new tr(e, "AbortSignal", t);
  }), K_ = Ir2((t, e) => {
    if (typeof t != "function")
      throw new tr(e, "Function", t);
  }), j_ = Ir2((t, e) => {
    if (typeof t != "function" || E_(t))
      throw new tr(e, "Function", t);
  }), Z_ = Ir2((t, e) => {
    if (t !== undefined)
      throw new tr(e, "undefined", t);
  });
  function V_(t, e, r) {
    if (!Gp(r, t))
      throw new tr(e, `('${Yp(r, "|")}')`, t);
  }
  Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
});
var Rh = T((kI, i1) => {
  var dt2 = i1.exports = {}, Yr, Xr;
  function Eh() {
    throw new Error("setTimeout has not been defined");
  }
  function Ah() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
    } catch {
      Yr = Eh;
    }
    try {
      typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
    } catch {
      Xr = Ah;
    }
  })();
  function e1(t) {
    if (Yr === setTimeout)
      return setTimeout(t, 0);
    if ((Yr === Eh || !Yr) && setTimeout)
      return Yr = setTimeout, setTimeout(t, 0);
    try {
      return Yr(t, 0);
    } catch {
      try {
        return Yr.call(null, t, 0);
      } catch {
        return Yr.call(this, t, 0);
      }
    }
  }
  function $_(t) {
    if (Xr === clearTimeout)
      return clearTimeout(t);
    if ((Xr === Ah || !Xr) && clearTimeout)
      return Xr = clearTimeout, clearTimeout(t);
    try {
      return Xr(t);
    } catch {
      try {
        return Xr.call(null, t);
      } catch {
        return Xr.call(this, t);
      }
    }
  }
  var pi = [], nf = false, mn, Oo = -1;
  function G_() {
    !nf || !mn || (nf = false, mn.length ? pi = mn.concat(pi) : Oo = -1, pi.length && t1());
  }
  function t1() {
    if (!nf) {
      var t = e1(G_);
      nf = true;
      for (var e = pi.length;e; ) {
        for (mn = pi, pi = [];++Oo < e; )
          mn && mn[Oo].run();
        Oo = -1, e = pi.length;
      }
      mn = null, nf = false, $_(t);
    }
  }
  dt2.nextTick = function(t) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r = 1;r < arguments.length; r++)
        e[r - 1] = arguments[r];
    pi.push(new r1(t, e)), pi.length === 1 && !nf && e1(t1);
  };
  function r1(t, e) {
    this.fun = t, this.array = e;
  }
  r1.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  dt2.title = "browser";
  dt2.browser = true;
  dt2.env = {};
  dt2.argv = [];
  dt2.version = "";
  dt2.versions = {};
  function vi() {
  }
  dt2.on = vi;
  dt2.addListener = vi;
  dt2.once = vi;
  dt2.off = vi;
  dt2.removeListener = vi;
  dt2.removeAllListeners = vi;
  dt2.emit = vi;
  dt2.prependListener = vi;
  dt2.prependOnceListener = vi;
  dt2.listeners = function(t) {
    return [];
  };
  dt2.binding = function(t) {
    throw new Error("process.binding is not supported");
  };
  dt2.cwd = function() {
    return "/";
  };
  dt2.chdir = function(t) {
    throw new Error("process.chdir is not supported");
  };
  dt2.umask = function() {
    return 0;
  };
});
var pr = {};
Ja(pr, { default: () => Y_ });
var Y_;
var Oi = R0(() => {
  ot2(pr, rn(Rh()));
  Y_ = rn(Rh());
});
var Fi = T((NI, v1) => {
  var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt2(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
  function Uo(t, e = false) {
    var r;
    return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
  }
  function zo(t) {
    var e;
    return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
  }
  function X_(t) {
    return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
  }
  function gn(t) {
    return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
  }
  function J_(t, e) {
    return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
  }
  function Ho(t) {
    if (!gn(t))
      return null;
    let { _writableState: e, _readableState: r } = t, o2 = e || r;
    return !!(t.destroyed || t[a1] || o2 != null && o2.destroyed);
  }
  function h1(t) {
    if (!zo(t))
      return null;
    if (t.writableEnded === true)
      return true;
    let e = t._writableState;
    return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
  }
  function Q_(t, e) {
    if (!zo(t))
      return null;
    if (t.writableFinished === true)
      return true;
    let r = t._writableState;
    return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
  }
  function e8(t) {
    if (!Uo(t))
      return null;
    if (t.readableEnded === true)
      return true;
    let e = t._readableState;
    return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
  }
  function u1(t, e) {
    if (!Uo(t))
      return null;
    let r = t._readableState;
    return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
  }
  function l1(t) {
    return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
  }
  function d1(t) {
    return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
  }
  function t8(t, e) {
    return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
  }
  function r8(t) {
    var e, r;
    return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
  }
  function i8(t) {
    var e, r;
    return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
  }
  function n8(t) {
    if (!gn(t))
      return null;
    if (typeof t.closed == "boolean")
      return t.closed;
    let { _writableState: e, _readableState: r } = t;
    return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
  }
  function c1(t) {
    return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
  }
  function p1(t) {
    return typeof t._sent100 == "boolean" && c1(t);
  }
  function f8(t) {
    var e;
    return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
  }
  function a8(t) {
    if (!gn(t))
      return null;
    let { _writableState: e, _readableState: r } = t, o2 = e || r;
    return !o2 && p1(t) || !!(o2 && o2.autoDestroy && o2.emitClose && o2.closed === false);
  }
  function o8(t) {
    var e;
    return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
  }
  function s8(t) {
    var e, r, o2, f, p2, m2, y2, M2, x3, S;
    return !!(t && ((e = (r = (o2 = (f = (p2 = (m2 = t[o1]) !== null && m2 !== undefined ? m2 : t.readableErrored) !== null && p2 !== undefined ? p2 : t.writableErrored) !== null && f !== undefined ? f : (y2 = t._readableState) === null || y2 === undefined ? undefined : y2.errorEmitted) !== null && o2 !== undefined ? o2 : (M2 = t._writableState) === null || M2 === undefined ? undefined : M2.errorEmitted) !== null && r !== undefined ? r : (x3 = t._readableState) === null || x3 === undefined ? undefined : x3.errored) !== null && e !== undefined ? e : (S = t._writableState) === null || S === undefined ? undefined : S.errored));
  }
  v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
});
var Ui = T((DI, Ih) => {
  var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt2(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
  function M8(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  var _8 = () => {
  };
  function S1(t, e, r) {
    var o2, f;
    arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
    let p2 = (o2 = e.readable) !== null && o2 !== undefined ? o2 : qh(t), m2 = (f = e.writable) !== null && f !== undefined ? f : _1(t);
    if (!y8(t))
      throw new l8("stream", "Stream", t);
    let { _writableState: y2, _readableState: M2 } = t, x3 = () => {
      t.writable || B();
    }, S = w8(t) && qh(t) === p2 && _1(t) === m2, E3 = x1(t, false), B = () => {
      E3 = true, t.destroyed && (S = false), !(S && (!t.readable || p2)) && (!p2 || q) && r.call(t);
    }, q = w1(t, false), L2 = () => {
      q = true, t.destroyed && (S = false), !(S && (!t.writable || m2)) && (!m2 || E3) && r.call(t);
    }, ge = (xe) => {
      r.call(t, xe);
    }, _e = b8(t), N3 = () => {
      _e = true;
      let xe = g8(t) || m8(t);
      if (xe && typeof xe != "boolean")
        return r.call(t, xe);
      if (p2 && !q && qh(t, true) && !w1(t, false))
        return r.call(t, new b1);
      if (m2 && !E3 && !x1(t, false))
        return r.call(t, new b1);
      r.call(t);
    }, we = () => {
      t.req.on("finish", B);
    };
    M8(t) ? (t.on("complete", B), S || t.on("abort", N3), t.req ? we() : t.on("request", we)) : m2 && !y2 && (t.on("end", x3), t.on("close", x3)), !S && typeof t.aborted == "boolean" && t.on("aborted", N3), t.on("end", L2), t.on("finish", B), e.error !== false && t.on("error", ge), t.on("close", N3), _e ? ff.nextTick(N3) : y2 != null && y2.errorEmitted || M2 != null && M2.errorEmitted ? S || ff.nextTick(N3) : (!p2 && (!S || y1(t)) && (E3 || M1(t) === false) || !m2 && (!S || M1(t)) && (q || y1(t) === false) || M2 && t.req && t.aborted) && ff.nextTick(N3);
    let ye = () => {
      r = _8, t.removeListener("aborted", N3), t.removeListener("complete", B), t.removeListener("abort", N3), t.removeListener("request", we), t.req && t.req.removeListener("finish", B), t.removeListener("end", x3), t.removeListener("close", x3), t.removeListener("finish", B), t.removeListener("end", L2), t.removeListener("error", ge), t.removeListener("close", N3);
    };
    if (e.signal && !_e) {
      let xe = () => {
        let Re = r;
        ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
      };
      if (e.signal.aborted)
        ff.nextTick(xe);
      else {
        let Re = r;
        r = g1((...Ee) => {
          e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
        }), e.signal.addEventListener("abort", xe);
      }
    }
    return ye;
  }
  function x8(t, e) {
    return new v8((r, o2) => {
      S1(t, e, (f) => {
        f ? o2(f) : r();
      });
    });
  }
  Ih.exports = S1;
  Ih.exports.finished = x8;
});
var k1 = T((PI, Lh) => {
  var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt2().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt2(), Wo = q1("kEmpty"), R1 = q1("kEof");
  function Ko(t, e) {
    if (typeof t != "function")
      throw new va("fn", ["Function", "AsyncFunction"], t);
    e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
    let r = 1;
    return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
      var f, p2;
      let m2 = new B1, y2 = this, M2 = [], x3 = m2.signal, S = { signal: x3 }, E3 = () => m2.abort();
      e != null && (f = e.signal) !== null && f !== undefined && f.aborted && E3(), e == null || (p2 = e.signal) === null || p2 === undefined || p2.addEventListener("abort", E3);
      let B, q, L2 = false;
      function ge() {
        L2 = true;
      }
      async function _e() {
        try {
          for await (let ye of y2) {
            var N3;
            if (L2)
              return;
            if (x3.aborted)
              throw new Jr;
            try {
              ye = t(ye, S);
            } catch (xe) {
              ye = A1(xe);
            }
            ye !== Wo && (typeof ((N3 = ye) === null || N3 === undefined ? undefined : N3.catch) == "function" && ye.catch(ge), M2.push(ye), B && (B(), B = null), !L2 && M2.length && M2.length >= r && await new E1((xe) => {
              q = xe;
            }));
          }
          M2.push(R1);
        } catch (ye) {
          let xe = A1(ye);
          L8(xe, undefined, ge), M2.push(xe);
        } finally {
          var we;
          L2 = true, B && (B(), B = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E3);
        }
      }
      _e();
      try {
        for (;; ) {
          for (;M2.length > 0; ) {
            let N3 = await M2[0];
            if (N3 === R1)
              return;
            if (x3.aborted)
              throw new Jr;
            N3 !== Wo && (yield N3), M2.shift(), q && (q(), q = null);
          }
          await new E1((N3) => {
            B = N3;
          });
        }
      } finally {
        m2.abort(), L2 = true, q && (q(), q = null);
      }
    }.call(this);
  }
  function N8(t = undefined) {
    return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
      let r = 0;
      for await (let f of this) {
        var o2;
        if (t != null && (o2 = t.signal) !== null && o2 !== undefined && o2.aborted)
          throw new Jr({ cause: t.signal.reason });
        yield [r++, f];
      }
    }.call(this);
  }
  async function I1(t, e = undefined) {
    for await (let r of kh.call(this, t, e))
      return true;
    return false;
  }
  async function D8(t, e = undefined) {
    if (typeof t != "function")
      throw new va("fn", ["Function", "AsyncFunction"], t);
    return !await I1.call(this, async (...r) => !await t(...r), e);
  }
  async function P8(t, e) {
    for await (let r of kh.call(this, t, e))
      return r;
  }
  async function C8(t, e) {
    if (typeof t != "function")
      throw new va("fn", ["Function", "AsyncFunction"], t);
    async function r(o2, f) {
      return await t(o2, f), Wo;
    }
    for await (let o2 of Ko.call(this, r, e))
      ;
  }
  function kh(t, e) {
    if (typeof t != "function")
      throw new va("fn", ["Function", "AsyncFunction"], t);
    async function r(o2, f) {
      return await t(o2, f) ? o2 : Wo;
    }
    return Ko.call(this, r, e);
  }
  var Th = class extends S8 {
    constructor() {
      super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
    }
  };
  async function O8(t, e, r) {
    var o2;
    if (typeof t != "function")
      throw new va("reducer", ["Function", "AsyncFunction"], t);
    r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
    let f = arguments.length > 1;
    if (r != null && (o2 = r.signal) !== null && o2 !== undefined && o2.aborted) {
      let x3 = new Jr(undefined, { cause: r.signal.reason });
      throw this.once("error", () => {
      }), await B8(this.destroy(x3)), x3;
    }
    let p2 = new B1, m2 = p2.signal;
    if (r != null && r.signal) {
      let x3 = { once: true, [R8]: this };
      r.signal.addEventListener("abort", () => p2.abort(), x3);
    }
    let y2 = false;
    try {
      for await (let x3 of this) {
        var M2;
        if (y2 = true, r != null && (M2 = r.signal) !== null && M2 !== undefined && M2.aborted)
          throw new Jr;
        f ? e = await t(e, x3, { signal: m2 }) : (e = x3, f = true);
      }
      if (!y2 && !f)
        throw new Th;
    } finally {
      p2.abort();
    }
    return e;
  }
  async function F8(t) {
    t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
    let e = [];
    for await (let o2 of this) {
      var r;
      if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
        throw new Jr(undefined, { cause: t.signal.reason });
      q8(e, o2);
    }
    return e;
  }
  function U8(t, e) {
    let r = Ko.call(this, t, e);
    return async function* () {
      for await (let f of r)
        yield* f;
    }.call(this);
  }
  function T1(t) {
    if (t = T8(t), k8(t))
      return 0;
    if (t < 0)
      throw new E8("number", ">= 0", t);
    return t;
  }
  function z8(t, e = undefined) {
    return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
      var o2;
      if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
        throw new Jr;
      for await (let p2 of this) {
        var f;
        if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
          throw new Jr;
        t-- <= 0 && (yield p2);
      }
    }.call(this);
  }
  function H8(t, e = undefined) {
    return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
      var o2;
      if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
        throw new Jr;
      for await (let p2 of this) {
        var f;
        if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
          throw new Jr;
        if (t-- > 0)
          yield p2;
        else
          return;
      }
    }.call(this);
  }
  Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
  Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
});
var yn = T((CI, U1) => {
  var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt2(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
  function C1(t, e, r) {
    t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
  }
  function Y8(t, e) {
    let r = this._readableState, o2 = this._writableState, f = o2 || r;
    return o2 && o2.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o2, r), o2 && (o2.destroyed = true), r && (r.destroyed = true), f.constructed ? L1(this, t, e) : this.once(P1, function(p2) {
      L1(this, W8(p2, t), e);
    }), this);
  }
  function L1(t, e, r) {
    let o2 = false;
    function f(p2) {
      if (o2)
        return;
      o2 = true;
      let { _readableState: m2, _writableState: y2 } = t;
      C1(p2, y2, m2), y2 && (y2.closed = true), m2 && (m2.closed = true), typeof r == "function" && r(p2), p2 ? zi.nextTick(X8, t, p2) : zi.nextTick(O1, t);
    }
    try {
      t._destroy(e || null, f);
    } catch (p2) {
      f(p2);
    }
  }
  function X8(t, e) {
    Dh(t, e), O1(t);
  }
  function O1(t) {
    let { _readableState: e, _writableState: r } = t;
    r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
  }
  function Dh(t, e) {
    let { _readableState: r, _writableState: o2 } = t;
    o2 && o2.errorEmitted || r && r.errorEmitted || (o2 && (o2.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
  }
  function J8() {
    let t = this._readableState, e = this._writableState;
    t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
  }
  function Ph(t, e, r) {
    let { _readableState: o2, _writableState: f } = t;
    if (f && f.destroyed || o2 && o2.destroyed)
      return this;
    o2 && o2.autoDestroy || f && f.autoDestroy ? t.destroy(e) : e && (e.stack, f && !f.errored && (f.errored = e), o2 && !o2.errored && (o2.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
  }
  function Q8(t, e) {
    if (typeof t._construct != "function")
      return;
    let { _readableState: r, _writableState: o2 } = t;
    r && (r.constructed = false), o2 && (o2.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
  }
  function e5(t) {
    let e = false;
    function r(o2) {
      if (e) {
        Ph(t, o2 ?? new K8);
        return;
      }
      e = true;
      let { _readableState: f, _writableState: p2 } = t, m2 = p2 || f;
      f && (f.constructed = true), p2 && (p2.constructed = true), m2.destroyed ? t.emit(P1, o2) : o2 ? Ph(t, o2, true) : zi.nextTick(t5, t);
    }
    try {
      t._construct(r);
    } catch (o2) {
      r(o2);
    }
  }
  function t5(t) {
    t.emit(Nh);
  }
  function N1(t) {
    return t && t.setHeader && typeof t.abort == "function";
  }
  function F1(t) {
    t.emit("close");
  }
  function r5(t, e) {
    t.emit("error", e), zi.nextTick(F1, t);
  }
  function i5(t, e) {
    !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
  }
  U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
});
var Vo = T((OI, H1) => {
  var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt2(), { EventEmitter: jo } = ki();
  function Zo(t) {
    jo.call(this, t);
  }
  z1(Zo.prototype, jo.prototype);
  z1(Zo, jo);
  Zo.prototype.pipe = function(t, e) {
    let r = this;
    function o2(S) {
      t.writable && t.write(S) === false && r.pause && r.pause();
    }
    r.on("data", o2);
    function f() {
      r.readable && r.resume && r.resume();
    }
    t.on("drain", f), !t._isStdio && (!e || e.end !== false) && (r.on("end", m2), r.on("close", y2));
    let p2 = false;
    function m2() {
      p2 || (p2 = true, t.end());
    }
    function y2() {
      p2 || (p2 = true, typeof t.destroy == "function" && t.destroy());
    }
    function M2(S) {
      x3(), jo.listenerCount(this, "error") === 0 && this.emit("error", S);
    }
    Ch(r, "error", M2), Ch(t, "error", M2);
    function x3() {
      r.removeListener("data", o2), t.removeListener("drain", f), r.removeListener("end", m2), r.removeListener("close", y2), r.removeListener("error", M2), t.removeListener("error", M2), r.removeListener("end", x3), r.removeListener("close", x3), t.removeListener("close", x3);
    }
    return r.on("end", x3), r.on("close", x3), t.on("close", x3), t.emit("pipe", r), t;
  };
  function Ch(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  H1.exports = { Stream: Zo, prependListener: Ch };
});
var Go = T((FI, $o) => {
  var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
    if (typeof t != "object" || !("aborted" in t))
      throw new W1(e, "AbortSignal", t);
  };
  function h5(t) {
    return !!(t && typeof t.pipe == "function");
  }
  $o.exports.addAbortSignal = function(e, r) {
    if (s5(e, "signal"), !h5(r))
      throw new W1("stream", "stream.Stream", r);
    return $o.exports.addAbortSignalNoValidate(e, r);
  };
  $o.exports.addAbortSignalNoValidate = function(t, e) {
    if (typeof t != "object" || !("aborted" in t))
      return e;
    let r = () => {
      e.destroy(new f5(undefined, { cause: t.reason }));
    };
    return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
  };
});
var Z1 = T((zI, j1) => {
  var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt2(), { Buffer: Oh } = Ut2(), { inspect: d5 } = Gr();
  j1.exports = class {
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    push(e) {
      let r = { data: e, next: null };
      this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
    }
    unshift(e) {
      let r = { data: e, next: this.head };
      this.length === 0 && (this.tail = r), this.head = r, ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      let e = this.head.data;
      return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
    }
    clear() {
      this.head = this.tail = null, this.length = 0;
    }
    join(e) {
      if (this.length === 0)
        return "";
      let r = this.head, o2 = "" + r.data;
      for (;(r = r.next) !== null; )
        o2 += e + r.data;
      return o2;
    }
    concat(e) {
      if (this.length === 0)
        return Oh.alloc(0);
      let r = Oh.allocUnsafe(e >>> 0), o2 = this.head, f = 0;
      for (;o2; )
        Yo(r, o2.data, f), f += o2.data.length, o2 = o2.next;
      return r;
    }
    consume(e, r) {
      let o2 = this.head.data;
      if (e < o2.length) {
        let f = o2.slice(0, e);
        return this.head.data = o2.slice(e), f;
      }
      return e === o2.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
    }
    first() {
      return this.head.data;
    }
    *[u5]() {
      for (let e = this.head;e; e = e.next)
        yield e.data;
    }
    _getString(e) {
      let r = "", o2 = this.head, f = 0;
      do {
        let p2 = o2.data;
        if (e > p2.length)
          r += p2, e -= p2.length;
        else {
          e === p2.length ? (r += p2, ++f, o2.next ? this.head = o2.next : this.head = this.tail = null) : (r += K1(p2, 0, e), this.head = o2, o2.data = K1(p2, e));
          break;
        }
        ++f;
      } while ((o2 = o2.next) !== null);
      return this.length -= f, r;
    }
    _getBuffer(e) {
      let r = Oh.allocUnsafe(e), o2 = e, f = this.head, p2 = 0;
      do {
        let m2 = f.data;
        if (e > m2.length)
          Yo(r, m2, o2 - e), e -= m2.length;
        else {
          e === m2.length ? (Yo(r, m2, o2 - e), ++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (Yo(r, new l5(m2.buffer, m2.byteOffset, e), o2 - e), this.head = f, f.data = m2.slice(e));
          break;
        }
        ++p2;
      } while ((f = f.next) !== null);
      return this.length -= p2, r;
    }
    [Symbol.for("nodejs.util.inspect.custom")](e, r) {
      return d5(this, { ...r, depth: 0, customInspect: false });
    }
  };
});
var Xo = T((HI, $1) => {
  var { MathFloor: c5, NumberIsInteger: p5 } = Tt2(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
  function b5(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function V1(t) {
    return t ? 16 : 16 * 1024;
  }
  function m5(t, e, r, o2) {
    let f = b5(e, o2, r);
    if (f != null) {
      if (!p5(f) || f < 0) {
        let p2 = o2 ? `options.${r}` : "options.highWaterMark";
        throw new v5(p2, f);
      }
      return c5(f);
    }
    return V1(t.objectMode);
  }
  $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
});
var Fh = T((WI, J1) => {
  var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt2(), { Buffer: y5 } = Ut2(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
  function _5(t, e, r) {
    let o2;
    if (typeof e == "string" || e instanceof y5)
      return new t({ objectMode: true, ...r, read() {
        this.push(e), this.push(null);
      } });
    let f;
    if (e && e[Y1])
      f = true, o2 = e[Y1]();
    else if (e && e[X1])
      f = false, o2 = e[X1]();
    else
      throw new w5("iterable", ["Iterable"], e);
    let p2 = new t({ objectMode: true, highWaterMark: 1, ...r }), m2 = false;
    p2._read = function() {
      m2 || (m2 = true, M2());
    }, p2._destroy = function(x3, S) {
      g5(y2(x3), () => G1.nextTick(S, x3), (E3) => G1.nextTick(S, E3 || x3));
    };
    async function y2(x3) {
      let S = x3 != null, E3 = typeof o2.throw == "function";
      if (S && E3) {
        let { value: B, done: q } = await o2.throw(x3);
        if (await B, q)
          return;
      }
      if (typeof o2.return == "function") {
        let { value: B } = await o2.return();
        await B;
      }
    }
    async function M2() {
      for (;; ) {
        try {
          let { value: x3, done: S } = f ? await o2.next() : o2.next();
          if (S)
            p2.push(null);
          else {
            let E3 = x3 && typeof x3.then == "function" ? await x3 : x3;
            if (E3 === null)
              throw m2 = false, new M5;
            if (p2.push(E3))
              continue;
            m2 = false;
          }
        } catch (x3) {
          p2.destroy(x3);
        }
        break;
      }
    }
    return p2;
  }
  J1.exports = _5;
});
var ba = T((KI, lv) => {
  var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt2();
  lv.exports = Le;
  Le.ReadableState = jh;
  var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut2(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe2 = Gr().debuglog("stream", (t) => {
    Pe2 = t;
  }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
  rv(Le.prototype, Hi.prototype);
  rv(Le, Hi);
  var zh = () => {
  }, { errorOrDestroy: sf } = hf;
  function jh(t, e, r) {
    typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
  }
  function Le(t) {
    if (!(this instanceof Le))
      return new Le(t);
    let e = this instanceof Qr();
    this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
      this._readableState.needReadable && Jo(this, this._readableState);
    });
  }
  Le.prototype.destroy = hf.destroy;
  Le.prototype._undestroy = hf.undestroy;
  Le.prototype._destroy = function(t, e) {
    e(t);
  };
  Le.prototype[k5.captureRejectionSymbol] = function(t) {
    this.destroy(t);
  };
  Le.prototype.push = function(t, e) {
    return nv(this, t, e, false);
  };
  Le.prototype.unshift = function(t, e) {
    return nv(this, t, e, true);
  };
  function nv(t, e, r, o2) {
    Pe2("readableAddChunk", e);
    let f = t._readableState, p2;
    if (f.objectMode || (typeof e == "string" ? (r = r || f.defaultEncoding, f.encoding !== r && (o2 && f.encoding ? e = Uh.from(e, r).toString(f.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi._isUint8Array(e) ? (e = Hi._uint8ArrayToBuffer(e), r = "") : e != null && (p2 = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p2)
      sf(t, p2);
    else if (e === null)
      f.reading = false, $5(t, f);
    else if (f.objectMode || e && e.length > 0)
      if (o2)
        if (f.endEmitted)
          sf(t, new W5);
        else {
          if (f.destroyed || f.errored)
            return false;
          Hh(t, f, e, true);
        }
      else if (f.ended)
        sf(t, new H5);
      else {
        if (f.destroyed || f.errored)
          return false;
        f.reading = false, f.decoder && !r ? (e = f.decoder.write(e), f.objectMode || e.length !== 0 ? Hh(t, f, e, false) : Jo(t, f)) : Hh(t, f, e, false);
      }
    else
      o2 || (f.reading = false, Jo(t, f));
    return !f.ended && (f.length < f.highWaterMark || f.length === 0);
  }
  function Hh(t, e, r, o2) {
    e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo(t, e);
  }
  Le.prototype.isPaused = function() {
    let t = this._readableState;
    return t[wn] === true || t.flowing === false;
  };
  Le.prototype.setEncoding = function(t) {
    let e = new iv(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    let r = this._readableState.buffer, o2 = "";
    for (let f of r)
      o2 += e.write(f);
    return r.clear(), o2 !== "" && r.push(o2), this._readableState.length = o2.length, this;
  };
  var Z5 = 1073741824;
  function V5(t) {
    if (t > Z5)
      throw new z5("size", "<= 1GiB", t);
    return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
  }
  function ev(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
  }
  Le.prototype.read = function(t) {
    Pe2("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
    let e = this._readableState, r = t;
    if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Pe2("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
    if (t = ev(t, e), t === 0 && e.ended)
      return e.length === 0 && Wh(this), null;
    let o2 = e.needReadable;
    if (Pe2("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Pe2("length less than watermark", o2)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
      o2 = false, Pe2("reading, ended or constructing", o2);
    else if (o2) {
      Pe2("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
      try {
        this._read(e.highWaterMark);
      } catch (p2) {
        sf(this, p2);
      }
      e.sync = false, e.reading || (t = ev(r, e));
    }
    let f;
    return t > 0 ? f = hv(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f)), f;
  };
  function $5(t, e) {
    if (Pe2("onEofChunk"), !e.ended) {
      if (e.decoder) {
        let r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
    }
  }
  function Qo(t) {
    let e = t._readableState;
    Pe2("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe2("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
  }
  function fv(t) {
    let e = t._readableState;
    Pe2("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
  }
  function Jo(t, e) {
    !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
  }
  function G5(t, e) {
    for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      let r = e.length;
      if (Pe2("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Le.prototype._read = function(t) {
    throw new U5("_read()");
  };
  Le.prototype.pipe = function(t, e) {
    let r = this, o2 = this._readableState;
    o2.pipes.length === 1 && (o2.multiAwaitDrain || (o2.multiAwaitDrain = true, o2.awaitDrainWriters = new q5(o2.awaitDrainWriters ? [o2.awaitDrainWriters] : []))), o2.pipes.push(t), Pe2("pipe count=%d opts=%j", o2.pipes.length, e);
    let p2 = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y2 : _e;
    o2.endEmitted ? Tr.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
    function m2(N3, we) {
      Pe2("onunpipe"), N3 === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S());
    }
    function y2() {
      Pe2("onend"), t.end();
    }
    let M2, x3 = false;
    function S() {
      Pe2("cleanup"), t.removeListener("close", L2), t.removeListener("finish", ge), M2 && t.removeListener("drain", M2), t.removeListener("error", q), t.removeListener("unpipe", m2), r.removeListener("end", y2), r.removeListener("end", _e), r.removeListener("data", B), x3 = true, M2 && o2.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M2();
    }
    function E3() {
      x3 || (o2.pipes.length === 1 && o2.pipes[0] === t ? (Pe2("false write response, pause", 0), o2.awaitDrainWriters = t, o2.multiAwaitDrain = false) : o2.pipes.length > 1 && o2.pipes.includes(t) && (Pe2("false write response, pause", o2.awaitDrainWriters.size), o2.awaitDrainWriters.add(t)), r.pause()), M2 || (M2 = Y5(r, t), t.on("drain", M2));
    }
    r.on("data", B);
    function B(N3) {
      Pe2("ondata");
      let we = t.write(N3);
      Pe2("dest.write", we), we === false && E3();
    }
    function q(N3) {
      if (Pe2("onerror", N3), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
        let we = t._writableState || t._readableState;
        we && !we.errorEmitted ? sf(t, N3) : t.emit("error", N3);
      }
    }
    L5(t, "error", q);
    function L2() {
      t.removeListener("finish", ge), _e();
    }
    t.once("close", L2);
    function ge() {
      Pe2("onfinish"), t.removeListener("close", L2), _e();
    }
    t.once("finish", ge);
    function _e() {
      Pe2("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), t.writableNeedDrain === true ? o2.flowing && E3() : o2.flowing || (Pe2("pipe resume"), r.resume()), t;
  };
  function Y5(t, e) {
    return function() {
      let o2 = t._readableState;
      o2.awaitDrainWriters === e ? (Pe2("pipeOnDrain", 1), o2.awaitDrainWriters = null) : o2.multiAwaitDrain && (Pe2("pipeOnDrain", o2.awaitDrainWriters.size), o2.awaitDrainWriters.delete(e)), (!o2.awaitDrainWriters || o2.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
    };
  }
  Le.prototype.unpipe = function(t) {
    let e = this._readableState, r = { hasUnpiped: false };
    if (e.pipes.length === 0)
      return this;
    if (!t) {
      let f = e.pipes;
      e.pipes = [], this.pause();
      for (let p2 = 0;p2 < f.length; p2++)
        f[p2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    let o2 = x5(e.pipes, t);
    return o2 === -1 ? this : (e.pipes.splice(o2, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
  };
  Le.prototype.on = function(t, e) {
    let r = Hi.prototype.on.call(this, t, e), o2 = this._readableState;
    return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Pe2("on readable", o2.length, o2.reading), o2.length ? Qo(this) : o2.reading || Tr.nextTick(X5, this)), r;
  };
  Le.prototype.addListener = Le.prototype.on;
  Le.prototype.removeListener = function(t, e) {
    let r = Hi.prototype.removeListener.call(this, t, e);
    return t === "readable" && Tr.nextTick(av, this), r;
  };
  Le.prototype.off = Le.prototype.removeListener;
  Le.prototype.removeAllListeners = function(t) {
    let e = Hi.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
  };
  function av(t) {
    let e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
  }
  function X5(t) {
    Pe2("readable nexttick read 0"), t.read(0);
  }
  Le.prototype.resume = function() {
    let t = this._readableState;
    return t.flowing || (Pe2("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
  };
  function J5(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
  }
  function Q5(t, e) {
    Pe2("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
  }
  Le.prototype.pause = function() {
    return Pe2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
  };
  function ov(t) {
    let e = t._readableState;
    for (Pe2("flow", e.flowing);e.flowing && t.read() !== null; )
      ;
  }
  Le.prototype.wrap = function(t) {
    let e = false;
    t.on("data", (o2) => {
      !this.push(o2) && t.pause && (e = true, t.pause());
    }), t.on("end", () => {
      this.push(null);
    }), t.on("error", (o2) => {
      sf(this, o2);
    }), t.on("close", () => {
      this.destroy();
    }), t.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      e && t.resume && (e = false, t.resume());
    };
    let r = R5(t);
    for (let o2 = 1;o2 < r.length; o2++) {
      let f = r[o2];
      this[f] === undefined && typeof t[f] == "function" && (this[f] = t[f].bind(t));
    }
    return this;
  };
  Le.prototype[I5] = function() {
    return sv(this);
  };
  Le.prototype.iterator = function(t) {
    return t !== undefined && K5(t, "options"), sv(this, t);
  };
  function sv(t, e) {
    typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
    let r = ex(t, e);
    return r.stream = t, r;
  }
  async function* ex(t, e) {
    let r = zh;
    function o2(m2) {
      this === t ? (r(), r = zh) : r = m2;
    }
    t.on("readable", o2);
    let f, p2 = D5(t, { writable: false }, (m2) => {
      f = m2 ? Q1(f, m2) : null, r(), r = zh;
    });
    try {
      for (;; ) {
        let m2 = t.destroyed ? null : t.read();
        if (m2 !== null)
          yield m2;
        else {
          if (f)
            throw f;
          if (f === null)
            return;
          await new B5(o2);
        }
      }
    } catch (m2) {
      throw f = Q1(f, m2), f;
    } finally {
      (f || e?.destroyOnReturn !== false) && (f === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o2), p2());
    }
  }
  tv(Le.prototype, { readable: { __proto__: null, get() {
    let t = this._readableState;
    return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
  }, set(t) {
    this._readableState && (this._readableState.readable = !!t);
  } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
    return this._readableState.dataEmitted;
  } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
    return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
  } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(t) {
    this._readableState && (this._readableState.flowing = t);
  } }, readableLength: { __proto__: null, enumerable: false, get() {
    return this._readableState.length;
  } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
    return this._readableState ? this._readableState.objectMode : false;
  } }, readableEncoding: { __proto__: null, enumerable: false, get() {
    return this._readableState ? this._readableState.encoding : null;
  } }, errored: { __proto__: null, enumerable: false, get() {
    return this._readableState ? this._readableState.errored : null;
  } }, closed: { __proto__: null, get() {
    return this._readableState ? this._readableState.closed : false;
  } }, destroyed: { __proto__: null, enumerable: false, get() {
    return this._readableState ? this._readableState.destroyed : false;
  }, set(t) {
    !this._readableState || (this._readableState.destroyed = t);
  } }, readableEnded: { __proto__: null, enumerable: false, get() {
    return this._readableState ? this._readableState.endEmitted : false;
  } } });
  tv(jh.prototype, { pipesCount: { __proto__: null, get() {
    return this.pipes.length;
  } }, paused: { __proto__: null, get() {
    return this[wn] !== false;
  }, set(t) {
    this[wn] = !!t;
  } } });
  Le._fromList = hv;
  function hv(t, e) {
    if (e.length === 0)
      return null;
    let r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Wh(t) {
    let e = t._readableState;
    Pe2("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
  }
  function tx(t, e) {
    if (Pe2("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
      if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
        Tr.nextTick(rx, e);
      else if (t.autoDestroy) {
        let r = e._writableState;
        (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
      }
    }
  }
  function rx(t) {
    t.writable && !t.writableEnded && !t.destroyed && t.end();
  }
  Le.from = function(t, e) {
    return j5(Le, t, e);
  };
  var Kh;
  function uv() {
    return Kh === undefined && (Kh = {}), Kh;
  }
  Le.fromWeb = function(t, e) {
    return uv().newStreamReadableFromReadableStream(t, e);
  };
  Le.toWeb = function(t, e) {
    return uv().newReadableStreamFromStreamReadable(t, e);
  };
  Le.wrap = function(t, e) {
    var r, o2;
    return new Le({ objectMode: (r = (o2 = t.readableObjectMode) !== null && o2 !== undefined ? o2 : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f, p2) {
      hf.destroyer(t, f), p2(f);
    } }).wrap(t);
  };
});
var Jh = T((jI, xv) => {
  var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt2();
  xv.exports = st3;
  st3.WritableState = ya;
  var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut2(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
  mv(st3.prototype, ma.prototype);
  mv(st3, ma);
  function $h() {
  }
  var lf = ax("kOnFinished");
  function ya(t, e, r) {
    typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    let o2 = !!(t && t.decodeStrings === false);
    this.decodeStrings = !o2, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
  }
  function rs(t) {
    t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
  }
  ya.prototype.getBuffer = function() {
    return pv(this.buffered, this.bufferedIndex);
  };
  bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
    return this.buffered.length - this.bufferedIndex;
  } });
  function st3(t) {
    let e = this instanceof Qr();
    if (!e && !vv(st3, this))
      return new st3(t);
    this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
      let r = this._writableState;
      r.writing || Yh(this, r), Xh(this, r);
    });
  }
  bv(st3, ox, { __proto__: null, value: function(t) {
    return vv(this, t) ? true : this !== st3 ? false : t && t._writableState instanceof ya;
  } });
  st3.prototype.pipe = function() {
    uf(this, new px);
  };
  function wv(t, e, r, o2) {
    let f = t._writableState;
    if (typeof r == "function")
      o2 = r, r = f.defaultEncoding;
    else {
      if (!r)
        r = f.defaultEncoding;
      else if (r !== "buffer" && !es.isEncoding(r))
        throw new yv(r);
      typeof o2 != "function" && (o2 = $h);
    }
    if (e === null)
      throw new bx;
    if (!f.objectMode)
      if (typeof e == "string")
        f.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
      else if (e instanceof es)
        r = "buffer";
      else if (ma._isUint8Array(e))
        e = ma._uint8ArrayToBuffer(e), r = "buffer";
      else
        throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
    let p2;
    return f.ending ? p2 = new mx : f.destroyed && (p2 = new ga("write")), p2 ? (Mn.nextTick(o2, p2), uf(t, p2, true), p2) : (f.pendingcb++, gx(t, f, e, r, o2));
  }
  st3.prototype.write = function(t, e, r) {
    return wv(this, t, e, r) === true;
  };
  st3.prototype.cork = function() {
    this._writableState.corked++;
  };
  st3.prototype.uncork = function() {
    let t = this._writableState;
    t.corked && (t.corked--, t.writing || Yh(this, t));
  };
  st3.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
      throw new yv(e);
    return this._writableState.defaultEncoding = e, this;
  };
  function gx(t, e, r, o2, f) {
    let p2 = e.objectMode ? 1 : r.length;
    e.length += p2;
    let m2 = e.length < e.highWaterMark;
    return m2 || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o2, callback: f }), e.allBuffers && o2 !== "buffer" && (e.allBuffers = false), e.allNoop && f !== $h && (e.allNoop = false)) : (e.writelen = p2, e.writecb = f, e.writing = true, e.sync = true, t._write(r, o2, e.onwrite), e.sync = false), m2 && !e.errored && !e.destroyed;
  }
  function dv(t, e, r, o2, f, p2, m2) {
    e.writelen = o2, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
  }
  function cv(t, e, r, o2) {
    --e.pendingcb, o2(r), Gh(e), uf(t, r);
  }
  function yx(t, e) {
    let r = t._writableState, o2 = r.sync, f = r.writecb;
    if (typeof f != "function") {
      uf(t, new gv);
      return;
    }
    r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o2 ? Mn.nextTick(cv, t, r, e, f) : cv(t, r, e, f)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o2 ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f));
  }
  function wx({ stream: t, state: e, count: r, cb: o2 }) {
    return e.afterWriteTickInfo = null, Mv(t, e, r, o2);
  }
  function Mv(t, e, r, o2) {
    for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
      e.pendingcb--, o2();
    e.destroyed && Gh(e), Xh(t, e);
  }
  function Gh(t) {
    if (t.writing)
      return;
    for (let f = t.bufferedIndex;f < t.buffered.length; ++f) {
      var e;
      let { chunk: p2, callback: m2 } = t.buffered[f], y2 = t.objectMode ? 1 : p2.length;
      t.length -= y2, m2((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
    }
    let r = t[lf].splice(0);
    for (let f = 0;f < r.length; f++) {
      var o2;
      r[f]((o2 = t.errored) !== null && o2 !== undefined ? o2 : new ga("end"));
    }
    rs(t);
  }
  function Yh(t, e) {
    if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
      return;
    let { buffered: r, bufferedIndex: o2, objectMode: f } = e, p2 = r.length - o2;
    if (!p2)
      return;
    let m2 = o2;
    if (e.bufferProcessing = true, p2 > 1 && t._writev) {
      e.pendingcb -= p2 - 1;
      let y2 = e.allNoop ? $h : (x3) => {
        for (let S = m2;S < r.length; ++S)
          r[S].callback(x3);
      }, M2 = e.allNoop && m2 === 0 ? r : pv(r, m2);
      M2.allBuffers = e.allBuffers, dv(t, e, true, e.length, M2, "", y2), rs(e);
    } else {
      do {
        let { chunk: y2, encoding: M2, callback: x3 } = r[m2];
        r[m2++] = null;
        let S = f ? 1 : y2.length;
        dv(t, e, false, S, y2, M2, x3);
      } while (m2 < r.length && !e.writing);
      m2 === r.length ? rs(e) : m2 > 256 ? (r.splice(0, m2), e.bufferedIndex = 0) : e.bufferedIndex = m2;
    }
    e.bufferProcessing = false;
  }
  st3.prototype._write = function(t, e, r) {
    if (this._writev)
      this._writev([{ chunk: t, encoding: e }], r);
    else
      throw new cx("_write()");
  };
  st3.prototype._writev = null;
  st3.prototype.end = function(t, e, r) {
    let o2 = this._writableState;
    typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
    let f;
    if (t != null) {
      let p2 = wv(this, t, e);
      p2 instanceof ix && (f = p2);
    }
    return o2.corked && (o2.corked = 1, this.uncork()), f || (!o2.errored && !o2.ending ? (o2.ending = true, Xh(this, o2, true), o2.ended = true) : o2.finished ? f = new vx("end") : o2.destroyed && (f = new ga("end"))), typeof r == "function" && (f || o2.finished ? Mn.nextTick(r, f) : o2[lf].push(r)), this;
  };
  function ts(t) {
    return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
  }
  function Mx(t, e) {
    let r = false;
    function o2(f) {
      if (r) {
        uf(t, f ?? gv());
        return;
      }
      if (r = true, e.pendingcb--, f) {
        let p2 = e[lf].splice(0);
        for (let m2 = 0;m2 < p2.length; m2++)
          p2[m2](f);
        uf(t, f, e.sync);
      } else
        ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
    }
    e.sync = true, e.pendingcb++;
    try {
      t._final(o2);
    } catch (f) {
      o2(f);
    }
    e.sync = false;
  }
  function _x(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function Xh(t, e, r) {
    ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o2, f) => {
      ts(f) ? Vh(o2, f) : f.pendingcb--;
    }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
  }
  function Vh(t, e) {
    e.pendingcb--, e.finished = true;
    let r = e[lf].splice(0);
    for (let o2 = 0;o2 < r.length; o2++)
      r[o2]();
    if (t.emit("finish"), e.autoDestroy) {
      let o2 = t._readableState;
      (!o2 || o2.autoDestroy && (o2.endEmitted || o2.readable === false)) && t.destroy();
    }
  }
  nx(st3.prototype, { closed: { __proto__: null, get() {
    return this._writableState ? this._writableState.closed : false;
  } }, destroyed: { __proto__: null, get() {
    return this._writableState ? this._writableState.destroyed : false;
  }, set(t) {
    this._writableState && (this._writableState.destroyed = t);
  } }, writable: { __proto__: null, get() {
    let t = this._writableState;
    return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
  }, set(t) {
    this._writableState && (this._writableState.writable = !!t);
  } }, writableFinished: { __proto__: null, get() {
    return this._writableState ? this._writableState.finished : false;
  } }, writableObjectMode: { __proto__: null, get() {
    return this._writableState ? this._writableState.objectMode : false;
  } }, writableBuffer: { __proto__: null, get() {
    return this._writableState && this._writableState.getBuffer();
  } }, writableEnded: { __proto__: null, get() {
    return this._writableState ? this._writableState.ending : false;
  } }, writableNeedDrain: { __proto__: null, get() {
    let t = this._writableState;
    return t ? !t.destroyed && !t.ending && t.needDrain : false;
  } }, writableHighWaterMark: { __proto__: null, get() {
    return this._writableState && this._writableState.highWaterMark;
  } }, writableCorked: { __proto__: null, get() {
    return this._writableState ? this._writableState.corked : 0;
  } }, writableLength: { __proto__: null, get() {
    return this._writableState && this._writableState.length;
  } }, errored: { __proto__: null, enumerable: false, get() {
    return this._writableState ? this._writableState.errored : null;
  } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
    return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
  } } });
  var xx = is.destroy;
  st3.prototype.destroy = function(t, e) {
    let r = this._writableState;
    return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
  };
  st3.prototype._undestroy = is.undestroy;
  st3.prototype._destroy = function(t, e) {
    e(t);
  };
  st3.prototype[sx.captureRejectionSymbol] = function(t) {
    this.destroy(t);
  };
  var Zh;
  function _v() {
    return Zh === undefined && (Zh = {}), Zh;
  }
  st3.fromWeb = function(t, e) {
    return _v().newStreamWritableFromWritableStream(t, e);
  };
  st3.toWeb = function(t) {
    return _v().newWritableStreamFromStreamWritable(t);
  };
});
var Dv = T((ZI, Nv) => {
  var Qh = (Oi(), ur(pr)), Sx = Ut2(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
    return e instanceof Tv;
  } : function(e) {
    return false;
  }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt2(), _n = class extends Ix {
    constructor(e) {
      super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
    }
  };
  Nv.exports = function t(e, r) {
    if (Bx(e))
      return e;
    if (Ev(e))
      return ns({ readable: e });
    if (Av(e))
      return ns({ writable: e });
    if (Rx(e))
      return ns({ writable: false, readable: false });
    if (typeof e == "function") {
      let { value: f, write: p2, final: m2, destroy: y2 } = Nx(e);
      if (Sv(f))
        return Iv(_n, f, { objectMode: true, write: p2, final: m2, destroy: y2 });
      let M2 = f?.then;
      if (typeof M2 == "function") {
        let x3, S = kv(M2, f, (E3) => {
          if (E3 != null)
            throw new Bv("nully", "body", E3);
        }, (E3) => {
          df(x3, E3);
        });
        return x3 = new _n({ objectMode: true, readable: false, write: p2, final(E3) {
          m2(async () => {
            try {
              await S, Qh.nextTick(E3, null);
            } catch (B) {
              Qh.nextTick(E3, B);
            }
          });
        }, destroy: y2 });
      }
      throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f);
    }
    if (kx(e))
      return t(e.arrayBuffer());
    if (Sv(e))
      return Iv(_n, e, { objectMode: true, writable: false });
    if (typeof e?.writable == "object" || typeof e?.readable == "object") {
      let f = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p2 = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
      return ns({ readable: f, writable: p2 });
    }
    let o2 = e?.then;
    if (typeof o2 == "function") {
      let f;
      return kv(o2, e, (p2) => {
        p2 != null && f.push(p2), f.push(null);
      }, (p2) => {
        df(f, p2);
      }), f = new _n({ objectMode: true, writable: false, read() {
      } });
    }
    throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
  };
  function Nx(t) {
    let { promise: e, resolve: r } = qv(), o2 = new Lx, f = o2.signal;
    return { value: t(async function* () {
      for (;; ) {
        let m2 = e;
        e = null;
        let { chunk: y2, done: M2, cb: x3 } = await m2;
        if (Qh.nextTick(x3), M2)
          return;
        if (f.aborted)
          throw new Lv(undefined, { cause: f.reason });
        ({ promise: e, resolve: r } = qv()), yield y2;
      }
    }(), { signal: f }), write(m2, y2, M2) {
      let x3 = r;
      r = null, x3({ chunk: m2, done: false, cb: M2 });
    }, final(m2) {
      let y2 = r;
      r = null, y2({ done: true, cb: m2 });
    }, destroy(m2, y2) {
      o2.abort(), y2(m2);
    } };
  }
  function ns(t) {
    let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o2 = !!Ex(e), f = !!Ax(r), p2, m2, y2, M2, x3;
    function S(E3) {
      let B = M2;
      M2 = null, B ? B(E3) : E3 ? x3.destroy(E3) : !o2 && !f && x3.destroy();
    }
    return x3 = new _n({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o2, writable: f }), f && (Rv(r, (E3) => {
      f = false, E3 && df(e, E3), S(E3);
    }), x3._write = function(E3, B, q) {
      r.write(E3, B) ? q() : p2 = q;
    }, x3._final = function(E3) {
      r.end(), m2 = E3;
    }, r.on("drain", function() {
      if (p2) {
        let E3 = p2;
        p2 = null, E3();
      }
    }), r.on("finish", function() {
      if (m2) {
        let E3 = m2;
        m2 = null, E3();
      }
    })), o2 && (Rv(e, (E3) => {
      o2 = false, E3 && df(e, E3), S(E3);
    }), e.on("readable", function() {
      if (y2) {
        let E3 = y2;
        y2 = null, E3();
      }
    }), e.on("end", function() {
      x3.push(null);
    }), x3._read = function() {
      for (;; ) {
        let E3 = e.read();
        if (E3 === null) {
          y2 = x3._read;
          return;
        }
        if (!x3.push(E3))
          return;
      }
    }), x3._destroy = function(E3, B) {
      !E3 && M2 !== null && (E3 = new Lv), y2 = null, p2 = null, m2 = null, M2 === null ? B(E3) : (M2 = B, df(r, E3), df(e, E3));
    }, x3;
  }
});
var Qr = T((VI, Ov) => {
  var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt2();
  Ov.exports = kr;
  var ru = ba(), vr = Jh();
  Pv(kr.prototype, ru.prototype);
  Pv(kr, ru);
  {
    let t = Px(vr.prototype);
    for (let e = 0;e < t.length; e++) {
      let r = t[e];
      kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
    }
  }
  function kr(t) {
    if (!(this instanceof kr))
      return new kr(t);
    ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
  }
  Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
    return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set(t) {
    this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
  } } });
  var eu;
  function Cv() {
    return eu === undefined && (eu = {}), eu;
  }
  kr.fromWeb = function(t, e) {
    return Cv().newStreamDuplexFromReadableWritablePair(t, e);
  };
  kr.toWeb = function(t) {
    return Cv().newReadableWritablePairFromDuplex(t);
  };
  var tu;
  kr.from = function(t) {
    return tu || (tu = Dv()), tu(t, "body");
  };
});
var fu = T(($I, Uv) => {
  var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt2();
  Uv.exports = mi;
  var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
  Fv(mi.prototype, nu.prototype);
  Fv(mi, nu);
  var wa = Cx("kCallback");
  function mi(t) {
    if (!(this instanceof mi))
      return new mi(t);
    let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
    e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
  }
  function iu(t) {
    typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
      if (e) {
        t ? t(e) : this.destroy(e);
        return;
      }
      r != null && this.push(r), this.push(null), t && t();
    }) : (this.push(null), t && t());
  }
  function Ux() {
    this._final !== iu && iu.call(this);
  }
  mi.prototype._final = iu;
  mi.prototype._transform = function(t, e, r) {
    throw new Ox("_transform()");
  };
  mi.prototype._write = function(t, e, r) {
    let o2 = this._readableState, f = this._writableState, p2 = o2.length;
    this._transform(t, e, (m2, y2) => {
      if (m2) {
        r(m2);
        return;
      }
      y2 != null && this.push(y2), f.ended || p2 === o2.length || o2.length < o2.highWaterMark ? r() : this[wa] = r;
    });
  };
  mi.prototype._read = function() {
    if (this[wa]) {
      let t = this[wa];
      this[wa] = null, t();
    }
  };
});
var ou = T((GI, Hv) => {
  var { ObjectSetPrototypeOf: zv } = Tt2();
  Hv.exports = cf;
  var au = fu();
  zv(cf.prototype, au.prototype);
  zv(cf, au);
  function cf(t) {
    if (!(this instanceof cf))
      return new cf(t);
    au.call(this, t);
  }
  cf.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var os = T((YI, Gv) => {
  var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt2(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
  function jv(t, e, r) {
    let o2 = false;
    t.on("close", () => {
      o2 = true;
    });
    let f = as(t, { readable: e, writable: r }, (p2) => {
      o2 = !p2;
    });
    return { destroy: (p2) => {
      o2 || (o2 = true, jx.destroyer(t, p2 || new $x("pipe")));
    }, cleanup: f };
  }
  function e7(t) {
    return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
  }
  function t7(t) {
    if (pf(t))
      return t;
    if (du(t))
      return r7(t);
    throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
  }
  async function* r7(t) {
    lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
  }
  async function Zv(t, e, r, { end: o2 }) {
    let f, p2 = null, m2 = (x3) => {
      if (x3 && (f = x3), p2) {
        let S = p2;
        p2 = null, S();
      }
    }, y2 = () => new Hx((x3, S) => {
      f ? S(f) : p2 = () => {
        f ? S(f) : x3();
      };
    });
    e.on("drain", m2);
    let M2 = as(e, { readable: false }, m2);
    try {
      e.writableNeedDrain && await y2();
      for await (let x3 of t)
        e.write(x3) || await y2();
      o2 && e.end(), await y2(), r();
    } catch (x3) {
      r(f !== x3 ? Zx(f, x3) : x3);
    } finally {
      M2(), e.off("drain", m2);
    }
  }
  function i7(...t) {
    return $v(t, Kx(e7(t)));
  }
  function $v(t, e, r) {
    if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
      throw new Vx("streams");
    let o2 = new Qx, f = o2.signal, p2 = r?.signal, m2 = [];
    Jx(p2, "options.signal");
    function y2() {
      q(new Yx);
    }
    p2?.addEventListener("abort", y2);
    let M2, x3, S = [], E3 = 0;
    function B(N3) {
      q(N3, --E3 === 0);
    }
    function q(N3, we) {
      if (N3 && (!M2 || M2.code === "ERR_STREAM_PREMATURE_CLOSE") && (M2 = N3), !(!M2 && !we)) {
        for (;S.length; )
          S.shift()(M2);
        p2?.removeEventListener("abort", y2), o2.abort(), we && (M2 || m2.forEach((ye) => ye()), fs.nextTick(e, M2, x3));
      }
    }
    let L2;
    for (let N3 = 0;N3 < t.length; N3++) {
      let we = t[N3], ye = N3 < t.length - 1, xe = N3 > 0, Re = ye || r?.end !== false, Ee = N3 === t.length - 1;
      if (Kv(we)) {
        let Ae2 = function(P3) {
          P3 && P3.name !== "AbortError" && P3.code !== "ERR_STREAM_PREMATURE_CLOSE" && B(P3);
        };
        var _e = Ae2;
        if (Re) {
          let { destroy: P3, cleanup: Se2 } = jv(we, ye, xe);
          S.push(P3), hu(we) && Ee && m2.push(Se2);
        }
        we.on("error", Ae2), hu(we) && Ee && m2.push(() => {
          we.removeListener("error", Ae2);
        });
      }
      if (N3 === 0)
        if (typeof we == "function") {
          if (L2 = we({ signal: f }), !pf(L2))
            throw new su("Iterable, AsyncIterable or Stream", "source", L2);
        } else
          pf(we) || du(we) ? L2 = we : L2 = Wv.from(we);
      else if (typeof we == "function")
        if (L2 = t7(L2), L2 = we(L2, { signal: f }), ye) {
          if (!pf(L2, true))
            throw new su("AsyncIterable", `transform[${N3 - 1}]`, L2);
        } else {
          var ge;
          uu || (uu = ou());
          let Ae2 = new uu({ objectMode: true }), P3 = (ge = L2) === null || ge === undefined ? undefined : ge.then;
          if (typeof P3 == "function")
            E3++, P3.call(L2, (i) => {
              x3 = i, i != null && Ae2.write(i), Re && Ae2.end(), fs.nextTick(B);
            }, (i) => {
              Ae2.destroy(i), fs.nextTick(B, i);
            });
          else if (pf(L2, true))
            E3++, Zv(L2, Ae2, B, { end: Re });
          else
            throw new su("AsyncIterable or Promise", "destination", L2);
          L2 = Ae2;
          let { destroy: Se2, cleanup: v3 } = jv(L2, false, true);
          S.push(Se2), Ee && m2.push(v3);
        }
      else if (Kv(we)) {
        if (du(L2)) {
          E3 += 2;
          let Ae2 = n7(L2, we, B, { end: Re });
          hu(we) && Ee && m2.push(Ae2);
        } else if (pf(L2))
          E3++, Zv(L2, we, B, { end: Re });
        else
          throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L2);
        L2 = we;
      } else
        L2 = Wv.from(we);
    }
    return (f != null && f.aborted || p2 != null && p2.aborted) && fs.nextTick(y2), L2;
  }
  function n7(t, e, r, { end: o2 }) {
    let f = false;
    return e.on("close", () => {
      f || r(new Gx);
    }), t.pipe(e, { end: o2 }), o2 ? t.once("end", () => {
      f = true, e.end();
    }) : r(), as(t, { readable: true, writable: false }, (p2) => {
      let m2 = t._readableState;
      p2 && p2.code === "ERR_STREAM_PREMATURE_CLOSE" && m2 && m2.ended && !m2.errored && !m2.errorEmitted ? t.once("end", r).once("error", r) : r(p2);
    }), as(e, { readable: false, writable: true }, r);
  }
  Gv.exports = { pipelineImpl: $v, pipeline: i7 };
});
var eb = T((XI, Qv) => {
  var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
  Qv.exports = function(...e) {
    if (e.length === 0)
      throw new h7("streams");
    if (e.length === 1)
      return ss.from(e[0]);
    let r = [...e];
    if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
      let q = e.length - 1;
      e[q] = ss.from(e[q]);
    }
    for (let q = 0;q < e.length; ++q)
      if (!!o7(e[q])) {
        if (q < e.length - 1 && !Yv(e[q]))
          throw new Jv(`streams[${q}]`, r[q], "must be readable");
        if (q > 0 && !Xv(e[q]))
          throw new Jv(`streams[${q}]`, r[q], "must be writable");
      }
    let o2, f, p2, m2, y2;
    function M2(q) {
      let L2 = m2;
      m2 = null, L2 ? L2(q) : q ? y2.destroy(q) : !B && !E3 && y2.destroy();
    }
    let x3 = e[0], S = f7(e, M2), E3 = !!Xv(x3), B = !!Yv(S);
    return y2 = new ss({ writableObjectMode: !!(x3 != null && x3.writableObjectMode), readableObjectMode: !!(S != null && S.writableObjectMode), writable: E3, readable: B }), E3 && (y2._write = function(q, L2, ge) {
      x3.write(q, L2) ? ge() : o2 = ge;
    }, y2._final = function(q) {
      x3.end(), f = q;
    }, x3.on("drain", function() {
      if (o2) {
        let q = o2;
        o2 = null, q();
      }
    }), S.on("finish", function() {
      if (f) {
        let q = f;
        f = null, q();
      }
    })), B && (S.on("readable", function() {
      if (p2) {
        let q = p2;
        p2 = null, q();
      }
    }), S.on("end", function() {
      y2.push(null);
    }), y2._read = function() {
      for (;; ) {
        let q = S.read();
        if (q === null) {
          p2 = y2._read;
          return;
        }
        if (!y2.push(q))
          return;
      }
    }), y2._destroy = function(q, L2) {
      !q && m2 !== null && (q = new s7), p2 = null, o2 = null, f = null, m2 === null ? L2(q) : (m2 = L2, a7(S, q));
    }, y2;
  };
});
var cu = T((JI, tb) => {
  var { ArrayPrototypePop: u7, Promise: l7 } = Tt2(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
  function b7(...t) {
    return new l7((e, r) => {
      let o2, f, p2 = t[t.length - 1];
      if (p2 && typeof p2 == "object" && !c7(p2) && !d7(p2)) {
        let m2 = u7(t);
        o2 = m2.signal, f = m2.end;
      }
      p7(t, (m2, y2) => {
        m2 ? r(m2) : e(y2);
      }, { signal: o2, end: f });
    });
  }
  tb.exports = { finished: v7, pipeline: b7 };
});
var lb = T((QI, ub) => {
  var { Buffer: m7 } = Ut2(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt2(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct3 = ub.exports = Vo().Stream;
  ct3.isDisturbed = vu.isDisturbed;
  ct3.isErrored = vu.isErrored;
  ct3.isReadable = vu.isReadable;
  ct3.Readable = ba();
  for (let t of nb(rb)) {
    let r = function(...o2) {
      if (new.target)
        throw ob();
      return ct3.Readable.from(fb(e, this, o2));
    };
    M7 = r;
    let e = rb[t];
    gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct3.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
  }
  var M7;
  for (let t of nb(ib)) {
    let r = function(...f) {
      if (new.target)
        throw ob();
      return fb(e, this, f);
    };
    M7 = r;
    let e = ib[t];
    gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct3.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
  }
  var M7;
  ct3.Writable = Jh();
  ct3.Duplex = Qr();
  ct3.Transform = fu();
  ct3.PassThrough = ou();
  ct3.pipeline = sb;
  var { addAbortSignal: w7 } = Go();
  ct3.addAbortSignal = w7;
  ct3.finished = hb;
  ct3.destroy = y7;
  ct3.compose = g7;
  gi(ct3, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
    return pu;
  } });
  gi(sb, ab, { __proto__: null, enumerable: true, get() {
    return pu.pipeline;
  } });
  gi(hb, ab, { __proto__: null, enumerable: true, get() {
    return pu.finished;
  } });
  ct3.Stream = ct3;
  ct3._isUint8Array = function(e) {
    return e instanceof Uint8Array;
  };
  ct3._uint8ArrayToBuffer = function(e) {
    return m7.from(e.buffer, e.byteOffset, e.byteLength);
  };
});
var bu = T((eT, pt3) => {
  var Lt2 = lb(), _7 = cu(), x7 = Lt2.Readable.destroy;
  pt3.exports = Lt2.Readable;
  pt3.exports._uint8ArrayToBuffer = Lt2._uint8ArrayToBuffer;
  pt3.exports._isUint8Array = Lt2._isUint8Array;
  pt3.exports.isDisturbed = Lt2.isDisturbed;
  pt3.exports.isErrored = Lt2.isErrored;
  pt3.exports.isReadable = Lt2.isReadable;
  pt3.exports.Readable = Lt2.Readable;
  pt3.exports.Writable = Lt2.Writable;
  pt3.exports.Duplex = Lt2.Duplex;
  pt3.exports.Transform = Lt2.Transform;
  pt3.exports.PassThrough = Lt2.PassThrough;
  pt3.exports.addAbortSignal = Lt2.addAbortSignal;
  pt3.exports.finished = Lt2.finished;
  pt3.exports.destroy = Lt2.destroy;
  pt3.exports.destroy = x7;
  pt3.exports.pipeline = Lt2.pipeline;
  pt3.exports.compose = Lt2.compose;
  Object.defineProperty(Lt2, "promises", { configurable: true, enumerable: true, get() {
    return _7;
  } });
  pt3.exports.Stream = Lt2.Stream;
  pt3.exports.default = pt3.exports;
});
var vf = {};
Ja(vf, { default: () => S7 });
var S7;
var db = R0(() => {
  ot2(vf, rn(bu()));
  S7 = rn(bu());
});
var yi = T((rT, vb) => {
  var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
  function Lr(t) {
    pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  A7(Lr, pb);
  Lr.prototype.update = function(t, e, r) {
    typeof t == "string" && (t = cb.from(t, e));
    var o2 = this._update(t);
    return this.hashMode ? this : (r && (o2 = this._toString(o2, r)), o2);
  };
  Lr.prototype.setAutoPadding = function() {
  };
  Lr.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  Lr.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  Lr.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  Lr.prototype._transform = function(t, e, r) {
    var o2;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (f) {
      o2 = f;
    } finally {
      r(o2);
    }
  };
  Lr.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Lr.prototype._finalOrDigest = function(t) {
    var e = this.__final() || cb.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  Lr.prototype._toString = function(t, e, r) {
    if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var o2 = this._decoder.write(t);
    return r && (o2 += this._decoder.end()), o2;
  };
  vb.exports = Lr;
});
var bf = T((iT, mb) => {
  var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
  function hs(t) {
    bb.call(this, "digest"), this._hash = t;
  }
  R7(hs, bb);
  hs.prototype._update = function(t) {
    this._hash.update(t);
  };
  hs.prototype._final = function() {
    return this._hash.digest();
  };
  mb.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
  };
});
var wb = T((nT, yb) => {
  var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
  function us(t, e) {
    gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
    for (var r = this._ipad = xn.allocUnsafe(mf), o2 = this._opad = xn.allocUnsafe(mf), f = 0;f < mf; f++)
      r[f] = e[f] ^ 54, o2[f] = e[f] ^ 92;
    this._hash = [r];
  }
  T7(us, gb);
  us.prototype._update = function(t) {
    this._hash.push(t);
  };
  us.prototype._final = function() {
    var t = this._alg(xn.concat(this._hash));
    return this._alg(xn.concat([this._opad, t]));
  };
  yb.exports = us;
});
var mu = T((fT, Mb) => {
  var L7 = Ao();
  Mb.exports = function(t) {
    return new L7().update(t).digest();
  };
});
var wu = T((aT, xb) => {
  var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
  function _a(t, e) {
    _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
      var o2 = t === "rmd160" ? new gu : yu(t);
      e = o2.update(e).digest();
    } else
      e.length < r && (e = Ma.concat([e, C7], r));
    for (var f = this._ipad = Ma.allocUnsafe(r), p2 = this._opad = Ma.allocUnsafe(r), m2 = 0;m2 < r; m2++)
      f[m2] = e[m2] ^ 54, p2[m2] = e[m2] ^ 92;
    this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f);
  }
  N7(_a, _b);
  _a.prototype._update = function(t) {
    this._hash.update(t);
  };
  _a.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  xb.exports = function(e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
  };
});
var Mu = T((oT, O7) => {
  O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var Eb = T((sT, Sb) => {
  Sb.exports = Mu();
});
var _u = T((hT, Ab) => {
  var F7 = Math.pow(2, 30) - 1;
  Ab.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > F7 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var xu = T((uT, Bb) => {
  var ls;
  global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
  var Rb;
  Bb.exports = ls;
});
var Eu = T((lT, qb) => {
  var Su = Te().Buffer;
  qb.exports = function(t, e, r) {
    if (Su.isBuffer(t))
      return t;
    if (typeof t == "string")
      return Su.from(t, e);
    if (ArrayBuffer.isView(t))
      return Su.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var Au = T((dT, Lb) => {
  var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function kb(t, e, r) {
    var o2 = j7(t), f = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > f ? e = o2(e) : e.length < f && (e = Sn.concat([e, K7], f));
    for (var p2 = Sn.allocUnsafe(f + ds[t]), m2 = Sn.allocUnsafe(f + ds[t]), y2 = 0;y2 < f; y2++)
      p2[y2] = e[y2] ^ 54, m2[y2] = e[y2] ^ 92;
    var M2 = Sn.allocUnsafe(f + r + 4);
    p2.copy(M2, 0, 0, f), this.ipad1 = M2, this.ipad2 = p2, this.opad = m2, this.alg = t, this.blocksize = f, this.hash = o2, this.size = ds[t];
  }
  kb.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function j7(t) {
    function e(o2) {
      return H7(t).update(o2).digest();
    }
    function r(o2) {
      return new z7().update(o2).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
  }
  function Z7(t, e, r, o2, f) {
    W7(r, o2), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f = f || "sha1";
    var p2 = new kb(f, t, e.length), m2 = Sn.allocUnsafe(o2), y2 = Sn.allocUnsafe(e.length + 4);
    e.copy(y2, 0, 0, e.length);
    for (var M2 = 0, x3 = ds[f], S = Math.ceil(o2 / x3), E3 = 1;E3 <= S; E3++) {
      y2.writeUInt32BE(E3, e.length);
      for (var B = p2.run(y2, p2.ipad1), q = B, L2 = 1;L2 < r; L2++) {
        q = p2.run(q, p2.ipad2);
        for (var ge = 0;ge < x3; ge++)
          B[ge] ^= q[ge];
      }
      B.copy(m2, M2), M2 += x3;
    }
    return m2;
  }
  Lb.exports = Z7;
});
var Ub = T((cT, Fb) => {
  var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
  function G7(t) {
    if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
      return Promise.resolve(false);
    if (Ru[t] !== undefined)
      return Ru[t];
    cs = cs || Cb.alloc(8);
    var e = Ob(cs, cs, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return Ru[t] = e, e;
  }
  var En;
  function Bu() {
    return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
  }
  function Ob(t, e, r, o2, f) {
    return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p2) {
      return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f } }, p2, o2 << 3);
    }).then(function(p2) {
      return Cb.from(p2);
    });
  }
  function Y7(t, e) {
    t.then(function(r) {
      Bu()(function() {
        e(null, r);
      });
    }, function(r) {
      Bu()(function() {
        e(r);
      });
    });
  }
  Fb.exports = function(t, e, r, o2, f, p2) {
    typeof f == "function" && (p2 = f, f = undefined), f = f || "sha1";
    var m2 = $7[f.toLowerCase()];
    if (!m2 || typeof global.Promise != "function") {
      Bu()(function() {
        var y2;
        try {
          y2 = Db(t, e, r, o2, f);
        } catch (M2) {
          return p2(M2);
        }
        p2(null, y2);
      });
      return;
    }
    if (V7(r, o2), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p2 != "function")
      throw new Error("No callback provided to pbkdf2");
    Y7(G7(m2).then(function(y2) {
      return y2 ? Ob(t, e, r, o2, m2) : Db(t, e, r, o2, f);
    }), p2);
  };
});
var Iu = T((qu) => {
  qu.pbkdf2 = Ub();
  qu.pbkdf2Sync = Au();
});
var Tu = T((br2) => {
  br2.readUInt32BE = function(e, r) {
    var o2 = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return o2 >>> 0;
  };
  br2.writeUInt32BE = function(e, r, o2) {
    e[0 + o2] = r >>> 24, e[1 + o2] = r >>> 16 & 255, e[2 + o2] = r >>> 8 & 255, e[3 + o2] = r & 255;
  };
  br2.ip = function(e, r, o2, f) {
    for (var p2 = 0, m2 = 0, y2 = 6;y2 >= 0; y2 -= 2) {
      for (var M2 = 0;M2 <= 24; M2 += 8)
        p2 <<= 1, p2 |= r >>> M2 + y2 & 1;
      for (var M2 = 0;M2 <= 24; M2 += 8)
        p2 <<= 1, p2 |= e >>> M2 + y2 & 1;
    }
    for (var y2 = 6;y2 >= 0; y2 -= 2) {
      for (var M2 = 1;M2 <= 25; M2 += 8)
        m2 <<= 1, m2 |= r >>> M2 + y2 & 1;
      for (var M2 = 1;M2 <= 25; M2 += 8)
        m2 <<= 1, m2 |= e >>> M2 + y2 & 1;
    }
    o2[f + 0] = p2 >>> 0, o2[f + 1] = m2 >>> 0;
  };
  br2.rip = function(e, r, o2, f) {
    for (var p2 = 0, m2 = 0, y2 = 0;y2 < 4; y2++)
      for (var M2 = 24;M2 >= 0; M2 -= 8)
        p2 <<= 1, p2 |= r >>> M2 + y2 & 1, p2 <<= 1, p2 |= e >>> M2 + y2 & 1;
    for (var y2 = 4;y2 < 8; y2++)
      for (var M2 = 24;M2 >= 0; M2 -= 8)
        m2 <<= 1, m2 |= r >>> M2 + y2 & 1, m2 <<= 1, m2 |= e >>> M2 + y2 & 1;
    o2[f + 0] = p2 >>> 0, o2[f + 1] = m2 >>> 0;
  };
  br2.pc1 = function(e, r, o2, f) {
    for (var p2 = 0, m2 = 0, y2 = 7;y2 >= 5; y2--) {
      for (var M2 = 0;M2 <= 24; M2 += 8)
        p2 <<= 1, p2 |= r >> M2 + y2 & 1;
      for (var M2 = 0;M2 <= 24; M2 += 8)
        p2 <<= 1, p2 |= e >> M2 + y2 & 1;
    }
    for (var M2 = 0;M2 <= 24; M2 += 8)
      p2 <<= 1, p2 |= r >> M2 + y2 & 1;
    for (var y2 = 1;y2 <= 3; y2++) {
      for (var M2 = 0;M2 <= 24; M2 += 8)
        m2 <<= 1, m2 |= r >> M2 + y2 & 1;
      for (var M2 = 0;M2 <= 24; M2 += 8)
        m2 <<= 1, m2 |= e >> M2 + y2 & 1;
    }
    for (var M2 = 0;M2 <= 24; M2 += 8)
      m2 <<= 1, m2 |= e >> M2 + y2 & 1;
    o2[f + 0] = p2 >>> 0, o2[f + 1] = m2 >>> 0;
  };
  br2.r28shl = function(e, r) {
    return e << r & 268435455 | e >>> 28 - r;
  };
  var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  br2.pc2 = function(e, r, o2, f) {
    for (var p2 = 0, m2 = 0, y2 = ps.length >>> 1, M2 = 0;M2 < y2; M2++)
      p2 <<= 1, p2 |= e >>> ps[M2] & 1;
    for (var M2 = y2;M2 < ps.length; M2++)
      m2 <<= 1, m2 |= r >>> ps[M2] & 1;
    o2[f + 0] = p2 >>> 0, o2[f + 1] = m2 >>> 0;
  };
  br2.expand = function(e, r, o2) {
    var f = 0, p2 = 0;
    f = (e & 1) << 5 | e >>> 27;
    for (var m2 = 23;m2 >= 15; m2 -= 4)
      f <<= 6, f |= e >>> m2 & 63;
    for (var m2 = 11;m2 >= 3; m2 -= 4)
      p2 |= e >>> m2 & 63, p2 <<= 6;
    p2 |= (e & 31) << 1 | e >>> 31, r[o2 + 0] = f >>> 0, r[o2 + 1] = p2 >>> 0;
  };
  var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  br2.substitute = function(e, r) {
    for (var o2 = 0, f = 0;f < 4; f++) {
      var p2 = e >>> 18 - f * 6 & 63, m2 = zb[f * 64 + p2];
      o2 <<= 4, o2 |= m2;
    }
    for (var f = 0;f < 4; f++) {
      var p2 = r >>> 18 - f * 6 & 63, m2 = zb[4 * 64 + f * 64 + p2];
      o2 <<= 4, o2 |= m2;
    }
    return o2 >>> 0;
  };
  var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  br2.permute = function(e) {
    for (var r = 0, o2 = 0;o2 < Hb.length; o2++)
      r <<= 1, r |= e >>> Hb[o2] & 1;
    return r >>> 0;
  };
  br2.padSplit = function(e, r, o2) {
    for (var f = e.toString(2);f.length < r; )
      f = "0" + f;
    for (var p2 = [], m2 = 0;m2 < r; m2 += o2)
      p2.push(f.slice(m2, m2 + o2));
    return p2.join(" ");
  };
});
var ar = T((bT, Kb) => {
  Kb.exports = Wb;
  function Wb(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  Wb.equal = function(e, r, o2) {
    if (e != r)
      throw new Error(o2 || "Assertion failed: " + e + " != " + r);
  };
});
var vs = T((mT, jb) => {
  var X7 = ar();
  function mr2(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  jb.exports = mr2;
  mr2.prototype._init = function() {
  };
  mr2.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  mr2.prototype._buffer = function(e, r) {
    for (var o2 = Math.min(this.buffer.length - this.bufferOff, e.length - r), f = 0;f < o2; f++)
      this.buffer[this.bufferOff + f] = e[r + f];
    return this.bufferOff += o2, o2;
  };
  mr2.prototype._flushBuffer = function(e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
  };
  mr2.prototype._updateEncrypt = function(e) {
    var r = 0, o2 = 0, f = (this.bufferOff + e.length) / this.blockSize | 0, p2 = new Array(f * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o2 += this._flushBuffer(p2, o2)));
    for (var m2 = e.length - (e.length - r) % this.blockSize;r < m2; r += this.blockSize)
      this._update(e, r, p2, o2), o2 += this.blockSize;
    for (;r < e.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r];
    return p2;
  };
  mr2.prototype._updateDecrypt = function(e) {
    for (var r = 0, o2 = 0, f = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p2 = new Array(f * this.blockSize);f > 0; f--)
      r += this._buffer(e, r), o2 += this._flushBuffer(p2, o2);
    return r += this._buffer(e, r), p2;
  };
  mr2.prototype.final = function(e) {
    var r;
    e && (r = this.update(e));
    var o2;
    return this.type === "encrypt" ? o2 = this._finalEncrypt() : o2 = this._finalDecrypt(), r ? r.concat(o2) : o2;
  };
  mr2.prototype._pad = function(e, r) {
    if (r === 0)
      return false;
    for (;r < e.length; )
      e[r++] = 0;
    return true;
  };
  mr2.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  mr2.prototype._unpad = function(e) {
    return e;
  };
  mr2.prototype._finalDecrypt = function() {
    X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var ku = T((gT, $b) => {
  var Zb = ar(), J7 = Ie(), Nt2 = Tu(), Vb = vs();
  function Q7() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ei(t) {
    Vb.call(this, t);
    var e = new Q7;
    this._desState = e, this.deriveKeys(e, t.key);
  }
  J7(ei, Vb);
  $b.exports = ei;
  ei.create = function(e) {
    return new ei(e);
  };
  var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  ei.prototype.deriveKeys = function(e, r) {
    e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
    var o2 = Nt2.readUInt32BE(r, 0), f = Nt2.readUInt32BE(r, 4);
    Nt2.pc1(o2, f, e.tmp, 0), o2 = e.tmp[0], f = e.tmp[1];
    for (var p2 = 0;p2 < e.keys.length; p2 += 2) {
      var m2 = e9[p2 >>> 1];
      o2 = Nt2.r28shl(o2, m2), f = Nt2.r28shl(f, m2), Nt2.pc2(o2, f, e.keys, p2);
    }
  };
  ei.prototype._update = function(e, r, o2, f) {
    var p2 = this._desState, m2 = Nt2.readUInt32BE(e, r), y2 = Nt2.readUInt32BE(e, r + 4);
    Nt2.ip(m2, y2, p2.tmp, 0), m2 = p2.tmp[0], y2 = p2.tmp[1], this.type === "encrypt" ? this._encrypt(p2, m2, y2, p2.tmp, 0) : this._decrypt(p2, m2, y2, p2.tmp, 0), m2 = p2.tmp[0], y2 = p2.tmp[1], Nt2.writeUInt32BE(o2, m2, f), Nt2.writeUInt32BE(o2, y2, f + 4);
  };
  ei.prototype._pad = function(e, r) {
    for (var o2 = e.length - r, f = r;f < e.length; f++)
      e[f] = o2;
    return true;
  };
  ei.prototype._unpad = function(e) {
    for (var r = e[e.length - 1], o2 = e.length - r;o2 < e.length; o2++)
      Zb.equal(e[o2], r);
    return e.slice(0, e.length - r);
  };
  ei.prototype._encrypt = function(e, r, o2, f, p2) {
    for (var m2 = r, y2 = o2, M2 = 0;M2 < e.keys.length; M2 += 2) {
      var x3 = e.keys[M2], S = e.keys[M2 + 1];
      Nt2.expand(y2, e.tmp, 0), x3 ^= e.tmp[0], S ^= e.tmp[1];
      var E3 = Nt2.substitute(x3, S), B = Nt2.permute(E3), q = y2;
      y2 = (m2 ^ B) >>> 0, m2 = q;
    }
    Nt2.rip(y2, m2, f, p2);
  };
  ei.prototype._decrypt = function(e, r, o2, f, p2) {
    for (var m2 = o2, y2 = r, M2 = e.keys.length - 2;M2 >= 0; M2 -= 2) {
      var x3 = e.keys[M2], S = e.keys[M2 + 1];
      Nt2.expand(m2, e.tmp, 0), x3 ^= e.tmp[0], S ^= e.tmp[1];
      var E3 = Nt2.substitute(x3, S), B = Nt2.permute(E3), q = m2;
      m2 = (y2 ^ B) >>> 0, y2 = q;
    }
    Nt2.rip(m2, y2, f, p2);
  };
});
var Yb = T((Gb) => {
  var t9 = ar(), r9 = Ie(), bs = {};
  function i9(t) {
    t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0;e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function n9(t) {
    function e(p2) {
      t.call(this, p2), this._cbcInit();
    }
    r9(e, t);
    for (var r = Object.keys(bs), o2 = 0;o2 < r.length; o2++) {
      var f = r[o2];
      e.prototype[f] = bs[f];
    }
    return e.create = function(m2) {
      return new e(m2);
    }, e;
  }
  Gb.instantiate = n9;
  bs._cbcInit = function() {
    var e = new i9(this.options.iv);
    this._cbcState = e;
  };
  bs._update = function(e, r, o2, f) {
    var p2 = this._cbcState, m2 = this.constructor.super_.prototype, y2 = p2.iv;
    if (this.type === "encrypt") {
      for (var M2 = 0;M2 < this.blockSize; M2++)
        y2[M2] ^= e[r + M2];
      m2._update.call(this, y2, 0, o2, f);
      for (var M2 = 0;M2 < this.blockSize; M2++)
        y2[M2] = o2[f + M2];
    } else {
      m2._update.call(this, e, r, o2, f);
      for (var M2 = 0;M2 < this.blockSize; M2++)
        o2[f + M2] ^= y2[M2];
      for (var M2 = 0;M2 < this.blockSize; M2++)
        y2[M2] = e[r + M2];
    }
  };
});
var Qb = T((wT, Jb) => {
  var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
  function o9(t, e) {
    f9.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), o2 = e.slice(8, 16), f = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o2 }), Wi.create({ type: "encrypt", key: f })] : this.ciphers = [Wi.create({ type: "decrypt", key: f }), Wi.create({ type: "encrypt", key: o2 }), Wi.create({ type: "decrypt", key: r })];
  }
  function An(t) {
    Xb.call(this, t);
    var e = new o9(this.type, this.options.key);
    this._edeState = e;
  }
  a9(An, Xb);
  Jb.exports = An;
  An.create = function(e) {
    return new An(e);
  };
  An.prototype._update = function(e, r, o2, f) {
    var p2 = this._edeState;
    p2.ciphers[0]._update(e, r, o2, f), p2.ciphers[1]._update(o2, f, o2, f), p2.ciphers[2]._update(o2, f, o2, f);
  };
  An.prototype._pad = Wi.prototype._pad;
  An.prototype._unpad = Wi.prototype._unpad;
});
var em = T((gf) => {
  gf.utils = Tu();
  gf.Cipher = vs();
  gf.DES = ku();
  gf.CBC = Yb();
  gf.EDE = Qb();
});
var im = T((_T, rm) => {
  var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
  Sa.des = Sa["des-cbc"];
  Sa.des3 = Sa["des-ede3-cbc"];
  rm.exports = ms;
  s9(ms, tm);
  function ms(t) {
    tm.call(this);
    var e = t.mode.toLowerCase(), r = Sa[e], o2;
    t.decrypt ? o2 = "decrypt" : o2 = "encrypt";
    var f = t.key;
    Rn.isBuffer(f) || (f = Rn.from(f)), (e === "des-ede" || e === "des-ede-cbc") && (f = Rn.concat([f, f.slice(0, 8)]));
    var p2 = t.iv;
    Rn.isBuffer(p2) || (p2 = Rn.from(p2)), this._des = r.create({ key: f, iv: p2, type: o2 });
  }
  ms.prototype._update = function(t) {
    return Rn.from(this._des.update(t));
  };
  ms.prototype._final = function() {
    return Rn.from(this._des.final());
  };
});
var nm = T((Lu) => {
  Lu.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  Lu.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var yf = T((ST, fm) => {
  fm.exports = function(e, r) {
    for (var o2 = Math.min(e.length, r.length), f = new Buffer(o2), p2 = 0;p2 < o2; ++p2)
      f[p2] = e[p2] ^ r[p2];
    return f;
  };
});
var om = T((Nu) => {
  var am = yf();
  Nu.encrypt = function(t, e) {
    var r = am(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  };
  Nu.decrypt = function(t, e) {
    var r = t._prev;
    t._prev = e;
    var o2 = t._cipher.decryptBlock(e);
    return am(o2, r);
  };
});
var um = T((hm) => {
  var Ea = Te().Buffer, h9 = yf();
  function sm(t, e, r) {
    var o2 = e.length, f = h9(e, t._cache);
    return t._cache = t._cache.slice(o2), t._prev = Ea.concat([t._prev, r ? e : f]), f;
  }
  hm.encrypt = function(t, e, r) {
    for (var o2 = Ea.allocUnsafe(0), f;e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
        f = t._cache.length, o2 = Ea.concat([o2, sm(t, e.slice(0, f), r)]), e = e.slice(f);
      else {
        o2 = Ea.concat([o2, sm(t, e, r)]);
        break;
      }
    return o2;
  };
});
var dm = T((lm) => {
  var Du = Te().Buffer;
  function u9(t, e, r) {
    var o2 = t._cipher.encryptBlock(t._prev), f = o2[0] ^ e;
    return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f])]), f;
  }
  lm.encrypt = function(t, e, r) {
    for (var o2 = e.length, f = Du.allocUnsafe(o2), p2 = -1;++p2 < o2; )
      f[p2] = u9(t, e[p2], r);
    return f;
  };
});
var pm = T((cm) => {
  var gs = Te().Buffer;
  function l9(t, e, r) {
    for (var o2, f = -1, p2 = 8, m2 = 0, y2, M2;++f < p2; )
      o2 = t._cipher.encryptBlock(t._prev), y2 = e & 1 << 7 - f ? 128 : 0, M2 = o2[0] ^ y2, m2 += (M2 & 128) >> f % 8, t._prev = d9(t._prev, r ? y2 : M2);
    return m2;
  }
  function d9(t, e) {
    var r = t.length, o2 = -1, f = gs.allocUnsafe(t.length);
    for (t = gs.concat([t, gs.from([e])]);++o2 < r; )
      f[o2] = t[o2] << 1 | t[o2 + 1] >> 7;
    return f;
  }
  cm.encrypt = function(t, e, r) {
    for (var o2 = e.length, f = gs.allocUnsafe(o2), p2 = -1;++p2 < o2; )
      f[p2] = l9(t, e[p2], r);
    return f;
  };
});
var bm = T((vm) => {
  var c9 = yf();
  function p9(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  vm.encrypt = function(t, e) {
    for (;t._cache.length < e.length; )
      t._cache = Buffer.concat([t._cache, p9(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), c9(e, r);
  };
});
var Pu = T((IT, mm) => {
  function v9(t) {
    for (var e = t.length, r;e--; )
      if (r = t.readUInt8(e), r === 255)
        t.writeUInt8(0, e);
      else {
        r++, t.writeUInt8(r, e);
        break;
      }
  }
  mm.exports = v9;
});
var Ou = T((ym) => {
  var b9 = yf(), gm = Te().Buffer, m9 = Pu();
  function g9(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return m9(t._prev), e;
  }
  var Cu = 16;
  ym.encrypt = function(t, e) {
    var r = Math.ceil(e.length / Cu), o2 = t._cache.length;
    t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
    for (var f = 0;f < r; f++) {
      var p2 = g9(t), m2 = o2 + f * Cu;
      t._cache.writeUInt32BE(p2[0], m2 + 0), t._cache.writeUInt32BE(p2[1], m2 + 4), t._cache.writeUInt32BE(p2[2], m2 + 8), t._cache.writeUInt32BE(p2[3], m2 + 12);
    }
    var y2 = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), b9(e, y2);
  };
});
var Fu = T((kT, y9) => {
  y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var ws = T((LT, wm) => {
  var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
  for (Uu in ys)
    ys[Uu].module = w9[ys[Uu].mode];
  var Uu;
  wm.exports = ys;
});
var Aa = T((NT, _m) => {
  var Ms = Te().Buffer;
  function Hu(t) {
    Ms.isBuffer(t) || (t = Ms.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), o2 = 0;o2 < e; o2++)
      r[o2] = t.readUInt32BE(o2 * 4);
    return r;
  }
  function zu(t) {
    for (var e = 0;e < t.length; t++)
      t[e] = 0;
  }
  function Mm(t, e, r, o2, f) {
    for (var p2 = r[0], m2 = r[1], y2 = r[2], M2 = r[3], x3 = t[0] ^ e[0], S = t[1] ^ e[1], E3 = t[2] ^ e[2], B = t[3] ^ e[3], q, L2, ge, _e, N3 = 4, we = 1;we < f; we++)
      q = p2[x3 >>> 24] ^ m2[S >>> 16 & 255] ^ y2[E3 >>> 8 & 255] ^ M2[B & 255] ^ e[N3++], L2 = p2[S >>> 24] ^ m2[E3 >>> 16 & 255] ^ y2[B >>> 8 & 255] ^ M2[x3 & 255] ^ e[N3++], ge = p2[E3 >>> 24] ^ m2[B >>> 16 & 255] ^ y2[x3 >>> 8 & 255] ^ M2[S & 255] ^ e[N3++], _e = p2[B >>> 24] ^ m2[x3 >>> 16 & 255] ^ y2[S >>> 8 & 255] ^ M2[E3 & 255] ^ e[N3++], x3 = q, S = L2, E3 = ge, B = _e;
    return q = (o2[x3 >>> 24] << 24 | o2[S >>> 16 & 255] << 16 | o2[E3 >>> 8 & 255] << 8 | o2[B & 255]) ^ e[N3++], L2 = (o2[S >>> 24] << 24 | o2[E3 >>> 16 & 255] << 16 | o2[B >>> 8 & 255] << 8 | o2[x3 & 255]) ^ e[N3++], ge = (o2[E3 >>> 24] << 24 | o2[B >>> 16 & 255] << 16 | o2[x3 >>> 8 & 255] << 8 | o2[S & 255]) ^ e[N3++], _e = (o2[B >>> 24] << 24 | o2[x3 >>> 16 & 255] << 16 | o2[S >>> 8 & 255] << 8 | o2[E3 & 255]) ^ e[N3++], q = q >>> 0, L2 = L2 >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q, L2, ge, _e];
  }
  var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt2 = function() {
    for (var t = new Array(256), e = 0;e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], o2 = [], f = [[], [], [], []], p2 = [[], [], [], []], m2 = 0, y2 = 0, M2 = 0;M2 < 256; ++M2) {
      var x3 = y2 ^ y2 << 1 ^ y2 << 2 ^ y2 << 3 ^ y2 << 4;
      x3 = x3 >>> 8 ^ x3 & 255 ^ 99, r[m2] = x3, o2[x3] = m2;
      var S = t[m2], E3 = t[S], B = t[E3], q = t[x3] * 257 ^ x3 * 16843008;
      f[0][m2] = q << 24 | q >>> 8, f[1][m2] = q << 16 | q >>> 16, f[2][m2] = q << 8 | q >>> 24, f[3][m2] = q, q = B * 16843009 ^ E3 * 65537 ^ S * 257 ^ m2 * 16843008, p2[0][x3] = q << 24 | q >>> 8, p2[1][x3] = q << 16 | q >>> 16, p2[2][x3] = q << 8 | q >>> 24, p2[3][x3] = q, m2 === 0 ? m2 = y2 = 1 : (m2 = S ^ t[t[t[B ^ S]]], y2 ^= t[t[y2]]);
    }
    return { SBOX: r, INV_SBOX: o2, SUB_MIX: f, INV_SUB_MIX: p2 };
  }();
  function gr3(t) {
    this._key = Hu(t), this._reset();
  }
  gr3.blockSize = 4 * 4;
  gr3.keySize = 256 / 8;
  gr3.prototype.blockSize = gr3.blockSize;
  gr3.prototype.keySize = gr3.keySize;
  gr3.prototype._reset = function() {
    for (var t = this._key, e = t.length, r = e + 6, o2 = (r + 1) * 4, f = [], p2 = 0;p2 < e; p2++)
      f[p2] = t[p2];
    for (p2 = e;p2 < o2; p2++) {
      var m2 = f[p2 - 1];
      p2 % e === 0 ? (m2 = m2 << 8 | m2 >>> 24, m2 = kt2.SBOX[m2 >>> 24] << 24 | kt2.SBOX[m2 >>> 16 & 255] << 16 | kt2.SBOX[m2 >>> 8 & 255] << 8 | kt2.SBOX[m2 & 255], m2 ^= M9[p2 / e | 0] << 24) : e > 6 && p2 % e === 4 && (m2 = kt2.SBOX[m2 >>> 24] << 24 | kt2.SBOX[m2 >>> 16 & 255] << 16 | kt2.SBOX[m2 >>> 8 & 255] << 8 | kt2.SBOX[m2 & 255]), f[p2] = f[p2 - e] ^ m2;
    }
    for (var y2 = [], M2 = 0;M2 < o2; M2++) {
      var x3 = o2 - M2, S = f[x3 - (M2 % 4 ? 0 : 4)];
      M2 < 4 || x3 <= 4 ? y2[M2] = S : y2[M2] = kt2.INV_SUB_MIX[0][kt2.SBOX[S >>> 24]] ^ kt2.INV_SUB_MIX[1][kt2.SBOX[S >>> 16 & 255]] ^ kt2.INV_SUB_MIX[2][kt2.SBOX[S >>> 8 & 255]] ^ kt2.INV_SUB_MIX[3][kt2.SBOX[S & 255]];
    }
    this._nRounds = r, this._keySchedule = f, this._invKeySchedule = y2;
  };
  gr3.prototype.encryptBlockRaw = function(t) {
    return t = Hu(t), Mm(t, this._keySchedule, kt2.SUB_MIX, kt2.SBOX, this._nRounds);
  };
  gr3.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
  };
  gr3.prototype.decryptBlock = function(t) {
    t = Hu(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = Mm(t, this._invKeySchedule, kt2.INV_SUB_MIX, kt2.INV_SBOX, this._nRounds), o2 = Ms.allocUnsafe(16);
    return o2.writeUInt32BE(r[0], 0), o2.writeUInt32BE(r[3], 4), o2.writeUInt32BE(r[2], 8), o2.writeUInt32BE(r[1], 12), o2;
  };
  gr3.prototype.scrub = function() {
    zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
  };
  _m.exports.AES = gr3;
});
var Em = T((DT, Sm) => {
  var wf = Te().Buffer, _9 = wf.alloc(16, 0);
  function x9(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function xm(t) {
    var e = wf.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function Ra(t) {
    this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
  }
  Ra.prototype.ghash = function(t) {
    for (var e = -1;++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  Ra.prototype._multiply = function() {
    for (var t = x9(this.h), e = [0, 0, 0, 0], r, o2, f, p2 = -1;++p2 < 128; ) {
      for (o2 = (this.state[~~(p2 / 8)] & 1 << 7 - p2 % 8) !== 0, o2 && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f = (t[3] & 1) !== 0, r = 3;r > 0; r--)
        t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
      t[0] = t[0] >>> 1, f && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = xm(e);
  };
  Ra.prototype.update = function(t) {
    this.cache = wf.concat([this.cache, t]);
    for (var e;this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  Ra.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
  };
  Sm.exports = Ra;
});
var Wu = T((PT, Bm) => {
  var S9 = Aa(), rr2 = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
  function B9(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var o2 = Math.min(t.length, e.length), f = 0;f < o2; ++f)
      r += t[f] ^ e[f];
    return r;
  }
  function q9(t, e, r) {
    if (e.length === 12)
      return t._finID = rr2.concat([e, rr2.from([0, 0, 0, 1])]), rr2.concat([e, rr2.from([0, 0, 0, 2])]);
    var o2 = new Rm(r), f = e.length, p2 = f % 16;
    o2.update(e), p2 && (p2 = 16 - p2, o2.update(rr2.alloc(p2, 0))), o2.update(rr2.alloc(8, 0));
    var m2 = f * 8, y2 = rr2.alloc(8);
    y2.writeUIntBE(m2, 0, 8), o2.update(y2), t._finID = o2.state;
    var M2 = rr2.from(t._finID);
    return R9(M2), M2;
  }
  function Bn(t, e, r, o2) {
    Am.call(this);
    var f = rr2.alloc(4, 0);
    this._cipher = new S9.AES(e);
    var p2 = this._cipher.encryptBlock(f);
    this._ghash = new Rm(p2), r = q9(this, r, p2), this._prev = rr2.from(r), this._cache = rr2.allocUnsafe(0), this._secCache = rr2.allocUnsafe(0), this._decrypt = o2, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  E9(Bn, Am);
  Bn.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = rr2.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
  };
  Bn.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && B9(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  Bn.prototype.getAuthTag = function() {
    if (this._decrypt || !rr2.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  Bn.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  Bn.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  Bm.exports = Bn;
});
var ju = T((CT, Im) => {
  var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
  function _s(t, e, r, o2) {
    qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o2, this._mode = t;
  }
  T9(_s, qm);
  _s.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  _s.prototype._final = function() {
    this._cipher.scrub();
  };
  Im.exports = _s;
});
var Ba = T((OT, Tm) => {
  var qn = Te().Buffer, k9 = Ao();
  function L9(t, e, r, o2) {
    if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var f = r / 8, p2 = qn.alloc(f), m2 = qn.alloc(o2 || 0), y2 = qn.alloc(0);f > 0 || o2 > 0; ) {
      var M2 = new k9;
      M2.update(y2), M2.update(t), e && M2.update(e), y2 = M2.digest();
      var x3 = 0;
      if (f > 0) {
        var S = p2.length - f;
        x3 = Math.min(f, y2.length), y2.copy(p2, S, 0, x3), f -= x3;
      }
      if (x3 < y2.length && o2 > 0) {
        var E3 = m2.length - o2, B = Math.min(o2, y2.length - x3);
        y2.copy(m2, E3, x3, x3 + B), o2 -= B;
      }
    }
    return y2.fill(0), { key: p2, iv: m2 };
  }
  Tm.exports = L9;
});
var Dm = T((Zu) => {
  var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
  function qa(t, e, r) {
    Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
  }
  O9(qa, Lm);
  qa.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, o2 = [];e = this._cache.get(); )
      r = this._mode.encrypt(this, e), o2.push(r);
    return Mi.concat(o2);
  };
  var F9 = Mi.alloc(16, 16);
  qa.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(F9))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  qa.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function xs() {
    this.cache = Mi.allocUnsafe(0);
  }
  xs.prototype.add = function(t) {
    this.cache = Mi.concat([this.cache, t]);
  };
  xs.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  xs.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
      e.writeUInt8(t, r);
    return Mi.concat([this.cache, e]);
  };
  function Nm(t, e, r) {
    var o2 = km[t.toLowerCase()];
    if (!o2)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = Mi.from(e)), e.length !== o2.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = Mi.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
      throw new TypeError("invalid iv length " + r.length);
    return o2.type === "stream" ? new D9(o2.module, e, r) : o2.type === "auth" ? new N9(o2.module, e, r) : new qa(o2.module, e, r);
  }
  function U9(t, e) {
    var r = km[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var o2 = C9(e, false, r.key, r.iv);
    return Nm(t, o2.key, o2.iv);
  }
  Zu.createCipheriv = Nm;
  Zu.createCipher = U9;
});
var Fm = T((Vu) => {
  var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
  function Ia(t, e, r) {
    Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
  }
  j9(Ia, Cm);
  Ia.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, o2 = [];e = this._cache.get(this._autopadding); )
      r = this._mode.decrypt(this, e), o2.push(r);
    return Mf.concat(o2);
  };
  Ia.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return Z9(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  Ia.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Ss() {
    this.cache = Mf.allocUnsafe(0);
  }
  Ss.prototype.add = function(t) {
    this.cache = Mf.concat([this.cache, t]);
  };
  Ss.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  Ss.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function Z9(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r = -1;++r < e; )
      if (t[r + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function Om(t, e, r) {
    var o2 = Pm[t.toLowerCase()];
    if (!o2)
      throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = Mf.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
      throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = Mf.from(e)), e.length !== o2.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return o2.type === "stream" ? new H9(o2.module, e, r, true) : o2.type === "auth" ? new z9(o2.module, e, r, true) : new Ia(o2.module, e, r);
  }
  function V9(t, e) {
    var r = Pm[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var o2 = K9(e, false, r.key, r.iv);
    return Om(t, o2.key, o2.iv);
  }
  Vu.createDecipher = V9;
  Vu.createDecipheriv = Om;
});
var Es = T((Nr) => {
  var Um = Dm(), zm = Fm(), $9 = Fu();
  function G9() {
    return Object.keys($9);
  }
  Nr.createCipher = Nr.Cipher = Um.createCipher;
  Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
  Nr.createDecipher = Nr.Decipher = zm.createDecipher;
  Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
  Nr.listCiphers = Nr.getCiphers = G9;
});
var Hm = T((_i) => {
  _i["des-ecb"] = { key: 8, iv: 0 };
  _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
  _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
  _i["des-ede3"] = { key: 24, iv: 0 };
  _i["des-ede-cbc"] = { key: 16, iv: 8 };
  _i["des-ede"] = { key: 16, iv: 0 };
});
var Vm = T((Dr) => {
  var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
  function Y9(t, e) {
    t = t.toLowerCase();
    var r, o2;
    if (Ki[t])
      r = Ki[t].key, o2 = Ki[t].iv;
    else if (xi[t])
      r = xi[t].key * 8, o2 = xi[t].iv;
    else
      throw new TypeError("invalid suite type");
    var f = Km(e, false, r, o2);
    return jm(t, f.key, f.iv);
  }
  function X9(t, e) {
    t = t.toLowerCase();
    var r, o2;
    if (Ki[t])
      r = Ki[t].key, o2 = Ki[t].iv;
    else if (xi[t])
      r = xi[t].key * 8, o2 = xi[t].iv;
    else
      throw new TypeError("invalid suite type");
    var f = Km(e, false, r, o2);
    return Zm(t, f.key, f.iv);
  }
  function jm(t, e, r) {
    if (t = t.toLowerCase(), Ki[t])
      return $u.createCipheriv(t, e, r);
    if (xi[t])
      return new Wm({ key: e, iv: r, mode: t });
    throw new TypeError("invalid suite type");
  }
  function Zm(t, e, r) {
    if (t = t.toLowerCase(), Ki[t])
      return $u.createDecipheriv(t, e, r);
    if (xi[t])
      return new Wm({ key: e, iv: r, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function J9() {
    return Object.keys(xi).concat($u.getCiphers());
  }
  Dr.createCipher = Dr.Cipher = Y9;
  Dr.createCipheriv = Dr.Cipheriv = jm;
  Dr.createDecipher = Dr.Decipher = X9;
  Dr.createDecipheriv = Dr.Decipheriv = Zm;
  Dr.listCiphers = Dr.getCiphers = J9;
});
var ji = T(() => {
});
var Yu = T(($m, Gu) => {
  (function(t, e) {
    function r(v3, i) {
      if (!v3)
        throw new Error(i || "Assertion failed");
    }
    function o2(v3, i) {
      v3.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v3.prototype = new a2, v3.prototype.constructor = v3;
    }
    function f(v3, i, a2) {
      if (f.isBN(v3))
        return v3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v3 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v3 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h2) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h2);
      if (typeof i == "object")
        return this._initArray(i, a2, h2);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h2) : (this._parseBase(i, a2, s), h2 === "le" && this._initArray(this.toArray(), a2, h2)));
    }, f.prototype._initNumber = function(i, a2, h2) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), a2, h2);
    }, f.prototype._initArray = function(i, a2, h2) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h2 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h2 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v3, i) {
      var a2 = v3.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y2(v3, i, a2) {
      var h2 = m2(v3, a2);
      return a2 - 1 >= i && (h2 |= m2(v3, a2 - 1) << 4), h2;
    }
    f.prototype._parseHex = function(i, a2, h2) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h2 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v3, i, a2, h2) {
      for (var s = 0, u = Math.min(v3.length, a2), c = i;c < u; c++) {
        var b3 = v3.charCodeAt(c) - 48;
        s *= h2, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h2) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h2, b3 = c % s, l2 = Math.min(c, c - b3) + h2, n = 0, d2 = h2;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h2;
      if (i === 16 || i === "hex") {
        h2 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h2 = x3[6 - l2.length] + l2 + h2 : h2 = l2 + h2, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h2 = u.toString(16) + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h2 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h2 = g2 + h2 : h2 = x3[n - g2.length] + g2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h2) {
      var s = this.byteLength(), u = h2 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h2 = 0;
      return a2 >= 4096 && (h2 += 13, a2 >>>= 13), a2 >= 64 && (h2 += 7, a2 >>>= 7), a2 >= 8 && (h2 += 4, a2 >>>= 4), a2 >= 2 && (h2 += 2, a2 >>>= 2), h2 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h2 = 0;
      return (a2 & 8191) === 0 && (h2 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h2 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h2 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h2 += 2, a2 >>>= 2), (a2 & 1) === 0 && h2++, h2;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v3) {
      for (var i = new Array(v3.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h2 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v3.words[h2] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h2 = this._zeroBits(this.words[a2]);
        if (i += h2, h2 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h2 = 0;h2 < a2.length; h2++)
        this.words[h2] = this.words[h2] & i.words[h2];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h2;
      this.length > i.length ? (a2 = this, h2 = i) : (a2 = i, h2 = this);
      for (var s = 0;s < h2.length; s++)
        this.words[s] = a2.words[s] ^ h2.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h2 = i % 26;
      this._expand(a2), h2 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h2 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h2), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h2 = i / 26 | 0, s = i % 26;
      return this._expand(h2 + 1), a2 ? this.words[h2] = this.words[h2] | 1 << s : this.words[h2] = this.words[h2] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h2, s;
      this.length > i.length ? (h2 = this, s = i) : (h2 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h2.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h2.length; c++)
        a2 = (h2.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h2.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h2 !== this)
        for (;c < h2.length; c++)
          this.words[c] = h2.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h2 = this.cmp(i);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h2 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative;
      var h2 = v3.length + i.length | 0;
      a2.length = h2, h2 = h2 - 1 | 0;
      var s = v3.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h2; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _2 = Math.max(0, n - v3.length + 1);_2 <= g2; _2++) {
          var A2 = n - _2 | 0;
          s = v3.words[A2] | 0, u = i.words[_2] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h2) {
      var s = i.words, u = a2.words, c = h2.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _2 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z2 = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h2.negative = i.negative ^ a2.negative, h2.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_2, X) | 0, d2 = Math.imul(_2, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_2, Q) | 0, d2 = d2 + Math.imul(_2, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_2, te) | 0, d2 = d2 + Math.imul(_2, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_2, ie) | 0, d2 = d2 + Math.imul(_2, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_2, fe) | 0, d2 = d2 + Math.imul(_2, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_2, oe) | 0, d2 = d2 + Math.imul(_2, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_2, he) | 0, d2 = d2 + Math.imul(_2, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z2, X) | 0, d2 = Math.imul(Z2, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_2, le) | 0, d2 = d2 + Math.imul(_2, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z2, Q) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_2, ce2) | 0, d2 = d2 + Math.imul(_2, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_2, ve) | 0, d2 = d2 + Math.imul(_2, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z2, ce2) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h2.length++), h2;
    };
    Math.imul || (L2 = q);
    function ge(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative, a2.length = v3.length + i.length;
      for (var h2 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h2 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v3.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v3.words[d2] | 0, g2 = i.words[n] | 0, _2 = w3 * g2, A2 = _2 & 67108863;
          c = c + (_2 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h2 = c, c = s;
      }
      return h2 !== 0 ? a2.words[u] = h2 : a2.length--, a2.strip();
    }
    function _e(v3, i, a2) {
      var h2 = new N3;
      return h2.mulp(v3, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h2, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h2 = L2(this, i, a2) : s < 63 ? h2 = q(this, i, a2) : s < 1024 ? h2 = ge(this, i, a2) : h2 = _e(this, i, a2), h2;
    };
    function N3(v3, i) {
      this.x = v3, this.y = i;
    }
    N3.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h2 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h2, i);
      return a2;
    }, N3.prototype.revBin = function(i, a2, h2) {
      if (i === 0 || i === h2 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N3.prototype.permute = function(i, a2, h2, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h2[i[b3]];
    }, N3.prototype.transform = function(i, a2, h2, s, u, c) {
      this.permute(c, i, a2, h2, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _2 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h2[w3 + A2], I = s[w3 + A2], Me = h2[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _2 * k;
            k = g2 * k + _2 * Me, Me = D2, h2[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h2[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _2, _2 = n * _2 + d2 * g2, g2 = D2);
          }
    }, N3.prototype.guessLen13b = function(i, a2) {
      var h2 = Math.max(a2, i) | 1, s = h2 & 1, u = 0;
      for (h2 = h2 / 2 | 0;h2; h2 = h2 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N3.prototype.conjugate = function(i, a2, h2) {
      if (!(h2 <= 1))
        for (var s = 0;s < h2 / 2; s++) {
          var u = i[s];
          i[s] = i[h2 - s - 1], i[h2 - s - 1] = u, u = a2[s], a2[s] = -a2[h2 - s - 1], a2[h2 - s - 1] = -u;
        }
    }, N3.prototype.normalize13b = function(i, a2) {
      for (var h2 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h2;
        i[s] = u & 67108863, u < 67108864 ? h2 = 0 : h2 = u / 67108864 | 0;
      }
      return i;
    }, N3.prototype.convert13b = function(i, a2, h2, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h2[2 * c] = u & 8191, u = u >>> 13, h2[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h2[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N3.prototype.stub = function(i) {
      for (var a2 = new Array(i), h2 = 0;h2 < i; h2++)
        a2[h2] = 0;
      return a2;
    }, N3.prototype.mulp = function(i, a2, h2) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _2 = h2.words;
      _2.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h2.negative = i.negative ^ a2.negative, h2.length = i.length + a2.length, h2.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h2 = 0;h2 < this.length; h2++) {
        var s = (this.words[h2] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h2] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h2] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h2 = this, s = 0;s < a2.length && a2[s] === 0; s++, h2 = h2.sqr())
        ;
      if (++s < a2.length)
        for (var u = h2.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h2 = h2.mul(u));
      return h2;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h2 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h2] = this.words[u];
        for (u = 0;u < h2; u++)
          this.words[u] = 0;
        this.length += h2;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h2) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h2;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h2) {
      return r(this.negative === 0), this.iushrn(i, a2, h2);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return false;
      var u = this.words[h2];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (a2 !== 0 && h2++, this.length = Math.min(h2, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h2) {
      var s = i.length + h2, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h2] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h2] = c & 67108863;
      }
      for (;u < this.length - h2; u++)
        c = (this.words[u + h2] | 0) + b3, b3 = c >> 26, this.words[u + h2] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h2 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h2 = 26 - b3, h2 !== 0 && (u = u.ushln(h2), s.iushln(h2), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _2 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g2);s.negative !== 0; )
          _2--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _2);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h2 !== 0 && s.iushrn(h2), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h2) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h2 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h2.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h2 = 0, s = this.length - 1;s >= 0; s--)
        h2 = (a2 * h2 + (this.words[s] | 0)) % i;
      return h2;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = (this.words[h2] | 0) + a2 * 67108864;
        this.words[h2] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h2.isEven(); )
        a2.iushrn(1), h2.iushrn(1), ++l2;
      for (var n = h2.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _2 = 0, A2 = 1;(h2.words[0] & A2) === 0 && _2 < 26; ++_2, A2 <<= 1)
          ;
        if (_2 > 0)
          for (h2.iushrn(_2);_2-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(c), u.isub(b3)) : (h2.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h2.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h2.clone();a2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h2.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h2.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(u)) : (h2.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h2 = i.clone();
      a2.negative = 0, h2.negative = 0;
      for (var s = 0;a2.isEven() && h2.isEven(); s++)
        a2.iushrn(1), h2.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h2.isEven(); )
          h2.iushrn(1);
        var u = a2.cmp(h2);
        if (u < 0) {
          var c = a2;
          a2 = h2, h2 = c;
        } else if (u === 0 || h2.cmpn(1) === 0)
          break;
        a2.isub(h2);
      } while (true);
      return h2.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= s, this;
      for (var u = s, c = h2;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h2 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = this.words[h2] | 0, u = i.words[h2] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P3(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v3, i) {
      this.name = v3, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h2 = a2.bitLength();
      while (h2 > this.n);
      var s = h2 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h2 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h2, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h2) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = i.words[h2] | 0;
        a2 += s * 977, i.words[h2] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = (i.words[h2] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h2] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P3(v3) {
      if (typeof v3 == "string") {
        var i = f._prime(v3);
        this.m = i.p, this.prime = i;
      } else
        r(v3.gtn(1), "modulus must be greater than 1"), this.m = v3, this.prime = null;
    }
    P3.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P3.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P3.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P3.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P3.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.add(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, P3.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.iadd(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, P3.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.sub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, P3.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.isub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, P3.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P3.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P3.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P3.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P3.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P3.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h2 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h2);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _2 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _2);
        var I = this.pow(d2, new f(1).iushln(_2 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _2 = R3;
      }
      return w3;
    }, P3.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P3.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h2 = 4, s = new Array(1 << h2);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h2 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P3.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P3.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v3) {
      P3.call(this, v3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P3), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h2 = i.imul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h2 = i.mul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof Gu > "u" || Gu, $m);
});
var Ym = T((Gm, Xu) => {
  (function(t, e) {
    function r(v3, i) {
      if (!v3)
        throw new Error(i || "Assertion failed");
    }
    function o2(v3, i) {
      v3.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v3.prototype = new a2, v3.prototype.constructor = v3;
    }
    function f(v3, i, a2) {
      if (f.isBN(v3))
        return v3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v3 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v3 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h2) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h2);
      if (typeof i == "object")
        return this._initArray(i, a2, h2);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h2) : (this._parseBase(i, a2, s), h2 === "le" && this._initArray(this.toArray(), a2, h2)));
    }, f.prototype._initNumber = function(i, a2, h2) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), a2, h2);
    }, f.prototype._initArray = function(i, a2, h2) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h2 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h2 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v3, i) {
      var a2 = v3.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y2(v3, i, a2) {
      var h2 = m2(v3, a2);
      return a2 - 1 >= i && (h2 |= m2(v3, a2 - 1) << 4), h2;
    }
    f.prototype._parseHex = function(i, a2, h2) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h2 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v3, i, a2, h2) {
      for (var s = 0, u = Math.min(v3.length, a2), c = i;c < u; c++) {
        var b3 = v3.charCodeAt(c) - 48;
        s *= h2, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h2) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h2, b3 = c % s, l2 = Math.min(c, c - b3) + h2, n = 0, d2 = h2;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h2;
      if (i === 16 || i === "hex") {
        h2 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h2 = x3[6 - l2.length] + l2 + h2 : h2 = l2 + h2, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h2 = u.toString(16) + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h2 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h2 = g2 + h2 : h2 = x3[n - g2.length] + g2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h2) {
      var s = this.byteLength(), u = h2 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h2 = 0;
      return a2 >= 4096 && (h2 += 13, a2 >>>= 13), a2 >= 64 && (h2 += 7, a2 >>>= 7), a2 >= 8 && (h2 += 4, a2 >>>= 4), a2 >= 2 && (h2 += 2, a2 >>>= 2), h2 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h2 = 0;
      return (a2 & 8191) === 0 && (h2 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h2 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h2 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h2 += 2, a2 >>>= 2), (a2 & 1) === 0 && h2++, h2;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v3) {
      for (var i = new Array(v3.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h2 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v3.words[h2] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h2 = this._zeroBits(this.words[a2]);
        if (i += h2, h2 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h2 = 0;h2 < a2.length; h2++)
        this.words[h2] = this.words[h2] & i.words[h2];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h2;
      this.length > i.length ? (a2 = this, h2 = i) : (a2 = i, h2 = this);
      for (var s = 0;s < h2.length; s++)
        this.words[s] = a2.words[s] ^ h2.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h2 = i % 26;
      this._expand(a2), h2 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h2 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h2), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h2 = i / 26 | 0, s = i % 26;
      return this._expand(h2 + 1), a2 ? this.words[h2] = this.words[h2] | 1 << s : this.words[h2] = this.words[h2] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h2, s;
      this.length > i.length ? (h2 = this, s = i) : (h2 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h2.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h2.length; c++)
        a2 = (h2.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h2.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h2 !== this)
        for (;c < h2.length; c++)
          this.words[c] = h2.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h2 = this.cmp(i);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h2 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative;
      var h2 = v3.length + i.length | 0;
      a2.length = h2, h2 = h2 - 1 | 0;
      var s = v3.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h2; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _2 = Math.max(0, n - v3.length + 1);_2 <= g2; _2++) {
          var A2 = n - _2 | 0;
          s = v3.words[A2] | 0, u = i.words[_2] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h2) {
      var s = i.words, u = a2.words, c = h2.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _2 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z2 = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h2.negative = i.negative ^ a2.negative, h2.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_2, X) | 0, d2 = Math.imul(_2, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_2, Q) | 0, d2 = d2 + Math.imul(_2, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_2, te) | 0, d2 = d2 + Math.imul(_2, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_2, ie) | 0, d2 = d2 + Math.imul(_2, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_2, fe) | 0, d2 = d2 + Math.imul(_2, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_2, oe) | 0, d2 = d2 + Math.imul(_2, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_2, he) | 0, d2 = d2 + Math.imul(_2, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z2, X) | 0, d2 = Math.imul(Z2, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_2, le) | 0, d2 = d2 + Math.imul(_2, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z2, Q) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_2, ce2) | 0, d2 = d2 + Math.imul(_2, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_2, ve) | 0, d2 = d2 + Math.imul(_2, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z2, ce2) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h2.length++), h2;
    };
    Math.imul || (L2 = q);
    function ge(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative, a2.length = v3.length + i.length;
      for (var h2 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h2 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v3.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v3.words[d2] | 0, g2 = i.words[n] | 0, _2 = w3 * g2, A2 = _2 & 67108863;
          c = c + (_2 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h2 = c, c = s;
      }
      return h2 !== 0 ? a2.words[u] = h2 : a2.length--, a2.strip();
    }
    function _e(v3, i, a2) {
      var h2 = new N3;
      return h2.mulp(v3, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h2, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h2 = L2(this, i, a2) : s < 63 ? h2 = q(this, i, a2) : s < 1024 ? h2 = ge(this, i, a2) : h2 = _e(this, i, a2), h2;
    };
    function N3(v3, i) {
      this.x = v3, this.y = i;
    }
    N3.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h2 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h2, i);
      return a2;
    }, N3.prototype.revBin = function(i, a2, h2) {
      if (i === 0 || i === h2 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N3.prototype.permute = function(i, a2, h2, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h2[i[b3]];
    }, N3.prototype.transform = function(i, a2, h2, s, u, c) {
      this.permute(c, i, a2, h2, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _2 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h2[w3 + A2], I = s[w3 + A2], Me = h2[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _2 * k;
            k = g2 * k + _2 * Me, Me = D2, h2[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h2[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _2, _2 = n * _2 + d2 * g2, g2 = D2);
          }
    }, N3.prototype.guessLen13b = function(i, a2) {
      var h2 = Math.max(a2, i) | 1, s = h2 & 1, u = 0;
      for (h2 = h2 / 2 | 0;h2; h2 = h2 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N3.prototype.conjugate = function(i, a2, h2) {
      if (!(h2 <= 1))
        for (var s = 0;s < h2 / 2; s++) {
          var u = i[s];
          i[s] = i[h2 - s - 1], i[h2 - s - 1] = u, u = a2[s], a2[s] = -a2[h2 - s - 1], a2[h2 - s - 1] = -u;
        }
    }, N3.prototype.normalize13b = function(i, a2) {
      for (var h2 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h2;
        i[s] = u & 67108863, u < 67108864 ? h2 = 0 : h2 = u / 67108864 | 0;
      }
      return i;
    }, N3.prototype.convert13b = function(i, a2, h2, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h2[2 * c] = u & 8191, u = u >>> 13, h2[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h2[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N3.prototype.stub = function(i) {
      for (var a2 = new Array(i), h2 = 0;h2 < i; h2++)
        a2[h2] = 0;
      return a2;
    }, N3.prototype.mulp = function(i, a2, h2) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _2 = h2.words;
      _2.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h2.negative = i.negative ^ a2.negative, h2.length = i.length + a2.length, h2.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h2 = 0;h2 < this.length; h2++) {
        var s = (this.words[h2] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h2] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h2] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h2 = this, s = 0;s < a2.length && a2[s] === 0; s++, h2 = h2.sqr())
        ;
      if (++s < a2.length)
        for (var u = h2.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h2 = h2.mul(u));
      return h2;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h2 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h2] = this.words[u];
        for (u = 0;u < h2; u++)
          this.words[u] = 0;
        this.length += h2;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h2) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h2;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h2) {
      return r(this.negative === 0), this.iushrn(i, a2, h2);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return false;
      var u = this.words[h2];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (a2 !== 0 && h2++, this.length = Math.min(h2, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h2) {
      var s = i.length + h2, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h2] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h2] = c & 67108863;
      }
      for (;u < this.length - h2; u++)
        c = (this.words[u + h2] | 0) + b3, b3 = c >> 26, this.words[u + h2] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h2 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h2 = 26 - b3, h2 !== 0 && (u = u.ushln(h2), s.iushln(h2), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _2 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g2);s.negative !== 0; )
          _2--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _2);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h2 !== 0 && s.iushrn(h2), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h2) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h2 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h2.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h2 = 0, s = this.length - 1;s >= 0; s--)
        h2 = (a2 * h2 + (this.words[s] | 0)) % i;
      return h2;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = (this.words[h2] | 0) + a2 * 67108864;
        this.words[h2] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h2.isEven(); )
        a2.iushrn(1), h2.iushrn(1), ++l2;
      for (var n = h2.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _2 = 0, A2 = 1;(h2.words[0] & A2) === 0 && _2 < 26; ++_2, A2 <<= 1)
          ;
        if (_2 > 0)
          for (h2.iushrn(_2);_2-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(c), u.isub(b3)) : (h2.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h2.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h2.clone();a2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h2.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h2.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(u)) : (h2.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h2 = i.clone();
      a2.negative = 0, h2.negative = 0;
      for (var s = 0;a2.isEven() && h2.isEven(); s++)
        a2.iushrn(1), h2.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h2.isEven(); )
          h2.iushrn(1);
        var u = a2.cmp(h2);
        if (u < 0) {
          var c = a2;
          a2 = h2, h2 = c;
        } else if (u === 0 || h2.cmpn(1) === 0)
          break;
        a2.isub(h2);
      } while (true);
      return h2.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= s, this;
      for (var u = s, c = h2;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h2 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = this.words[h2] | 0, u = i.words[h2] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P3(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v3, i) {
      this.name = v3, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h2 = a2.bitLength();
      while (h2 > this.n);
      var s = h2 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h2 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h2, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h2) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = i.words[h2] | 0;
        a2 += s * 977, i.words[h2] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = (i.words[h2] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h2] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P3(v3) {
      if (typeof v3 == "string") {
        var i = f._prime(v3);
        this.m = i.p, this.prime = i;
      } else
        r(v3.gtn(1), "modulus must be greater than 1"), this.m = v3, this.prime = null;
    }
    P3.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P3.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P3.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P3.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P3.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.add(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, P3.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.iadd(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, P3.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.sub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, P3.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.isub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, P3.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P3.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P3.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P3.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P3.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P3.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h2 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h2);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _2 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _2);
        var I = this.pow(d2, new f(1).iushln(_2 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _2 = R3;
      }
      return w3;
    }, P3.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P3.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h2 = 4, s = new Array(1 << h2);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h2 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P3.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P3.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v3) {
      P3.call(this, v3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P3), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h2 = i.imul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h2 = i.mul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof Xu > "u" || Xu, Gm);
});
var Xm = T(() => {
});
var As = T(($T, el) => {
  var Ju;
  el.exports = function(e) {
    return Ju || (Ju = new Zi(null)), Ju.generate(e);
  };
  function Zi(t) {
    this.rand = t;
  }
  el.exports.Rand = Zi;
  Zi.prototype.generate = function(e) {
    return this._rand(e);
  };
  Zi.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), o2 = 0;o2 < r.length; o2++)
      r[o2] = this.rand.getByte();
    return r;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (Zi.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (Qu = Xm(), typeof Qu.randomBytes != "function")
        throw new Error("Not supported");
      Zi.prototype._rand = function(e) {
        return Qu.randomBytes(e);
      };
    } catch {
    }
  var Qu;
});
var tl = T((GT, Jm) => {
  var In = Ym(), Q9 = As();
  function Tn(t) {
    this.rand = t || new Q9.Rand;
  }
  Jm.exports = Tn;
  Tn.create = function(e) {
    return new Tn(e);
  };
  Tn.prototype._randbelow = function(e) {
    var r = e.bitLength(), o2 = Math.ceil(r / 8);
    do
      var f = new In(this.rand.generate(o2));
    while (f.cmp(e) >= 0);
    return f;
  };
  Tn.prototype._randrange = function(e, r) {
    var o2 = r.sub(e);
    return e.add(this._randbelow(o2));
  };
  Tn.prototype.test = function(e, r, o2) {
    var f = e.bitLength(), p2 = In.mont(e), m2 = new In(1).toRed(p2);
    r || (r = Math.max(1, f / 48 | 0));
    for (var y2 = e.subn(1), M2 = 0;!y2.testn(M2); M2++)
      ;
    for (var x3 = e.shrn(M2), S = y2.toRed(p2), E3 = true;r > 0; r--) {
      var B = this._randrange(new In(2), y2);
      o2 && o2(B);
      var q = B.toRed(p2).redPow(x3);
      if (!(q.cmp(m2) === 0 || q.cmp(S) === 0)) {
        for (var L2 = 1;L2 < M2; L2++) {
          if (q = q.redSqr(), q.cmp(m2) === 0)
            return false;
          if (q.cmp(S) === 0)
            break;
        }
        if (L2 === M2)
          return false;
      }
    }
    return E3;
  };
  Tn.prototype.getDivisor = function(e, r) {
    var o2 = e.bitLength(), f = In.mont(e), p2 = new In(1).toRed(f);
    r || (r = Math.max(1, o2 / 48 | 0));
    for (var m2 = e.subn(1), y2 = 0;!m2.testn(y2); y2++)
      ;
    for (var M2 = e.shrn(y2), x3 = m2.toRed(f);r > 0; r--) {
      var S = this._randrange(new In(2), m2), E3 = e.gcd(S);
      if (E3.cmpn(1) !== 0)
        return E3;
      var B = S.toRed(f).redPow(M2);
      if (!(B.cmp(p2) === 0 || B.cmp(x3) === 0)) {
        for (var q = 1;q < y2; q++) {
          if (B = B.redSqr(), B.cmp(p2) === 0)
            return B.fromRed().subn(1).gcd(e);
          if (B.cmp(x3) === 0)
            break;
        }
        if (q === y2)
          return B = B.redSqr(), B.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var ol = T((ek, tg) => {
  var eS = on();
  tg.exports = al;
  al.simpleSieve = nl;
  al.fermatTest = fl;
  var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
  function sS() {
    if (rl !== null)
      return rl;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r = 1, o2 = 3;o2 < t; o2 += 2) {
      for (var f = Math.ceil(Math.sqrt(o2)), p2 = 0;p2 < r && e[p2] <= f && o2 % e[p2] !== 0; p2++)
        ;
      r !== p2 && e[p2] <= f || (e[r++] = o2);
    }
    return rl = e, e;
  }
  function nl(t) {
    for (var e = sS(), r = 0;r < e.length; r++)
      if (t.modn(e[r]) === 0)
        return t.cmpn(e[r]) === 0;
    return true;
  }
  function fl(t) {
    var e = Ht.mont(t);
    return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function al(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
    e = new Ht(e);
    for (var r, o2;; ) {
      for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
        r.ishrn(1);
      if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
        if (!e.cmp(nS))
          for (;r.mod(fS).cmp(aS); )
            r.iadd(eg);
      } else
        for (;r.mod(tS).cmp(oS); )
          r.iadd(eg);
      if (o2 = r.shrn(1), nl(o2) && nl(r) && fl(o2) && fl(r) && Qm.test(o2) && Qm.test(r))
        return r;
    }
  }
});
var rg = T((tk, hS) => {
  hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var ag = T((rk, fg) => {
  var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
  fg.exports = Si;
  function mS(t, e) {
    return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr(t), this;
  }
  function gS(t, e) {
    return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr(t), this;
  }
  var Rs = {};
  function yS(t, e) {
    var r = e.toString("hex"), o2 = [r, t.toString(16)].join("_");
    if (o2 in Rs)
      return Rs[o2];
    var f = 0;
    if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
      return f += 1, r === "02" || r === "05" ? f += 8 : f += 4, Rs[o2] = f, f;
    ig.test(t.shrn(1)) || (f += 2);
    var p2;
    switch (r) {
      case "02":
        t.mod(lS).cmp(dS) && (f += 8);
        break;
      case "05":
        p2 = t.mod(cS), p2.cmp(pS) && p2.cmp(vS) && (f += 8);
        break;
      default:
        f += 4;
    }
    return Rs[o2] = f, f;
  }
  function Si(t, e, r) {
    this.setGenerator(e), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
  }
  Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
  } });
  Si.prototype.generateKeys = function() {
    return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  Si.prototype.computeSecret = function(t) {
    t = new yr(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o2 = this.getPrime();
    if (r.length < o2.length) {
      var f = new Buffer(o2.length - r.length);
      f.fill(0), r = Buffer.concat([f, r]);
    }
    return r;
  };
  Si.prototype.getPublicKey = function(e) {
    return Bs(this._pub, e);
  };
  Si.prototype.getPrivateKey = function(e) {
    return Bs(this._priv, e);
  };
  Si.prototype.getPrime = function(t) {
    return Bs(this.__prime, t);
  };
  Si.prototype.getGenerator = function(t) {
    return Bs(this._gen, t);
  };
  Si.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr(t), this;
  };
  function Bs(t, e) {
    var r = new Buffer(t.toArray());
    return e ? r.toString(e) : r;
  }
});
var hg = T((_f) => {
  var wS = ol(), og = rg(), sl = ag();
  function MS(t) {
    var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
    return new sl(e, r);
  }
  var _S = { binary: true, hex: true, base64: true };
  function sg(t, e, r, o2) {
    return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o2 = o2 || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o2)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
  }
  _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
  _f.createDiffieHellman = _f.DiffieHellman = sg;
});
var hl = T((nk, ug) => {
  ug.exports = ki().EventEmitter;
});
var pg = T((fk, cg) => {
  function lg(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(t);
      e && (o2 = o2.filter(function(f) {
        return Object.getOwnPropertyDescriptor(t, f).enumerable;
      })), r.push.apply(r, o2);
    }
    return r;
  }
  function xS(t) {
    for (var e = 1;e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? lg(Object(r), true).forEach(function(o2) {
        SS(t, o2, r[o2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o2) {
        Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
      });
    }
    return t;
  }
  function SS(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function ES(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function dg(t, e) {
    for (var r = 0;r < e.length; r++) {
      var o2 = e[r];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
    }
  }
  function AS(t, e, r) {
    return e && dg(t.prototype, e), r && dg(t, r), t;
  }
  var RS = Ut2(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
  function IS(t, e, r) {
    qs.prototype.copy.call(t, e, r);
  }
  cg.exports = function() {
    function t() {
      ES(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return AS(t, [{ key: "push", value: function(r) {
      var o2 = { data: r, next: null };
      this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var o2 = { data: r, next: this.head };
      this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var o2 = this.head, f = "" + o2.data;o2 = o2.next; )
        f += r + o2.data;
      return f;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return qs.alloc(0);
      for (var o2 = qs.allocUnsafe(r >>> 0), f = this.head, p2 = 0;f; )
        IS(f.data, o2, p2), p2 += f.data.length, f = f.next;
      return o2;
    } }, { key: "consume", value: function(r, o2) {
      var f;
      return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o2 ? this._getString(r) : this._getBuffer(r), f;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var o2 = this.head, f = 1, p2 = o2.data;
      for (r -= p2.length;o2 = o2.next; ) {
        var m2 = o2.data, y2 = r > m2.length ? m2.length : r;
        if (y2 === m2.length ? p2 += m2 : p2 += m2.slice(0, r), r -= y2, r === 0) {
          y2 === m2.length ? (++f, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m2.slice(y2));
          break;
        }
        ++f;
      }
      return this.length -= f, p2;
    } }, { key: "_getBuffer", value: function(r) {
      var o2 = qs.allocUnsafe(r), f = this.head, p2 = 1;
      for (f.data.copy(o2), r -= f.data.length;f = f.next; ) {
        var m2 = f.data, y2 = r > m2.length ? m2.length : r;
        if (m2.copy(o2, o2.length - r, 0, y2), r -= y2, r === 0) {
          y2 === m2.length ? (++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m2.slice(y2));
          break;
        }
        ++p2;
      }
      return this.length -= p2, o2;
    } }, { key: qS, value: function(r, o2) {
      return ul(this, xS({}, o2, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var dl = T((ak, bg) => {
  function TS(t, e) {
    var r = this, o2 = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return o2 || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
      !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p2)) : process.nextTick(vg, r, p2) : e ? (process.nextTick(Is, r), e(p2)) : process.nextTick(Is, r);
    }), this);
  }
  function vg(t, e) {
    ll(t, e), Is(t);
  }
  function Is(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function kS() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function ll(t, e) {
    t.emit("error", e);
  }
  function LS(t, e) {
    var { _readableState: r, _writableState: o2 } = t;
    r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
});
var kn = T((ok, yg) => {
  function NS(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var gg = {};
  function wr(t, e, r) {
    r || (r = Error);
    function o2(p2, m2, y2) {
      return typeof e == "string" ? e : e(p2, m2, y2);
    }
    var f = function(p2) {
      NS(m2, p2);
      function m2(y2, M2, x3) {
        return p2.call(this, o2(y2, M2, x3)) || this;
      }
      return m2;
    }(r);
    f.prototype.name = r.name, f.prototype.code = t, gg[t] = f;
  }
  function mg(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(o2) {
        return String(o2);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function DS(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function PS(t, e, r) {
    return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function CS(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  wr("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var o2;
    typeof e == "string" && DS(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
    var f;
    if (PS(t, " argument"))
      f = "The ".concat(t, " ").concat(o2, " ").concat(mg(e, "type"));
    else {
      var p2 = CS(t, ".") ? "property" : "argument";
      f = 'The "'.concat(t, '" ').concat(p2, " ").concat(o2, " ").concat(mg(e, "type"));
    }
    return f += ". Received type ".concat(typeof r), f;
  }, TypeError);
  wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  wr("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
  wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  wr("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  yg.exports.codes = gg;
});
var cl = T((sk, wg) => {
  var OS = kn().codes.ERR_INVALID_OPT_VALUE;
  function FS(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function US(t, e, r, o2) {
    var f = FS(e, o2, r);
    if (f != null) {
      if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
        var p2 = o2 ? r : "highWaterMark";
        throw new OS(p2, f);
      }
      return Math.floor(f);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  wg.exports = { getHighWaterMark: US };
});
var bl = T((hk, Ag) => {
  Ag.exports = ut2;
  function _g(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      cE(e, t);
    };
  }
  var xf;
  ut2.WritableState = ka;
  var zS = { deprecate: G0() }, xg = hl(), ks = Ut2().Buffer, HS = global.Uint8Array || function() {
  };
  function WS(t) {
    return ks.from(t);
  }
  function KS(t) {
    return ks.isBuffer(t) || t instanceof HS;
  }
  var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
  Ie()(ut2, xg);
  function tE() {
  }
  function ka(t, e, r) {
    xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o2 = t.decodeStrings === false;
    this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
      sE(e, f);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
  }
  ka.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = [];e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var Ts;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut2, Symbol.hasInstance, { value: function(e) {
    return Ts.call(this, e) ? true : this !== ut2 ? false : e && e._writableState instanceof ka;
  } })) : Ts = function(e) {
    return e instanceof this;
  };
  function ut2(t) {
    xf = xf || Ln();
    var e = this instanceof xf;
    if (!e && !Ts.call(ut2, this))
      return new ut2(t);
    this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
  }
  ut2.prototype.pipe = function() {
    Sf(this, new YS);
  };
  function rE(t, e) {
    var r = new QS;
    Sf(t, r), process.nextTick(e, r);
  }
  function iE(t, e, r, o2) {
    var f;
    return r === null ? f = new JS : typeof r != "string" && !e.objectMode && (f = new VS("chunk", ["string", "Buffer"], r)), f ? (Sf(t, f), process.nextTick(o2, f), false) : true;
  }
  ut2.prototype.write = function(t, e, r) {
    var o2 = this._writableState, f = false, p2 = !o2.objectMode && KS(t);
    return p2 && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = tE), o2.ending ? rE(this, r) : (p2 || iE(this, o2, t, r)) && (o2.pendingcb++, f = fE(this, o2, p2, t, e, r)), f;
  };
  ut2.prototype.cork = function() {
    this._writableState.corked++;
  };
  ut2.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
  };
  ut2.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new eE(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(ut2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function nE(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
  }
  Object.defineProperty(ut2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function fE(t, e, r, o2, f, p2) {
    if (!r) {
      var m2 = nE(e, o2, f);
      o2 !== m2 && (r = true, f = "buffer", o2 = m2);
    }
    var y2 = e.objectMode ? 1 : o2.length;
    e.length += y2;
    var M2 = e.length < e.highWaterMark;
    if (M2 || (e.needDrain = true), e.writing || e.corked) {
      var x3 = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: o2, encoding: f, isBuf: r, callback: p2, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      pl(t, e, false, y2, o2, f, p2);
    return M2;
  }
  function pl(t, e, r, o2, f, p2, m2) {
    e.writelen = o2, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
  }
  function aE(t, e, r, o2, f) {
    --e.pendingcb, r ? (process.nextTick(f, o2), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o2)) : (f(o2), t._writableState.errorEmitted = true, Sf(t, o2), Ta(t, e));
  }
  function oE(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function sE(t, e) {
    var r = t._writableState, o2 = r.sync, f = r.writecb;
    if (typeof f != "function")
      throw new GS;
    if (oE(r), e)
      aE(t, r, o2, e, f);
    else {
      var p2 = Eg(r) || t.destroyed;
      !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o2 ? process.nextTick(Mg, t, r, p2, f) : Mg(t, r, p2, f);
    }
  }
  function Mg(t, e, r, o2) {
    r || hE(t, e), e.pendingcb--, o2(), Ta(t, e);
  }
  function hE(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function Sg(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var o2 = e.bufferedRequestCount, f = new Array(o2), p2 = e.corkedRequestsFree;
      p2.entry = r;
      for (var m2 = 0, y2 = true;r; )
        f[m2] = r, r.isBuf || (y2 = false), r = r.next, m2 += 1;
      f.allBuffers = y2, pl(t, e, true, e.length, f, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
    } else {
      for (;r; ) {
        var { chunk: M2, encoding: x3, callback: S } = r, E3 = e.objectMode ? 1 : M2.length;
        if (pl(t, e, false, E3, M2, x3, S), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  ut2.prototype._write = function(t, e, r) {
    r(new $S("_write()"));
  };
  ut2.prototype._writev = null;
  ut2.prototype.end = function(t, e, r) {
    var o2 = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || dE(this, o2, r), this;
  };
  Object.defineProperty(ut2.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function Eg(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function uE(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
    });
  }
  function lE(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function Ta(t, e) {
    var r = Eg(e);
    if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var o2 = t._readableState;
      (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
    }
    return r;
  }
  function dE(t, e, r) {
    e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function cE(t, e, r) {
    var o2 = t.entry;
    for (t.entry = null;o2; ) {
      var f = o2.callback;
      e.pendingcb--, f(r), o2 = o2.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(ut2.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === undefined ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  ut2.prototype.destroy = vl.destroy;
  ut2.prototype._undestroy = vl.undestroy;
  ut2.prototype._destroy = function(t, e) {
    e(t);
  };
});
var Ln = T((uk, Bg) => {
  var pE = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  Bg.exports = ti;
  var Rg = yl(), gl = bl();
  Ie()(ti, Rg);
  for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
    Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
  var ml, Ns, Ls;
  function ti(t) {
    if (!(this instanceof ti))
      return new ti(t);
    Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
  }
  Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function vE() {
    this._writableState.ended || process.nextTick(bE, this);
  }
  function bE(t) {
    t.end();
  }
  Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var Ds = T((lk, Tg) => {
  var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
  function mE(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, o2 = new Array(r), f = 0;f < r; f++)
          o2[f] = arguments[f];
        t.apply(this, o2);
      }
    };
  }
  function gE() {
  }
  function yE(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function Ig(t, e, r) {
    if (typeof e == "function")
      return Ig(t, null, e);
    e || (e = {}), r = mE(r || gE);
    var o2 = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p2 = function() {
      t.writable || y2();
    }, m2 = t._writableState && t._writableState.finished, y2 = function() {
      f = false, m2 = true, o2 || r.call(t);
    }, M2 = t._readableState && t._readableState.endEmitted, x3 = function() {
      o2 = false, M2 = true, f || r.call(t);
    }, S = function(L2) {
      r.call(t, L2);
    }, E3 = function() {
      var L2;
      if (o2 && !M2)
        return (!t._readableState || !t._readableState.ended) && (L2 = new qg), r.call(t, L2);
      if (f && !m2)
        return (!t._writableState || !t._writableState.ended) && (L2 = new qg), r.call(t, L2);
    }, B = function() {
      t.req.on("finish", y2);
    };
    return yE(t) ? (t.on("complete", y2), t.on("abort", E3), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x3), t.on("finish", y2), e.error !== false && t.on("error", S), t.on("close", E3), function() {
      t.removeListener("complete", y2), t.removeListener("abort", E3), t.removeListener("request", B), t.req && t.req.removeListener("finish", y2), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y2), t.removeListener("end", x3), t.removeListener("error", S), t.removeListener("close", E3);
    };
  }
  Tg.exports = Ig;
});
var Lg = T((dk, kg) => {
  var Ps;
  function $i(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
  function Yi(t, e) {
    return { value: t, done: e };
  }
  function ME(t) {
    var e = t[Gi];
    if (e !== null) {
      var r = t[Pn].read();
      r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e(Yi(r, false)));
    }
  }
  function _E(t) {
    process.nextTick(ME, t);
  }
  function xE(t, e) {
    return function(r, o2) {
      t.then(function() {
        if (e[Cs]) {
          r(Yi(undefined, true));
          return;
        }
        e[wl](r, o2);
      }, o2);
    };
  }
  var SE = Object.getPrototypeOf(function() {
  }), EE = Object.setPrototypeOf((Ps = { get stream() {
    return this[Pn];
  }, next: function() {
    var e = this, r = this[La];
    if (r !== null)
      return Promise.reject(r);
    if (this[Cs])
      return Promise.resolve(Yi(undefined, true));
    if (this[Pn].destroyed)
      return new Promise(function(m2, y2) {
        process.nextTick(function() {
          e[La] ? y2(e[La]) : m2(Yi(undefined, true));
        });
      });
    var o2 = this[Dn], f;
    if (o2)
      f = new Promise(xE(o2, this));
    else {
      var p2 = this[Pn].read();
      if (p2 !== null)
        return Promise.resolve(Yi(p2, false));
      f = new Promise(this[wl]);
    }
    return this[Dn] = f, f;
  } }, $i(Ps, Symbol.asyncIterator, function() {
    return this;
  }), $i(Ps, "return", function() {
    var e = this;
    return new Promise(function(r, o2) {
      e[Pn].destroy(null, function(f) {
        if (f) {
          o2(f);
          return;
        }
        r(Yi(undefined, true));
      });
    });
  }), Ps), SE), AE = function(e) {
    var r, o2 = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p2, m2) {
      var y2 = o2[Pn].read();
      y2 ? (o2[Dn] = null, o2[Gi] = null, o2[Nn] = null, p2(Yi(y2, false))) : (o2[Gi] = p2, o2[Nn] = m2);
    }, writable: true }), r));
    return o2[Dn] = null, wE(e, function(f) {
      if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var p2 = o2[Nn];
        p2 !== null && (o2[Dn] = null, o2[Gi] = null, o2[Nn] = null, p2(f)), o2[La] = f;
        return;
      }
      var m2 = o2[Gi];
      m2 !== null && (o2[Dn] = null, o2[Gi] = null, o2[Nn] = null, m2(Yi(undefined, true))), o2[Cs] = true;
    }), e.on("readable", _E.bind(null, o2)), o2;
  };
  kg.exports = AE;
});
var Dg = T((ck, Ng) => {
  Ng.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var yl = T((vk, jg) => {
  jg.exports = Oe;
  var Ef;
  Oe.ReadableState = Fg;
  var pk = ki().EventEmitter, Og = function(e, r) {
    return e.listeners(r).length;
  }, Da = hl(), Os = Ut2().Buffer, RE = global.Uint8Array || function() {
  };
  function BE(t) {
    return Os.from(t);
  }
  function qE(t) {
    return Os.isBuffer(t) || t instanceof RE;
  }
  var Ml = $f(), De;
  Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
  };
  var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
  Ie()(Oe, Da);
  var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
  function CE(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function Fg(t, e, r) {
    Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
  }
  function Oe(t) {
    if (Ef = Ef || Ln(), !(this instanceof Oe))
      return new Oe(t);
    var e = this instanceof Ef;
    this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
  }
  Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === undefined ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  Oe.prototype.destroy = Bl.destroy;
  Oe.prototype._undestroy = Bl.undestroy;
  Oe.prototype._destroy = function(t, e) {
    e(t);
  };
  Oe.prototype.push = function(t, e) {
    var r = this._readableState, o2;
    return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o2 = true), Ug(this, t, e, false, o2);
  };
  Oe.prototype.unshift = function(t) {
    return Ug(this, t, null, true, false);
  };
  function Ug(t, e, r, o2, f) {
    De("readableAddChunk", e);
    var p2 = t._readableState;
    if (e === null)
      p2.reading = false, UE(t, p2);
    else {
      var m2;
      if (f || (m2 = OE(p2, e)), m2)
        Na(t, m2);
      else if (p2.objectMode || e && e.length > 0)
        if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o2)
          p2.endEmitted ? Na(t, new PE) : El(t, p2, e, true);
        else if (p2.ended)
          Na(t, new NE);
        else {
          if (p2.destroyed)
            return false;
          p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? El(t, p2, e, false) : Rl(t, p2)) : El(t, p2, e, false);
        }
      else
        o2 || (p2.reading = false, Rl(t, p2));
    }
    return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
  }
  function El(t, e, r, o2) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
  }
  function OE(t, e) {
    var r;
    return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  Oe.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Oe.prototype.setEncoding = function(t) {
    Af || (Af = (Qf(), ur(Jf)).StringDecoder);
    var e = new Af(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
      o2 += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
  };
  var Pg = 1073741824;
  function FE(t) {
    return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function Cg(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  Oe.prototype.read = function(t) {
    De("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
    if (t = Cg(t, e), t === 0 && e.ended)
      return e.length === 0 && Al(this), null;
    var o2 = e.needReadable;
    De("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, De("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, De("reading or ended", o2)) : o2 && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
    var f;
    return t > 0 ? f = Wg(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f !== null && this.emit("data", f), f;
  };
  function UE(t, e) {
    if (De("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
    }
  }
  function Us(t) {
    var e = t._readableState;
    De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
  }
  function zg(t) {
    var e = t._readableState;
    De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
  }
  function Rl(t, e) {
    e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
  }
  function zE(t, e) {
    for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (De("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Oe.prototype._read = function(t) {
    Na(this, new DE("_read()"));
  };
  Oe.prototype.pipe = function(t, e) {
    var r = this, o2 = this._readableState;
    switch (o2.pipesCount) {
      case 0:
        o2.pipes = t;
        break;
      case 1:
        o2.pipes = [o2.pipes, t];
        break;
      default:
        o2.pipes.push(t);
        break;
    }
    o2.pipesCount += 1, De("pipe count=%d opts=%j", o2.pipesCount, e);
    var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f ? y2 : ge;
    o2.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
    function m2(_e, N3) {
      De("onunpipe"), _e === r && N3 && N3.hasUnpiped === false && (N3.hasUnpiped = true, S());
    }
    function y2() {
      De("onend"), t.end();
    }
    var M2 = HE(r);
    t.on("drain", M2);
    var x3 = false;
    function S() {
      De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L2), t.removeListener("drain", M2), t.removeListener("error", B), t.removeListener("unpipe", m2), r.removeListener("end", y2), r.removeListener("end", ge), r.removeListener("data", E3), x3 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M2();
    }
    r.on("data", E3);
    function E3(_e) {
      De("ondata");
      var N3 = t.write(_e);
      De("dest.write", N3), N3 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Kg(o2.pipes, t) !== -1) && !x3 && (De("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
    }
    function B(_e) {
      De("onerror", _e), ge(), t.removeListener("error", B), Og(t, "error") === 0 && Na(t, _e);
    }
    CE(t, "error", B);
    function q() {
      t.removeListener("finish", L2), ge();
    }
    t.once("close", q);
    function L2() {
      De("onfinish"), t.removeListener("close", q), ge();
    }
    t.once("finish", L2);
    function ge() {
      De("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), o2.flowing || (De("pipe resume"), r.resume()), t;
  };
  function HE(t) {
    return function() {
      var r = t._readableState;
      De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
    };
  }
  Oe.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var { pipes: o2, pipesCount: f } = e;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var p2 = 0;p2 < f; p2++)
        o2[p2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var m2 = Kg(e.pipes, t);
    return m2 === -1 ? this : (e.pipes.splice(m2, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  Oe.prototype.on = function(t, e) {
    var r = Da.prototype.on.call(this, t, e), o2 = this._readableState;
    return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, De("on readable", o2.length, o2.reading), o2.length ? Us(this) : o2.reading || process.nextTick(WE, this)), r;
  };
  Oe.prototype.addListener = Oe.prototype.on;
  Oe.prototype.removeListener = function(t, e) {
    var r = Da.prototype.removeListener.call(this, t, e);
    return t === "readable" && process.nextTick(Hg, this), r;
  };
  Oe.prototype.removeAllListeners = function(t) {
    var e = Da.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
  };
  function Hg(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function WE(t) {
    De("readable nexttick read 0"), t.read(0);
  }
  Oe.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
  };
  function KE(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
  }
  function jE(t, e) {
    De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
  }
  Oe.prototype.pause = function() {
    return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function ql(t) {
    var e = t._readableState;
    for (De("flow", e.flowing);e.flowing && t.read() !== null; )
      ;
  }
  Oe.prototype.wrap = function(t) {
    var e = this, r = this._readableState, o2 = false;
    t.on("end", function() {
      if (De("wrapped end"), r.decoder && !r.ended) {
        var m2 = r.decoder.end();
        m2 && m2.length && e.push(m2);
      }
      e.push(null);
    }), t.on("data", function(m2) {
      if (De("wrapped data"), r.decoder && (m2 = r.decoder.write(m2)), !(r.objectMode && m2 == null) && !(!r.objectMode && (!m2 || !m2.length))) {
        var y2 = e.push(m2);
        y2 || (o2 = true, t.pause());
      }
    });
    for (var f in t)
      this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y2) {
        return function() {
          return t[y2].apply(t, arguments);
        };
      }(f));
    for (var p2 = 0;p2 < Sl.length; p2++)
      t.on(Sl[p2], this.emit.bind(this, Sl[p2]));
    return this._read = function(m2) {
      De("wrapped _read", m2), o2 && (o2 = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
    return _l === undefined && (_l = Lg()), _l(this);
  });
  Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  Oe._fromList = Wg;
  Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Wg(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Al(t) {
    var e = t._readableState;
    De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
  }
  function ZE(t, e) {
    if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (Oe.from = function(t, e) {
    return xl === undefined && (xl = Dg()), xl(Oe, t, e);
  });
  function Kg(t, e) {
    for (var r = 0, o2 = t.length;r < o2; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var Il = T((bk, Vg) => {
  Vg.exports = Ei;
  var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
  Ie()(Ei, Hs);
  function XE(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var o2 = r.writecb;
    if (o2 === null)
      return this.emit("error", new $E);
    r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
    var f = this._readableState;
    f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
  }
  function Ei(t) {
    if (!(this instanceof Ei))
      return new Ei(t);
    Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
  }
  function JE() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Zg(t, e, r);
    }) : Zg(this, null, null);
  }
  Ei.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e);
  };
  Ei.prototype._transform = function(t, e, r) {
    r(new VE("_transform()"));
  };
  Ei.prototype._write = function(t, e, r) {
    var o2 = this._transformState;
    if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
      var f = this._readableState;
      (o2.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
  };
  Ei.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  Ei.prototype._destroy = function(t, e) {
    Hs.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Zg(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new YE;
    if (t._transformState.transforming)
      throw new GE;
    return t.push(null);
  }
});
var Yg = T((mk, Gg) => {
  Gg.exports = Pa;
  var $g = Il();
  Ie()(Pa, $g);
  function Pa(t) {
    if (!(this instanceof Pa))
      return new Pa(t);
    $g.call(this, t);
  }
  Pa.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var t2 = T((gk, e2) => {
  var Tl;
  function QE(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(undefined, arguments));
    };
  }
  var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
  function Xg(t) {
    if (t)
      throw t;
  }
  function rA(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function iA(t, e, r, o2) {
    o2 = QE(o2);
    var f = false;
    t.on("close", function() {
      f = true;
    }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m2) {
      if (m2)
        return o2(m2);
      f = true, o2();
    });
    var p2 = false;
    return function(m2) {
      if (!f && !p2) {
        if (p2 = true, rA(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        o2(m2 || new tA("pipe"));
      }
    };
  }
  function Jg(t) {
    t();
  }
  function nA(t, e) {
    return t.pipe(e);
  }
  function fA(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
  }
  function aA() {
    for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
      e[r] = arguments[r];
    var o2 = fA(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new eA("streams");
    var f, p2 = e.map(function(m2, y2) {
      var M2 = y2 < e.length - 1, x3 = y2 > 0;
      return iA(m2, M2, x3, function(S) {
        f || (f = S), S && p2.forEach(Jg), !M2 && (p2.forEach(Jg), o2(f));
      });
    });
    return e.reduce(nA);
  }
  e2.exports = aA;
});
var i2 = T((Mr, r2) => {
  Mr = r2.exports = yl();
  Mr.Stream = Mr;
  Mr.Readable = Mr;
  Mr.Writable = bl();
  Mr.Duplex = Ln();
  Mr.Transform = Il();
  Mr.PassThrough = Yg();
  Mr.finished = Ds();
  Mr.pipeline = t2();
});
var Ws = T((n2, kl) => {
  (function(t, e) {
    function r(h2, s) {
      if (!h2)
        throw new Error(s || "Assertion failed");
    }
    function o2(h2, s) {
      h2.super_ = s;
      var u = function() {
      };
      u.prototype = s.prototype, h2.prototype = new u, h2.prototype.constructor = h2;
    }
    function f(h2, s, u) {
      if (f.isBN(h2))
        return h2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, h2 !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h2 || 0, s || 10, u || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(s) {
      return s instanceof f ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f.wordSize && Array.isArray(s.words);
    }, f.max = function(s, u) {
      return s.cmp(u) > 0 ? s : u;
    }, f.min = function(s, u) {
      return s.cmp(u) < 0 ? s : u;
    }, f.prototype._init = function(s, u, c) {
      if (typeof s == "number")
        return this._initNumber(s, u, c);
      if (typeof s == "object")
        return this._initArray(s, u, c);
      u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
      var b3 = 0;
      s[0] === "-" && (b3++, this.negative = 1), b3 < s.length && (u === 16 ? this._parseHex(s, b3, c) : (this._parseBase(s, u, b3), c === "le" && this._initArray(this.toArray(), u, c)));
    }, f.prototype._initNumber = function(s, u, c) {
      s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
    }, f.prototype._initArray = function(s, u, c) {
      if (r(typeof s.length == "number"), s.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
      for (var b3 = 0;b3 < this.length; b3++)
        this.words[b3] = 0;
      var l2, n, d2 = 0;
      if (c === "be")
        for (b3 = s.length - 1, l2 = 0;b3 >= 0; b3 -= 3)
          n = s[b3] | s[b3 - 1] << 8 | s[b3 - 2] << 16, this.words[l2] |= n << d2 & 67108863, this.words[l2 + 1] = n >>> 26 - d2 & 67108863, d2 += 24, d2 >= 26 && (d2 -= 26, l2++);
      else if (c === "le")
        for (b3 = 0, l2 = 0;b3 < s.length; b3 += 3)
          n = s[b3] | s[b3 + 1] << 8 | s[b3 + 2] << 16, this.words[l2] |= n << d2 & 67108863, this.words[l2 + 1] = n >>> 26 - d2 & 67108863, d2 += 24, d2 >= 26 && (d2 -= 26, l2++);
      return this._strip();
    };
    function m2(h2, s) {
      var u = h2.charCodeAt(s);
      if (u >= 48 && u <= 57)
        return u - 48;
      if (u >= 65 && u <= 70)
        return u - 55;
      if (u >= 97 && u <= 102)
        return u - 87;
      r(false, "Invalid character in " + h2);
    }
    function y2(h2, s, u) {
      var c = m2(h2, u);
      return u - 1 >= s && (c |= m2(h2, u - 1) << 4), c;
    }
    f.prototype._parseHex = function(s, u, c) {
      this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
      for (var b3 = 0;b3 < this.length; b3++)
        this.words[b3] = 0;
      var l2 = 0, n = 0, d2;
      if (c === "be")
        for (b3 = s.length - 1;b3 >= u; b3 -= 2)
          d2 = y2(s, u, b3) << l2, this.words[n] |= d2 & 67108863, l2 >= 18 ? (l2 -= 18, n += 1, this.words[n] |= d2 >>> 26) : l2 += 8;
      else {
        var w3 = s.length - u;
        for (b3 = w3 % 2 === 0 ? u + 1 : u;b3 < s.length; b3 += 2)
          d2 = y2(s, u, b3) << l2, this.words[n] |= d2 & 67108863, l2 >= 18 ? (l2 -= 18, n += 1, this.words[n] |= d2 >>> 26) : l2 += 8;
      }
      this._strip();
    };
    function M2(h2, s, u, c) {
      for (var b3 = 0, l2 = 0, n = Math.min(h2.length, u), d2 = s;d2 < n; d2++) {
        var w3 = h2.charCodeAt(d2) - 48;
        b3 *= c, w3 >= 49 ? l2 = w3 - 49 + 10 : w3 >= 17 ? l2 = w3 - 17 + 10 : l2 = w3, r(w3 >= 0 && l2 < c, "Invalid character"), b3 += l2;
      }
      return b3;
    }
    f.prototype._parseBase = function(s, u, c) {
      this.words = [0], this.length = 1;
      for (var b3 = 0, l2 = 1;l2 <= 67108863; l2 *= u)
        b3++;
      b3--, l2 = l2 / u | 0;
      for (var n = s.length - c, d2 = n % b3, w3 = Math.min(n, n - d2) + c, g2 = 0, _2 = c;_2 < w3; _2 += b3)
        g2 = M2(s, _2, _2 + b3, u), this.imuln(l2), this.words[0] + g2 < 67108864 ? this.words[0] += g2 : this._iaddn(g2);
      if (d2 !== 0) {
        var A2 = 1;
        for (g2 = M2(s, _2, s.length, u), _2 = 0;_2 < d2; _2++)
          A2 *= u;
        this.imuln(A2), this.words[0] + g2 < 67108864 ? this.words[0] += g2 : this._iaddn(g2);
      }
      this._strip();
    }, f.prototype.copy = function(s) {
      s.words = new Array(this.length);
      for (var u = 0;u < this.length; u++)
        s.words[u] = this.words[u];
      s.length = this.length, s.negative = this.negative, s.red = this.red;
    };
    function x3(h2, s) {
      h2.words = s.words, h2.length = s.length, h2.negative = s.negative, h2.red = s.red;
    }
    if (f.prototype._move = function(s) {
      x3(s, this);
    }, f.prototype.clone = function() {
      var s = new f(null);
      return this.copy(s), s;
    }, f.prototype._expand = function(s) {
      for (;this.length < s; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype._strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        f.prototype[Symbol.for("nodejs.util.inspect.custom")] = S;
      } catch {
        f.prototype.inspect = S;
      }
    else
      f.prototype.inspect = S;
    function S() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(s, u) {
      s = s || 10, u = u | 0 || 1;
      var c;
      if (s === 16 || s === "hex") {
        c = "";
        for (var b3 = 0, l2 = 0, n = 0;n < this.length; n++) {
          var d2 = this.words[n], w3 = ((d2 << b3 | l2) & 16777215).toString(16);
          l2 = d2 >>> 24 - b3 & 16777215, b3 += 2, b3 >= 26 && (b3 -= 26, n--), l2 !== 0 || n !== this.length - 1 ? c = E3[6 - w3.length] + w3 + c : c = w3 + c;
        }
        for (l2 !== 0 && (c = l2.toString(16) + c);c.length % u !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      if (s === (s | 0) && s >= 2 && s <= 36) {
        var g2 = B[s], _2 = q[s];
        c = "";
        var A2 = this.clone();
        for (A2.negative = 0;!A2.isZero(); ) {
          var R3 = A2.modrn(_2).toString(s);
          A2 = A2.idivn(_2), A2.isZero() ? c = R3 + c : c = E3[g2 - R3.length] + R3 + c;
        }
        for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var s = this.words[0];
      return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
    }, f.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, p2 && (f.prototype.toBuffer = function(s, u) {
      return this.toArrayLike(p2, s, u);
    }), f.prototype.toArray = function(s, u) {
      return this.toArrayLike(Array, s, u);
    };
    var L2 = function(s, u) {
      return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
    };
    f.prototype.toArrayLike = function(s, u, c) {
      this._strip();
      var b3 = this.byteLength(), l2 = c || Math.max(1, b3);
      r(b3 <= l2, "byte array longer than desired length"), r(l2 > 0, "Requested array length <= 0");
      var n = L2(s, l2), d2 = u === "le" ? "LE" : "BE";
      return this["_toArrayLike" + d2](n, b3), n;
    }, f.prototype._toArrayLikeLE = function(s, u) {
      for (var c = 0, b3 = 0, l2 = 0, n = 0;l2 < this.length; l2++) {
        var d2 = this.words[l2] << n | b3;
        s[c++] = d2 & 255, c < s.length && (s[c++] = d2 >> 8 & 255), c < s.length && (s[c++] = d2 >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d2 >> 24 & 255), b3 = 0, n = 0) : (b3 = d2 >>> 24, n += 2);
      }
      if (c < s.length)
        for (s[c++] = b3;c < s.length; )
          s[c++] = 0;
    }, f.prototype._toArrayLikeBE = function(s, u) {
      for (var c = s.length - 1, b3 = 0, l2 = 0, n = 0;l2 < this.length; l2++) {
        var d2 = this.words[l2] << n | b3;
        s[c--] = d2 & 255, c >= 0 && (s[c--] = d2 >> 8 & 255), c >= 0 && (s[c--] = d2 >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d2 >> 24 & 255), b3 = 0, n = 0) : (b3 = d2 >>> 24, n += 2);
      }
      if (c >= 0)
        for (s[c--] = b3;c >= 0; )
          s[c--] = 0;
    }, Math.clz32 ? f.prototype._countBits = function(s) {
      return 32 - Math.clz32(s);
    } : f.prototype._countBits = function(s) {
      var u = s, c = 0;
      return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
    }, f.prototype._zeroBits = function(s) {
      if (s === 0)
        return 26;
      var u = s, c = 0;
      return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
    }, f.prototype.bitLength = function() {
      var s = this.words[this.length - 1], u = this._countBits(s);
      return (this.length - 1) * 26 + u;
    };
    function ge(h2) {
      for (var s = new Array(h2.bitLength()), u = 0;u < s.length; u++) {
        var c = u / 26 | 0, b3 = u % 26;
        s[u] = h2.words[c] >>> b3 & 1;
      }
      return s;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var s = 0, u = 0;u < this.length; u++) {
        var c = this._zeroBits(this.words[u]);
        if (s += c, c !== 26)
          break;
      }
      return s;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(s) {
      return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(s) {
      return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(s) {
      for (;this.length < s.length; )
        this.words[this.length++] = 0;
      for (var u = 0;u < s.length; u++)
        this.words[u] = this.words[u] | s.words[u];
      return this._strip();
    }, f.prototype.ior = function(s) {
      return r((this.negative | s.negative) === 0), this.iuor(s);
    }, f.prototype.or = function(s) {
      return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
    }, f.prototype.uor = function(s) {
      return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
    }, f.prototype.iuand = function(s) {
      var u;
      this.length > s.length ? u = s : u = this;
      for (var c = 0;c < u.length; c++)
        this.words[c] = this.words[c] & s.words[c];
      return this.length = u.length, this._strip();
    }, f.prototype.iand = function(s) {
      return r((this.negative | s.negative) === 0), this.iuand(s);
    }, f.prototype.and = function(s) {
      return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
    }, f.prototype.uand = function(s) {
      return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
    }, f.prototype.iuxor = function(s) {
      var u, c;
      this.length > s.length ? (u = this, c = s) : (u = s, c = this);
      for (var b3 = 0;b3 < c.length; b3++)
        this.words[b3] = u.words[b3] ^ c.words[b3];
      if (this !== u)
        for (;b3 < u.length; b3++)
          this.words[b3] = u.words[b3];
      return this.length = u.length, this._strip();
    }, f.prototype.ixor = function(s) {
      return r((this.negative | s.negative) === 0), this.iuxor(s);
    }, f.prototype.xor = function(s) {
      return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
    }, f.prototype.uxor = function(s) {
      return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
    }, f.prototype.inotn = function(s) {
      r(typeof s == "number" && s >= 0);
      var u = Math.ceil(s / 26) | 0, c = s % 26;
      this._expand(u), c > 0 && u--;
      for (var b3 = 0;b3 < u; b3++)
        this.words[b3] = ~this.words[b3] & 67108863;
      return c > 0 && (this.words[b3] = ~this.words[b3] & 67108863 >> 26 - c), this._strip();
    }, f.prototype.notn = function(s) {
      return this.clone().inotn(s);
    }, f.prototype.setn = function(s, u) {
      r(typeof s == "number" && s >= 0);
      var c = s / 26 | 0, b3 = s % 26;
      return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b3 : this.words[c] = this.words[c] & ~(1 << b3), this._strip();
    }, f.prototype.iadd = function(s) {
      var u;
      if (this.negative !== 0 && s.negative === 0)
        return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && s.negative !== 0)
        return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
      var c, b3;
      this.length > s.length ? (c = this, b3 = s) : (c = s, b3 = this);
      for (var l2 = 0, n = 0;n < b3.length; n++)
        u = (c.words[n] | 0) + (b3.words[n] | 0) + l2, this.words[n] = u & 67108863, l2 = u >>> 26;
      for (;l2 !== 0 && n < c.length; n++)
        u = (c.words[n] | 0) + l2, this.words[n] = u & 67108863, l2 = u >>> 26;
      if (this.length = c.length, l2 !== 0)
        this.words[this.length] = l2, this.length++;
      else if (c !== this)
        for (;n < c.length; n++)
          this.words[n] = c.words[n];
      return this;
    }, f.prototype.add = function(s) {
      var u;
      return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
    }, f.prototype.isub = function(s) {
      if (s.negative !== 0) {
        s.negative = 0;
        var u = this.iadd(s);
        return s.negative = 1, u._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
      var c = this.cmp(s);
      if (c === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var b3, l2;
      c > 0 ? (b3 = this, l2 = s) : (b3 = s, l2 = this);
      for (var n = 0, d2 = 0;d2 < l2.length; d2++)
        u = (b3.words[d2] | 0) - (l2.words[d2] | 0) + n, n = u >> 26, this.words[d2] = u & 67108863;
      for (;n !== 0 && d2 < b3.length; d2++)
        u = (b3.words[d2] | 0) + n, n = u >> 26, this.words[d2] = u & 67108863;
      if (n === 0 && d2 < b3.length && b3 !== this)
        for (;d2 < b3.length; d2++)
          this.words[d2] = b3.words[d2];
      return this.length = Math.max(this.length, d2), b3 !== this && (this.negative = 1), this._strip();
    }, f.prototype.sub = function(s) {
      return this.clone().isub(s);
    };
    function _e(h2, s, u) {
      u.negative = s.negative ^ h2.negative;
      var c = h2.length + s.length | 0;
      u.length = c, c = c - 1 | 0;
      var b3 = h2.words[0] | 0, l2 = s.words[0] | 0, n = b3 * l2, d2 = n & 67108863, w3 = n / 67108864 | 0;
      u.words[0] = d2;
      for (var g2 = 1;g2 < c; g2++) {
        for (var _2 = w3 >>> 26, A2 = w3 & 67108863, R3 = Math.min(g2, s.length - 1), I = Math.max(0, g2 - h2.length + 1);I <= R3; I++) {
          var Me = g2 - I | 0;
          b3 = h2.words[Me] | 0, l2 = s.words[I] | 0, n = b3 * l2 + A2, _2 += n / 67108864 | 0, A2 = n & 67108863;
        }
        u.words[g2] = A2 | 0, w3 = _2 | 0;
      }
      return w3 !== 0 ? u.words[g2] = w3 | 0 : u.length--, u._strip();
    }
    var N3 = function(s, u, c) {
      var b3 = s.words, l2 = u.words, n = c.words, d2 = 0, w3, g2, _2, A2 = b3[0] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = b3[1] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = b3[2] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = b3[3] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = b3[4] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = b3[5] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = b3[6] | 0, j2 = gt2 & 8191, Z2 = gt2 >>> 13, yt2 = b3[7] | 0, V2 = yt2 & 8191, $2 = yt2 >>> 13, wt = b3[8] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = b3[9] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = l2[0] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = l2[1] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = l2[2] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = l2[3] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = l2[4] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = l2[5] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = l2[6] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = l2[7] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = l2[8] | 0, ve = It & 8191, be = It >>> 13, ft2 = l2[9] | 0, Be = ft2 & 8191, qe2 = ft2 >>> 13;
      c.negative = s.negative ^ u.negative, c.length = 19, w3 = Math.imul(R3, Q), g2 = Math.imul(R3, ee), g2 = g2 + Math.imul(I, Q) | 0, _2 = Math.imul(I, ee);
      var ze = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w3 = Math.imul(k, Q), g2 = Math.imul(k, ee), g2 = g2 + Math.imul(D2, Q) | 0, _2 = Math.imul(D2, ee), w3 = w3 + Math.imul(R3, te) | 0, g2 = g2 + Math.imul(R3, re2) | 0, g2 = g2 + Math.imul(I, te) | 0, _2 = _2 + Math.imul(I, re2) | 0;
      var He = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w3 = Math.imul(C2, Q), g2 = Math.imul(C2, ee), g2 = g2 + Math.imul(O2, Q) | 0, _2 = Math.imul(O2, ee), w3 = w3 + Math.imul(k, te) | 0, g2 = g2 + Math.imul(k, re2) | 0, g2 = g2 + Math.imul(D2, te) | 0, _2 = _2 + Math.imul(D2, re2) | 0, w3 = w3 + Math.imul(R3, ie) | 0, g2 = g2 + Math.imul(R3, ne) | 0, g2 = g2 + Math.imul(I, ie) | 0, _2 = _2 + Math.imul(I, ne) | 0;
      var We = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w3 = Math.imul(F2, Q), g2 = Math.imul(F2, ee), g2 = g2 + Math.imul(U, Q) | 0, _2 = Math.imul(U, ee), w3 = w3 + Math.imul(C2, te) | 0, g2 = g2 + Math.imul(C2, re2) | 0, g2 = g2 + Math.imul(O2, te) | 0, _2 = _2 + Math.imul(O2, re2) | 0, w3 = w3 + Math.imul(k, ie) | 0, g2 = g2 + Math.imul(k, ne) | 0, g2 = g2 + Math.imul(D2, ie) | 0, _2 = _2 + Math.imul(D2, ne) | 0, w3 = w3 + Math.imul(R3, fe) | 0, g2 = g2 + Math.imul(R3, ae) | 0, g2 = g2 + Math.imul(I, fe) | 0, _2 = _2 + Math.imul(I, ae) | 0;
      var Ke = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w3 = Math.imul(z, Q), g2 = Math.imul(z, ee), g2 = g2 + Math.imul(H2, Q) | 0, _2 = Math.imul(H2, ee), w3 = w3 + Math.imul(F2, te) | 0, g2 = g2 + Math.imul(F2, re2) | 0, g2 = g2 + Math.imul(U, te) | 0, _2 = _2 + Math.imul(U, re2) | 0, w3 = w3 + Math.imul(C2, ie) | 0, g2 = g2 + Math.imul(C2, ne) | 0, g2 = g2 + Math.imul(O2, ie) | 0, _2 = _2 + Math.imul(O2, ne) | 0, w3 = w3 + Math.imul(k, fe) | 0, g2 = g2 + Math.imul(k, ae) | 0, g2 = g2 + Math.imul(D2, fe) | 0, _2 = _2 + Math.imul(D2, ae) | 0, w3 = w3 + Math.imul(R3, oe) | 0, g2 = g2 + Math.imul(R3, se) | 0, g2 = g2 + Math.imul(I, oe) | 0, _2 = _2 + Math.imul(I, se) | 0;
      var je = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w3 = Math.imul(W, Q), g2 = Math.imul(W, ee), g2 = g2 + Math.imul(K2, Q) | 0, _2 = Math.imul(K2, ee), w3 = w3 + Math.imul(z, te) | 0, g2 = g2 + Math.imul(z, re2) | 0, g2 = g2 + Math.imul(H2, te) | 0, _2 = _2 + Math.imul(H2, re2) | 0, w3 = w3 + Math.imul(F2, ie) | 0, g2 = g2 + Math.imul(F2, ne) | 0, g2 = g2 + Math.imul(U, ie) | 0, _2 = _2 + Math.imul(U, ne) | 0, w3 = w3 + Math.imul(C2, fe) | 0, g2 = g2 + Math.imul(C2, ae) | 0, g2 = g2 + Math.imul(O2, fe) | 0, _2 = _2 + Math.imul(O2, ae) | 0, w3 = w3 + Math.imul(k, oe) | 0, g2 = g2 + Math.imul(k, se) | 0, g2 = g2 + Math.imul(D2, oe) | 0, _2 = _2 + Math.imul(D2, se) | 0, w3 = w3 + Math.imul(R3, he) | 0, g2 = g2 + Math.imul(R3, ue) | 0, g2 = g2 + Math.imul(I, he) | 0, _2 = _2 + Math.imul(I, ue) | 0;
      var Ze = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w3 = Math.imul(j2, Q), g2 = Math.imul(j2, ee), g2 = g2 + Math.imul(Z2, Q) | 0, _2 = Math.imul(Z2, ee), w3 = w3 + Math.imul(W, te) | 0, g2 = g2 + Math.imul(W, re2) | 0, g2 = g2 + Math.imul(K2, te) | 0, _2 = _2 + Math.imul(K2, re2) | 0, w3 = w3 + Math.imul(z, ie) | 0, g2 = g2 + Math.imul(z, ne) | 0, g2 = g2 + Math.imul(H2, ie) | 0, _2 = _2 + Math.imul(H2, ne) | 0, w3 = w3 + Math.imul(F2, fe) | 0, g2 = g2 + Math.imul(F2, ae) | 0, g2 = g2 + Math.imul(U, fe) | 0, _2 = _2 + Math.imul(U, ae) | 0, w3 = w3 + Math.imul(C2, oe) | 0, g2 = g2 + Math.imul(C2, se) | 0, g2 = g2 + Math.imul(O2, oe) | 0, _2 = _2 + Math.imul(O2, se) | 0, w3 = w3 + Math.imul(k, he) | 0, g2 = g2 + Math.imul(k, ue) | 0, g2 = g2 + Math.imul(D2, he) | 0, _2 = _2 + Math.imul(D2, ue) | 0, w3 = w3 + Math.imul(R3, le) | 0, g2 = g2 + Math.imul(R3, de) | 0, g2 = g2 + Math.imul(I, le) | 0, _2 = _2 + Math.imul(I, de) | 0;
      var Ve = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w3 = Math.imul(V2, Q), g2 = Math.imul(V2, ee), g2 = g2 + Math.imul($2, Q) | 0, _2 = Math.imul($2, ee), w3 = w3 + Math.imul(j2, te) | 0, g2 = g2 + Math.imul(j2, re2) | 0, g2 = g2 + Math.imul(Z2, te) | 0, _2 = _2 + Math.imul(Z2, re2) | 0, w3 = w3 + Math.imul(W, ie) | 0, g2 = g2 + Math.imul(W, ne) | 0, g2 = g2 + Math.imul(K2, ie) | 0, _2 = _2 + Math.imul(K2, ne) | 0, w3 = w3 + Math.imul(z, fe) | 0, g2 = g2 + Math.imul(z, ae) | 0, g2 = g2 + Math.imul(H2, fe) | 0, _2 = _2 + Math.imul(H2, ae) | 0, w3 = w3 + Math.imul(F2, oe) | 0, g2 = g2 + Math.imul(F2, se) | 0, g2 = g2 + Math.imul(U, oe) | 0, _2 = _2 + Math.imul(U, se) | 0, w3 = w3 + Math.imul(C2, he) | 0, g2 = g2 + Math.imul(C2, ue) | 0, g2 = g2 + Math.imul(O2, he) | 0, _2 = _2 + Math.imul(O2, ue) | 0, w3 = w3 + Math.imul(k, le) | 0, g2 = g2 + Math.imul(k, de) | 0, g2 = g2 + Math.imul(D2, le) | 0, _2 = _2 + Math.imul(D2, de) | 0, w3 = w3 + Math.imul(R3, ce2) | 0, g2 = g2 + Math.imul(R3, pe) | 0, g2 = g2 + Math.imul(I, ce2) | 0, _2 = _2 + Math.imul(I, pe) | 0;
      var $e = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w3 = Math.imul(G, Q), g2 = Math.imul(G, ee), g2 = g2 + Math.imul(Y2, Q) | 0, _2 = Math.imul(Y2, ee), w3 = w3 + Math.imul(V2, te) | 0, g2 = g2 + Math.imul(V2, re2) | 0, g2 = g2 + Math.imul($2, te) | 0, _2 = _2 + Math.imul($2, re2) | 0, w3 = w3 + Math.imul(j2, ie) | 0, g2 = g2 + Math.imul(j2, ne) | 0, g2 = g2 + Math.imul(Z2, ie) | 0, _2 = _2 + Math.imul(Z2, ne) | 0, w3 = w3 + Math.imul(W, fe) | 0, g2 = g2 + Math.imul(W, ae) | 0, g2 = g2 + Math.imul(K2, fe) | 0, _2 = _2 + Math.imul(K2, ae) | 0, w3 = w3 + Math.imul(z, oe) | 0, g2 = g2 + Math.imul(z, se) | 0, g2 = g2 + Math.imul(H2, oe) | 0, _2 = _2 + Math.imul(H2, se) | 0, w3 = w3 + Math.imul(F2, he) | 0, g2 = g2 + Math.imul(F2, ue) | 0, g2 = g2 + Math.imul(U, he) | 0, _2 = _2 + Math.imul(U, ue) | 0, w3 = w3 + Math.imul(C2, le) | 0, g2 = g2 + Math.imul(C2, de) | 0, g2 = g2 + Math.imul(O2, le) | 0, _2 = _2 + Math.imul(O2, de) | 0, w3 = w3 + Math.imul(k, ce2) | 0, g2 = g2 + Math.imul(k, pe) | 0, g2 = g2 + Math.imul(D2, ce2) | 0, _2 = _2 + Math.imul(D2, pe) | 0, w3 = w3 + Math.imul(R3, ve) | 0, g2 = g2 + Math.imul(R3, be) | 0, g2 = g2 + Math.imul(I, ve) | 0, _2 = _2 + Math.imul(I, be) | 0;
      var Ge = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w3 = Math.imul(X, Q), g2 = Math.imul(X, ee), g2 = g2 + Math.imul(J, Q) | 0, _2 = Math.imul(J, ee), w3 = w3 + Math.imul(G, te) | 0, g2 = g2 + Math.imul(G, re2) | 0, g2 = g2 + Math.imul(Y2, te) | 0, _2 = _2 + Math.imul(Y2, re2) | 0, w3 = w3 + Math.imul(V2, ie) | 0, g2 = g2 + Math.imul(V2, ne) | 0, g2 = g2 + Math.imul($2, ie) | 0, _2 = _2 + Math.imul($2, ne) | 0, w3 = w3 + Math.imul(j2, fe) | 0, g2 = g2 + Math.imul(j2, ae) | 0, g2 = g2 + Math.imul(Z2, fe) | 0, _2 = _2 + Math.imul(Z2, ae) | 0, w3 = w3 + Math.imul(W, oe) | 0, g2 = g2 + Math.imul(W, se) | 0, g2 = g2 + Math.imul(K2, oe) | 0, _2 = _2 + Math.imul(K2, se) | 0, w3 = w3 + Math.imul(z, he) | 0, g2 = g2 + Math.imul(z, ue) | 0, g2 = g2 + Math.imul(H2, he) | 0, _2 = _2 + Math.imul(H2, ue) | 0, w3 = w3 + Math.imul(F2, le) | 0, g2 = g2 + Math.imul(F2, de) | 0, g2 = g2 + Math.imul(U, le) | 0, _2 = _2 + Math.imul(U, de) | 0, w3 = w3 + Math.imul(C2, ce2) | 0, g2 = g2 + Math.imul(C2, pe) | 0, g2 = g2 + Math.imul(O2, ce2) | 0, _2 = _2 + Math.imul(O2, pe) | 0, w3 = w3 + Math.imul(k, ve) | 0, g2 = g2 + Math.imul(k, be) | 0, g2 = g2 + Math.imul(D2, ve) | 0, _2 = _2 + Math.imul(D2, be) | 0, w3 = w3 + Math.imul(R3, Be) | 0, g2 = g2 + Math.imul(R3, qe2) | 0, g2 = g2 + Math.imul(I, Be) | 0, _2 = _2 + Math.imul(I, qe2) | 0;
      var Ye = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w3 = Math.imul(X, te), g2 = Math.imul(X, re2), g2 = g2 + Math.imul(J, te) | 0, _2 = Math.imul(J, re2), w3 = w3 + Math.imul(G, ie) | 0, g2 = g2 + Math.imul(G, ne) | 0, g2 = g2 + Math.imul(Y2, ie) | 0, _2 = _2 + Math.imul(Y2, ne) | 0, w3 = w3 + Math.imul(V2, fe) | 0, g2 = g2 + Math.imul(V2, ae) | 0, g2 = g2 + Math.imul($2, fe) | 0, _2 = _2 + Math.imul($2, ae) | 0, w3 = w3 + Math.imul(j2, oe) | 0, g2 = g2 + Math.imul(j2, se) | 0, g2 = g2 + Math.imul(Z2, oe) | 0, _2 = _2 + Math.imul(Z2, se) | 0, w3 = w3 + Math.imul(W, he) | 0, g2 = g2 + Math.imul(W, ue) | 0, g2 = g2 + Math.imul(K2, he) | 0, _2 = _2 + Math.imul(K2, ue) | 0, w3 = w3 + Math.imul(z, le) | 0, g2 = g2 + Math.imul(z, de) | 0, g2 = g2 + Math.imul(H2, le) | 0, _2 = _2 + Math.imul(H2, de) | 0, w3 = w3 + Math.imul(F2, ce2) | 0, g2 = g2 + Math.imul(F2, pe) | 0, g2 = g2 + Math.imul(U, ce2) | 0, _2 = _2 + Math.imul(U, pe) | 0, w3 = w3 + Math.imul(C2, ve) | 0, g2 = g2 + Math.imul(C2, be) | 0, g2 = g2 + Math.imul(O2, ve) | 0, _2 = _2 + Math.imul(O2, be) | 0, w3 = w3 + Math.imul(k, Be) | 0, g2 = g2 + Math.imul(k, qe2) | 0, g2 = g2 + Math.imul(D2, Be) | 0, _2 = _2 + Math.imul(D2, qe2) | 0;
      var Xe = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w3 = Math.imul(X, ie), g2 = Math.imul(X, ne), g2 = g2 + Math.imul(J, ie) | 0, _2 = Math.imul(J, ne), w3 = w3 + Math.imul(G, fe) | 0, g2 = g2 + Math.imul(G, ae) | 0, g2 = g2 + Math.imul(Y2, fe) | 0, _2 = _2 + Math.imul(Y2, ae) | 0, w3 = w3 + Math.imul(V2, oe) | 0, g2 = g2 + Math.imul(V2, se) | 0, g2 = g2 + Math.imul($2, oe) | 0, _2 = _2 + Math.imul($2, se) | 0, w3 = w3 + Math.imul(j2, he) | 0, g2 = g2 + Math.imul(j2, ue) | 0, g2 = g2 + Math.imul(Z2, he) | 0, _2 = _2 + Math.imul(Z2, ue) | 0, w3 = w3 + Math.imul(W, le) | 0, g2 = g2 + Math.imul(W, de) | 0, g2 = g2 + Math.imul(K2, le) | 0, _2 = _2 + Math.imul(K2, de) | 0, w3 = w3 + Math.imul(z, ce2) | 0, g2 = g2 + Math.imul(z, pe) | 0, g2 = g2 + Math.imul(H2, ce2) | 0, _2 = _2 + Math.imul(H2, pe) | 0, w3 = w3 + Math.imul(F2, ve) | 0, g2 = g2 + Math.imul(F2, be) | 0, g2 = g2 + Math.imul(U, ve) | 0, _2 = _2 + Math.imul(U, be) | 0, w3 = w3 + Math.imul(C2, Be) | 0, g2 = g2 + Math.imul(C2, qe2) | 0, g2 = g2 + Math.imul(O2, Be) | 0, _2 = _2 + Math.imul(O2, qe2) | 0;
      var Je = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w3 = Math.imul(X, fe), g2 = Math.imul(X, ae), g2 = g2 + Math.imul(J, fe) | 0, _2 = Math.imul(J, ae), w3 = w3 + Math.imul(G, oe) | 0, g2 = g2 + Math.imul(G, se) | 0, g2 = g2 + Math.imul(Y2, oe) | 0, _2 = _2 + Math.imul(Y2, se) | 0, w3 = w3 + Math.imul(V2, he) | 0, g2 = g2 + Math.imul(V2, ue) | 0, g2 = g2 + Math.imul($2, he) | 0, _2 = _2 + Math.imul($2, ue) | 0, w3 = w3 + Math.imul(j2, le) | 0, g2 = g2 + Math.imul(j2, de) | 0, g2 = g2 + Math.imul(Z2, le) | 0, _2 = _2 + Math.imul(Z2, de) | 0, w3 = w3 + Math.imul(W, ce2) | 0, g2 = g2 + Math.imul(W, pe) | 0, g2 = g2 + Math.imul(K2, ce2) | 0, _2 = _2 + Math.imul(K2, pe) | 0, w3 = w3 + Math.imul(z, ve) | 0, g2 = g2 + Math.imul(z, be) | 0, g2 = g2 + Math.imul(H2, ve) | 0, _2 = _2 + Math.imul(H2, be) | 0, w3 = w3 + Math.imul(F2, Be) | 0, g2 = g2 + Math.imul(F2, qe2) | 0, g2 = g2 + Math.imul(U, Be) | 0, _2 = _2 + Math.imul(U, qe2) | 0;
      var Qe = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w3 = Math.imul(X, oe), g2 = Math.imul(X, se), g2 = g2 + Math.imul(J, oe) | 0, _2 = Math.imul(J, se), w3 = w3 + Math.imul(G, he) | 0, g2 = g2 + Math.imul(G, ue) | 0, g2 = g2 + Math.imul(Y2, he) | 0, _2 = _2 + Math.imul(Y2, ue) | 0, w3 = w3 + Math.imul(V2, le) | 0, g2 = g2 + Math.imul(V2, de) | 0, g2 = g2 + Math.imul($2, le) | 0, _2 = _2 + Math.imul($2, de) | 0, w3 = w3 + Math.imul(j2, ce2) | 0, g2 = g2 + Math.imul(j2, pe) | 0, g2 = g2 + Math.imul(Z2, ce2) | 0, _2 = _2 + Math.imul(Z2, pe) | 0, w3 = w3 + Math.imul(W, ve) | 0, g2 = g2 + Math.imul(W, be) | 0, g2 = g2 + Math.imul(K2, ve) | 0, _2 = _2 + Math.imul(K2, be) | 0, w3 = w3 + Math.imul(z, Be) | 0, g2 = g2 + Math.imul(z, qe2) | 0, g2 = g2 + Math.imul(H2, Be) | 0, _2 = _2 + Math.imul(H2, qe2) | 0;
      var et = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w3 = Math.imul(X, he), g2 = Math.imul(X, ue), g2 = g2 + Math.imul(J, he) | 0, _2 = Math.imul(J, ue), w3 = w3 + Math.imul(G, le) | 0, g2 = g2 + Math.imul(G, de) | 0, g2 = g2 + Math.imul(Y2, le) | 0, _2 = _2 + Math.imul(Y2, de) | 0, w3 = w3 + Math.imul(V2, ce2) | 0, g2 = g2 + Math.imul(V2, pe) | 0, g2 = g2 + Math.imul($2, ce2) | 0, _2 = _2 + Math.imul($2, pe) | 0, w3 = w3 + Math.imul(j2, ve) | 0, g2 = g2 + Math.imul(j2, be) | 0, g2 = g2 + Math.imul(Z2, ve) | 0, _2 = _2 + Math.imul(Z2, be) | 0, w3 = w3 + Math.imul(W, Be) | 0, g2 = g2 + Math.imul(W, qe2) | 0, g2 = g2 + Math.imul(K2, Be) | 0, _2 = _2 + Math.imul(K2, qe2) | 0;
      var tt3 = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, w3 = Math.imul(X, le), g2 = Math.imul(X, de), g2 = g2 + Math.imul(J, le) | 0, _2 = Math.imul(J, de), w3 = w3 + Math.imul(G, ce2) | 0, g2 = g2 + Math.imul(G, pe) | 0, g2 = g2 + Math.imul(Y2, ce2) | 0, _2 = _2 + Math.imul(Y2, pe) | 0, w3 = w3 + Math.imul(V2, ve) | 0, g2 = g2 + Math.imul(V2, be) | 0, g2 = g2 + Math.imul($2, ve) | 0, _2 = _2 + Math.imul($2, be) | 0, w3 = w3 + Math.imul(j2, Be) | 0, g2 = g2 + Math.imul(j2, qe2) | 0, g2 = g2 + Math.imul(Z2, Be) | 0, _2 = _2 + Math.imul(Z2, qe2) | 0;
      var rt3 = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, w3 = Math.imul(X, ce2), g2 = Math.imul(X, pe), g2 = g2 + Math.imul(J, ce2) | 0, _2 = Math.imul(J, pe), w3 = w3 + Math.imul(G, ve) | 0, g2 = g2 + Math.imul(G, be) | 0, g2 = g2 + Math.imul(Y2, ve) | 0, _2 = _2 + Math.imul(Y2, be) | 0, w3 = w3 + Math.imul(V2, Be) | 0, g2 = g2 + Math.imul(V2, qe2) | 0, g2 = g2 + Math.imul($2, Be) | 0, _2 = _2 + Math.imul($2, qe2) | 0;
      var S0 = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w3 = Math.imul(X, ve), g2 = Math.imul(X, be), g2 = g2 + Math.imul(J, ve) | 0, _2 = Math.imul(J, be), w3 = w3 + Math.imul(G, Be) | 0, g2 = g2 + Math.imul(G, qe2) | 0, g2 = g2 + Math.imul(Y2, Be) | 0, _2 = _2 + Math.imul(Y2, qe2) | 0;
      var E0 = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      d2 = (_2 + (g2 >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w3 = Math.imul(X, Be), g2 = Math.imul(X, qe2), g2 = g2 + Math.imul(J, Be) | 0, _2 = Math.imul(J, qe2);
      var A0 = (d2 + w3 | 0) + ((g2 & 8191) << 13) | 0;
      return d2 = (_2 + (g2 >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt3, n[15] = rt3, n[16] = S0, n[17] = E0, n[18] = A0, d2 !== 0 && (n[19] = d2, c.length++), c;
    };
    Math.imul || (N3 = _e);
    function we(h2, s, u) {
      u.negative = s.negative ^ h2.negative, u.length = h2.length + s.length;
      for (var c = 0, b3 = 0, l2 = 0;l2 < u.length - 1; l2++) {
        var n = b3;
        b3 = 0;
        for (var d2 = c & 67108863, w3 = Math.min(l2, s.length - 1), g2 = Math.max(0, l2 - h2.length + 1);g2 <= w3; g2++) {
          var _2 = l2 - g2, A2 = h2.words[_2] | 0, R3 = s.words[g2] | 0, I = A2 * R3, Me = I & 67108863;
          n = n + (I / 67108864 | 0) | 0, Me = Me + d2 | 0, d2 = Me & 67108863, n = n + (Me >>> 26) | 0, b3 += n >>> 26, n &= 67108863;
        }
        u.words[l2] = d2, c = n, n = b3;
      }
      return c !== 0 ? u.words[l2] = c : u.length--, u._strip();
    }
    function ye(h2, s, u) {
      return we(h2, s, u);
    }
    f.prototype.mulTo = function(s, u) {
      var c, b3 = this.length + s.length;
      return this.length === 10 && s.length === 10 ? c = N3(this, s, u) : b3 < 63 ? c = _e(this, s, u) : b3 < 1024 ? c = we(this, s, u) : c = ye(this, s, u), c;
    };
    function xe(h2, s) {
      this.x = h2, this.y = s;
    }
    xe.prototype.makeRBT = function(s) {
      for (var u = new Array(s), c = f.prototype._countBits(s) - 1, b3 = 0;b3 < s; b3++)
        u[b3] = this.revBin(b3, c, s);
      return u;
    }, xe.prototype.revBin = function(s, u, c) {
      if (s === 0 || s === c - 1)
        return s;
      for (var b3 = 0, l2 = 0;l2 < u; l2++)
        b3 |= (s & 1) << u - l2 - 1, s >>= 1;
      return b3;
    }, xe.prototype.permute = function(s, u, c, b3, l2, n) {
      for (var d2 = 0;d2 < n; d2++)
        b3[d2] = u[s[d2]], l2[d2] = c[s[d2]];
    }, xe.prototype.transform = function(s, u, c, b3, l2, n) {
      this.permute(n, s, u, c, b3, l2);
      for (var d2 = 1;d2 < l2; d2 <<= 1)
        for (var w3 = d2 << 1, g2 = Math.cos(2 * Math.PI / w3), _2 = Math.sin(2 * Math.PI / w3), A2 = 0;A2 < l2; A2 += w3)
          for (var R3 = g2, I = _2, Me = 0;Me < d2; Me++) {
            var k = c[A2 + Me], D2 = b3[A2 + Me], nt3 = c[A2 + Me + d2], C2 = b3[A2 + Me + d2], O2 = R3 * nt3 - I * C2;
            C2 = R3 * C2 + I * nt3, nt3 = O2, c[A2 + Me] = k + nt3, b3[A2 + Me] = D2 + C2, c[A2 + Me + d2] = k - nt3, b3[A2 + Me + d2] = D2 - C2, Me !== w3 && (O2 = g2 * R3 - _2 * I, I = g2 * I + _2 * R3, R3 = O2);
          }
    }, xe.prototype.guessLen13b = function(s, u) {
      var c = Math.max(u, s) | 1, b3 = c & 1, l2 = 0;
      for (c = c / 2 | 0;c; c = c >>> 1)
        l2++;
      return 1 << l2 + 1 + b3;
    }, xe.prototype.conjugate = function(s, u, c) {
      if (!(c <= 1))
        for (var b3 = 0;b3 < c / 2; b3++) {
          var l2 = s[b3];
          s[b3] = s[c - b3 - 1], s[c - b3 - 1] = l2, l2 = u[b3], u[b3] = -u[c - b3 - 1], u[c - b3 - 1] = -l2;
        }
    }, xe.prototype.normalize13b = function(s, u) {
      for (var c = 0, b3 = 0;b3 < u / 2; b3++) {
        var l2 = Math.round(s[2 * b3 + 1] / u) * 8192 + Math.round(s[2 * b3] / u) + c;
        s[b3] = l2 & 67108863, l2 < 67108864 ? c = 0 : c = l2 / 67108864 | 0;
      }
      return s;
    }, xe.prototype.convert13b = function(s, u, c, b3) {
      for (var l2 = 0, n = 0;n < u; n++)
        l2 = l2 + (s[n] | 0), c[2 * n] = l2 & 8191, l2 = l2 >>> 13, c[2 * n + 1] = l2 & 8191, l2 = l2 >>> 13;
      for (n = 2 * u;n < b3; ++n)
        c[n] = 0;
      r(l2 === 0), r((l2 & -8192) === 0);
    }, xe.prototype.stub = function(s) {
      for (var u = new Array(s), c = 0;c < s; c++)
        u[c] = 0;
      return u;
    }, xe.prototype.mulp = function(s, u, c) {
      var b3 = 2 * this.guessLen13b(s.length, u.length), l2 = this.makeRBT(b3), n = this.stub(b3), d2 = new Array(b3), w3 = new Array(b3), g2 = new Array(b3), _2 = new Array(b3), A2 = new Array(b3), R3 = new Array(b3), I = c.words;
      I.length = b3, this.convert13b(s.words, s.length, d2, b3), this.convert13b(u.words, u.length, _2, b3), this.transform(d2, n, w3, g2, b3, l2), this.transform(_2, n, A2, R3, b3, l2);
      for (var Me = 0;Me < b3; Me++) {
        var k = w3[Me] * A2[Me] - g2[Me] * R3[Me];
        g2[Me] = w3[Me] * R3[Me] + g2[Me] * A2[Me], w3[Me] = k;
      }
      return this.conjugate(w3, g2, b3), this.transform(w3, g2, I, n, b3, l2), this.conjugate(I, n, b3), this.normalize13b(I, b3), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
    }, f.prototype.mul = function(s) {
      var u = new f(null);
      return u.words = new Array(this.length + s.length), this.mulTo(s, u);
    }, f.prototype.mulf = function(s) {
      var u = new f(null);
      return u.words = new Array(this.length + s.length), ye(this, s, u);
    }, f.prototype.imul = function(s) {
      return this.clone().mulTo(s, this);
    }, f.prototype.imuln = function(s) {
      var u = s < 0;
      u && (s = -s), r(typeof s == "number"), r(s < 67108864);
      for (var c = 0, b3 = 0;b3 < this.length; b3++) {
        var l2 = (this.words[b3] | 0) * s, n = (l2 & 67108863) + (c & 67108863);
        c >>= 26, c += l2 / 67108864 | 0, c += n >>> 26, this.words[b3] = n & 67108863;
      }
      return c !== 0 && (this.words[b3] = c, this.length++), u ? this.ineg() : this;
    }, f.prototype.muln = function(s) {
      return this.clone().imuln(s);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(s) {
      var u = ge(s);
      if (u.length === 0)
        return new f(1);
      for (var c = this, b3 = 0;b3 < u.length && u[b3] === 0; b3++, c = c.sqr())
        ;
      if (++b3 < u.length)
        for (var l2 = c.sqr();b3 < u.length; b3++, l2 = l2.sqr())
          u[b3] !== 0 && (c = c.mul(l2));
      return c;
    }, f.prototype.iushln = function(s) {
      r(typeof s == "number" && s >= 0);
      var u = s % 26, c = (s - u) / 26, b3 = 67108863 >>> 26 - u << 26 - u, l2;
      if (u !== 0) {
        var n = 0;
        for (l2 = 0;l2 < this.length; l2++) {
          var d2 = this.words[l2] & b3, w3 = (this.words[l2] | 0) - d2 << u;
          this.words[l2] = w3 | n, n = d2 >>> 26 - u;
        }
        n && (this.words[l2] = n, this.length++);
      }
      if (c !== 0) {
        for (l2 = this.length - 1;l2 >= 0; l2--)
          this.words[l2 + c] = this.words[l2];
        for (l2 = 0;l2 < c; l2++)
          this.words[l2] = 0;
        this.length += c;
      }
      return this._strip();
    }, f.prototype.ishln = function(s) {
      return r(this.negative === 0), this.iushln(s);
    }, f.prototype.iushrn = function(s, u, c) {
      r(typeof s == "number" && s >= 0);
      var b3;
      u ? b3 = (u - u % 26) / 26 : b3 = 0;
      var l2 = s % 26, n = Math.min((s - l2) / 26, this.length), d2 = 67108863 ^ 67108863 >>> l2 << l2, w3 = c;
      if (b3 -= n, b3 = Math.max(0, b3), w3) {
        for (var g2 = 0;g2 < n; g2++)
          w3.words[g2] = this.words[g2];
        w3.length = n;
      }
      if (n !== 0)
        if (this.length > n)
          for (this.length -= n, g2 = 0;g2 < this.length; g2++)
            this.words[g2] = this.words[g2 + n];
        else
          this.words[0] = 0, this.length = 1;
      var _2 = 0;
      for (g2 = this.length - 1;g2 >= 0 && (_2 !== 0 || g2 >= b3); g2--) {
        var A2 = this.words[g2] | 0;
        this.words[g2] = _2 << 26 - l2 | A2 >>> l2, _2 = A2 & d2;
      }
      return w3 && _2 !== 0 && (w3.words[w3.length++] = _2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, f.prototype.ishrn = function(s, u, c) {
      return r(this.negative === 0), this.iushrn(s, u, c);
    }, f.prototype.shln = function(s) {
      return this.clone().ishln(s);
    }, f.prototype.ushln = function(s) {
      return this.clone().iushln(s);
    }, f.prototype.shrn = function(s) {
      return this.clone().ishrn(s);
    }, f.prototype.ushrn = function(s) {
      return this.clone().iushrn(s);
    }, f.prototype.testn = function(s) {
      r(typeof s == "number" && s >= 0);
      var u = s % 26, c = (s - u) / 26, b3 = 1 << u;
      if (this.length <= c)
        return false;
      var l2 = this.words[c];
      return !!(l2 & b3);
    }, f.prototype.imaskn = function(s) {
      r(typeof s == "number" && s >= 0);
      var u = s % 26, c = (s - u) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
        return this;
      if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
        var b3 = 67108863 ^ 67108863 >>> u << u;
        this.words[this.length - 1] &= b3;
      }
      return this._strip();
    }, f.prototype.maskn = function(s) {
      return this.clone().imaskn(s);
    }, f.prototype.iaddn = function(s) {
      return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
    }, f.prototype._iaddn = function(s) {
      this.words[0] += s;
      for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
        this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
      return this.length = Math.max(this.length, u + 1), this;
    }, f.prototype.isubn = function(s) {
      if (r(typeof s == "number"), r(s < 67108864), s < 0)
        return this.iaddn(-s);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(s), this.negative = 1, this;
      if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var u = 0;u < this.length && this.words[u] < 0; u++)
          this.words[u] += 67108864, this.words[u + 1] -= 1;
      return this._strip();
    }, f.prototype.addn = function(s) {
      return this.clone().iaddn(s);
    }, f.prototype.subn = function(s) {
      return this.clone().isubn(s);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(s, u, c) {
      var b3 = s.length + c, l2;
      this._expand(b3);
      var n, d2 = 0;
      for (l2 = 0;l2 < s.length; l2++) {
        n = (this.words[l2 + c] | 0) + d2;
        var w3 = (s.words[l2] | 0) * u;
        n -= w3 & 67108863, d2 = (n >> 26) - (w3 / 67108864 | 0), this.words[l2 + c] = n & 67108863;
      }
      for (;l2 < this.length - c; l2++)
        n = (this.words[l2 + c] | 0) + d2, d2 = n >> 26, this.words[l2 + c] = n & 67108863;
      if (d2 === 0)
        return this._strip();
      for (r(d2 === -1), d2 = 0, l2 = 0;l2 < this.length; l2++)
        n = -(this.words[l2] | 0) + d2, d2 = n >> 26, this.words[l2] = n & 67108863;
      return this.negative = 1, this._strip();
    }, f.prototype._wordDiv = function(s, u) {
      var c = this.length - s.length, b3 = this.clone(), l2 = s, n = l2.words[l2.length - 1] | 0, d2 = this._countBits(n);
      c = 26 - d2, c !== 0 && (l2 = l2.ushln(c), b3.iushln(c), n = l2.words[l2.length - 1] | 0);
      var w3 = b3.length - l2.length, g2;
      if (u !== "mod") {
        g2 = new f(null), g2.length = w3 + 1, g2.words = new Array(g2.length);
        for (var _2 = 0;_2 < g2.length; _2++)
          g2.words[_2] = 0;
      }
      var A2 = b3.clone()._ishlnsubmul(l2, 1, w3);
      A2.negative === 0 && (b3 = A2, g2 && (g2.words[w3] = 1));
      for (var R3 = w3 - 1;R3 >= 0; R3--) {
        var I = (b3.words[l2.length + R3] | 0) * 67108864 + (b3.words[l2.length + R3 - 1] | 0);
        for (I = Math.min(I / n | 0, 67108863), b3._ishlnsubmul(l2, I, R3);b3.negative !== 0; )
          I--, b3.negative = 0, b3._ishlnsubmul(l2, 1, R3), b3.isZero() || (b3.negative ^= 1);
        g2 && (g2.words[R3] = I);
      }
      return g2 && g2._strip(), b3._strip(), u !== "div" && c !== 0 && b3.iushrn(c), { div: g2 || null, mod: b3 };
    }, f.prototype.divmod = function(s, u, c) {
      if (r(!s.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var b3, l2, n;
      return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b3 = n.div.neg()), u !== "div" && (l2 = n.mod.neg(), c && l2.negative !== 0 && l2.iadd(s)), { div: b3, mod: l2 }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b3 = n.div.neg()), { div: b3, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l2 = n.mod.neg(), c && l2.negative !== 0 && l2.isub(s)), { div: n.div, mod: l2 }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f(this.modrn(s.words[0])) } : this._wordDiv(s, u);
    }, f.prototype.div = function(s) {
      return this.divmod(s, "div", false).div;
    }, f.prototype.mod = function(s) {
      return this.divmod(s, "mod", false).mod;
    }, f.prototype.umod = function(s) {
      return this.divmod(s, "mod", true).mod;
    }, f.prototype.divRound = function(s) {
      var u = this.divmod(s);
      if (u.mod.isZero())
        return u.div;
      var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b3 = s.ushrn(1), l2 = s.andln(1), n = c.cmp(b3);
      return n < 0 || l2 === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
    }, f.prototype.modrn = function(s) {
      var u = s < 0;
      u && (s = -s), r(s <= 67108863);
      for (var c = (1 << 26) % s, b3 = 0, l2 = this.length - 1;l2 >= 0; l2--)
        b3 = (c * b3 + (this.words[l2] | 0)) % s;
      return u ? -b3 : b3;
    }, f.prototype.modn = function(s) {
      return this.modrn(s);
    }, f.prototype.idivn = function(s) {
      var u = s < 0;
      u && (s = -s), r(s <= 67108863);
      for (var c = 0, b3 = this.length - 1;b3 >= 0; b3--) {
        var l2 = (this.words[b3] | 0) + c * 67108864;
        this.words[b3] = l2 / s | 0, c = l2 % s;
      }
      return this._strip(), u ? this.ineg() : this;
    }, f.prototype.divn = function(s) {
      return this.clone().idivn(s);
    }, f.prototype.egcd = function(s) {
      r(s.negative === 0), r(!s.isZero());
      var u = this, c = s.clone();
      u.negative !== 0 ? u = u.umod(s) : u = u.clone();
      for (var b3 = new f(1), l2 = new f(0), n = new f(0), d2 = new f(1), w3 = 0;u.isEven() && c.isEven(); )
        u.iushrn(1), c.iushrn(1), ++w3;
      for (var g2 = c.clone(), _2 = u.clone();!u.isZero(); ) {
        for (var A2 = 0, R3 = 1;(u.words[0] & R3) === 0 && A2 < 26; ++A2, R3 <<= 1)
          ;
        if (A2 > 0)
          for (u.iushrn(A2);A2-- > 0; )
            (b3.isOdd() || l2.isOdd()) && (b3.iadd(g2), l2.isub(_2)), b3.iushrn(1), l2.iushrn(1);
        for (var I = 0, Me = 1;(c.words[0] & Me) === 0 && I < 26; ++I, Me <<= 1)
          ;
        if (I > 0)
          for (c.iushrn(I);I-- > 0; )
            (n.isOdd() || d2.isOdd()) && (n.iadd(g2), d2.isub(_2)), n.iushrn(1), d2.iushrn(1);
        u.cmp(c) >= 0 ? (u.isub(c), b3.isub(n), l2.isub(d2)) : (c.isub(u), n.isub(b3), d2.isub(l2));
      }
      return { a: n, b: d2, gcd: c.iushln(w3) };
    }, f.prototype._invmp = function(s) {
      r(s.negative === 0), r(!s.isZero());
      var u = this, c = s.clone();
      u.negative !== 0 ? u = u.umod(s) : u = u.clone();
      for (var b3 = new f(1), l2 = new f(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
        for (var d2 = 0, w3 = 1;(u.words[0] & w3) === 0 && d2 < 26; ++d2, w3 <<= 1)
          ;
        if (d2 > 0)
          for (u.iushrn(d2);d2-- > 0; )
            b3.isOdd() && b3.iadd(n), b3.iushrn(1);
        for (var g2 = 0, _2 = 1;(c.words[0] & _2) === 0 && g2 < 26; ++g2, _2 <<= 1)
          ;
        if (g2 > 0)
          for (c.iushrn(g2);g2-- > 0; )
            l2.isOdd() && l2.iadd(n), l2.iushrn(1);
        u.cmp(c) >= 0 ? (u.isub(c), b3.isub(l2)) : (c.isub(u), l2.isub(b3));
      }
      var A2;
      return u.cmpn(1) === 0 ? A2 = b3 : A2 = l2, A2.cmpn(0) < 0 && A2.iadd(s), A2;
    }, f.prototype.gcd = function(s) {
      if (this.isZero())
        return s.abs();
      if (s.isZero())
        return this.abs();
      var u = this.clone(), c = s.clone();
      u.negative = 0, c.negative = 0;
      for (var b3 = 0;u.isEven() && c.isEven(); b3++)
        u.iushrn(1), c.iushrn(1);
      do {
        for (;u.isEven(); )
          u.iushrn(1);
        for (;c.isEven(); )
          c.iushrn(1);
        var l2 = u.cmp(c);
        if (l2 < 0) {
          var n = u;
          u = c, c = n;
        } else if (l2 === 0 || c.cmpn(1) === 0)
          break;
        u.isub(c);
      } while (true);
      return c.iushln(b3);
    }, f.prototype.invm = function(s) {
      return this.egcd(s).a.umod(s);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(s) {
      return this.words[0] & s;
    }, f.prototype.bincn = function(s) {
      r(typeof s == "number");
      var u = s % 26, c = (s - u) / 26, b3 = 1 << u;
      if (this.length <= c)
        return this._expand(c + 1), this.words[c] |= b3, this;
      for (var l2 = b3, n = c;l2 !== 0 && n < this.length; n++) {
        var d2 = this.words[n] | 0;
        d2 += l2, l2 = d2 >>> 26, d2 &= 67108863, this.words[n] = d2;
      }
      return l2 !== 0 && (this.words[n] = l2, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(s) {
      var u = s < 0;
      if (this.negative !== 0 && !u)
        return -1;
      if (this.negative === 0 && u)
        return 1;
      this._strip();
      var c;
      if (this.length > 1)
        c = 1;
      else {
        u && (s = -s), r(s <= 67108863, "Number is too big");
        var b3 = this.words[0] | 0;
        c = b3 === s ? 0 : b3 < s ? -1 : 1;
      }
      return this.negative !== 0 ? -c | 0 : c;
    }, f.prototype.cmp = function(s) {
      if (this.negative !== 0 && s.negative === 0)
        return -1;
      if (this.negative === 0 && s.negative !== 0)
        return 1;
      var u = this.ucmp(s);
      return this.negative !== 0 ? -u | 0 : u;
    }, f.prototype.ucmp = function(s) {
      if (this.length > s.length)
        return 1;
      if (this.length < s.length)
        return -1;
      for (var u = 0, c = this.length - 1;c >= 0; c--) {
        var b3 = this.words[c] | 0, l2 = s.words[c] | 0;
        if (b3 !== l2) {
          b3 < l2 ? u = -1 : b3 > l2 && (u = 1);
          break;
        }
      }
      return u;
    }, f.prototype.gtn = function(s) {
      return this.cmpn(s) === 1;
    }, f.prototype.gt = function(s) {
      return this.cmp(s) === 1;
    }, f.prototype.gten = function(s) {
      return this.cmpn(s) >= 0;
    }, f.prototype.gte = function(s) {
      return this.cmp(s) >= 0;
    }, f.prototype.ltn = function(s) {
      return this.cmpn(s) === -1;
    }, f.prototype.lt = function(s) {
      return this.cmp(s) === -1;
    }, f.prototype.lten = function(s) {
      return this.cmpn(s) <= 0;
    }, f.prototype.lte = function(s) {
      return this.cmp(s) <= 0;
    }, f.prototype.eqn = function(s) {
      return this.cmpn(s) === 0;
    }, f.prototype.eq = function(s) {
      return this.cmp(s) === 0;
    }, f.red = function(s) {
      return new i(s);
    }, f.prototype.toRed = function(s) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(s) {
      return this.red = s, this;
    }, f.prototype.forceRed = function(s) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
    }, f.prototype.redAdd = function(s) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
    }, f.prototype.redIAdd = function(s) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
    }, f.prototype.redSub = function(s) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
    }, f.prototype.redISub = function(s) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
    }, f.prototype.redShl = function(s) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
    }, f.prototype.redMul = function(s) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
    }, f.prototype.redIMul = function(s) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(s) {
      return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
    };
    var Re = { k256: null, p224: null, p192: null, p25519: null };
    function Ee(h2, s) {
      this.name = h2, this.p = new f(s, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ee.prototype._tmp = function() {
      var s = new f(null);
      return s.words = new Array(Math.ceil(this.n / 13)), s;
    }, Ee.prototype.ireduce = function(s) {
      var u = s, c;
      do
        this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
      while (c > this.n);
      var b3 = c < this.n ? -1 : u.ucmp(this.p);
      return b3 === 0 ? (u.words[0] = 0, u.length = 1) : b3 > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
    }, Ee.prototype.split = function(s, u) {
      s.iushrn(this.n, 0, u);
    }, Ee.prototype.imulK = function(s) {
      return s.imul(this.k);
    };
    function Ae2() {
      Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(Ae2, Ee), Ae2.prototype.split = function(s, u) {
      for (var c = 4194303, b3 = Math.min(s.length, 9), l2 = 0;l2 < b3; l2++)
        u.words[l2] = s.words[l2];
      if (u.length = b3, s.length <= 9) {
        s.words[0] = 0, s.length = 1;
        return;
      }
      var n = s.words[9];
      for (u.words[u.length++] = n & c, l2 = 10;l2 < s.length; l2++) {
        var d2 = s.words[l2] | 0;
        s.words[l2 - 10] = (d2 & c) << 4 | n >>> 22, n = d2;
      }
      n >>>= 22, s.words[l2 - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
    }, Ae2.prototype.imulK = function(s) {
      s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
      for (var u = 0, c = 0;c < s.length; c++) {
        var b3 = s.words[c] | 0;
        u += b3 * 977, s.words[c] = u & 67108863, u = b3 * 64 + (u / 67108864 | 0);
      }
      return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
    };
    function P3() {
      Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(P3, Ee);
    function Se2() {
      Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Se2, Ee);
    function v3() {
      Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(v3, Ee), v3.prototype.imulK = function(s) {
      for (var u = 0, c = 0;c < s.length; c++) {
        var b3 = (s.words[c] | 0) * 19 + u, l2 = b3 & 67108863;
        b3 >>>= 26, s.words[c] = l2, u = b3;
      }
      return u !== 0 && (s.words[s.length++] = u), s;
    }, f._prime = function(s) {
      if (Re[s])
        return Re[s];
      var u;
      if (s === "k256")
        u = new Ae2;
      else if (s === "p224")
        u = new P3;
      else if (s === "p192")
        u = new Se2;
      else if (s === "p25519")
        u = new v3;
      else
        throw new Error("Unknown prime " + s);
      return Re[s] = u, u;
    };
    function i(h2) {
      if (typeof h2 == "string") {
        var s = f._prime(h2);
        this.m = s.p, this.prime = s;
      } else
        r(h2.gtn(1), "modulus must be greater than 1"), this.m = h2, this.prime = null;
    }
    i.prototype._verify1 = function(s) {
      r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
    }, i.prototype._verify2 = function(s, u) {
      r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
    }, i.prototype.imod = function(s) {
      return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x3(s, s.umod(this.m)._forceRed(this)), s);
    }, i.prototype.neg = function(s) {
      return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
    }, i.prototype.add = function(s, u) {
      this._verify2(s, u);
      var c = s.add(u);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
    }, i.prototype.iadd = function(s, u) {
      this._verify2(s, u);
      var c = s.iadd(u);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c;
    }, i.prototype.sub = function(s, u) {
      this._verify2(s, u);
      var c = s.sub(u);
      return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
    }, i.prototype.isub = function(s, u) {
      this._verify2(s, u);
      var c = s.isub(u);
      return c.cmpn(0) < 0 && c.iadd(this.m), c;
    }, i.prototype.shl = function(s, u) {
      return this._verify1(s), this.imod(s.ushln(u));
    }, i.prototype.imul = function(s, u) {
      return this._verify2(s, u), this.imod(s.imul(u));
    }, i.prototype.mul = function(s, u) {
      return this._verify2(s, u), this.imod(s.mul(u));
    }, i.prototype.isqr = function(s) {
      return this.imul(s, s.clone());
    }, i.prototype.sqr = function(s) {
      return this.mul(s, s);
    }, i.prototype.sqrt = function(s) {
      if (s.isZero())
        return s.clone();
      var u = this.m.andln(3);
      if (r(u % 2 === 1), u === 3) {
        var c = this.m.add(new f(1)).iushrn(2);
        return this.pow(s, c);
      }
      for (var b3 = this.m.subn(1), l2 = 0;!b3.isZero() && b3.andln(1) === 0; )
        l2++, b3.iushrn(1);
      r(!b3.isZero());
      var n = new f(1).toRed(this), d2 = n.redNeg(), w3 = this.m.subn(1).iushrn(1), g2 = this.m.bitLength();
      for (g2 = new f(2 * g2 * g2).toRed(this);this.pow(g2, w3).cmp(d2) !== 0; )
        g2.redIAdd(d2);
      for (var _2 = this.pow(g2, b3), A2 = this.pow(s, b3.addn(1).iushrn(1)), R3 = this.pow(s, b3), I = l2;R3.cmp(n) !== 0; ) {
        for (var Me = R3, k = 0;Me.cmp(n) !== 0; k++)
          Me = Me.redSqr();
        r(k < I);
        var D2 = this.pow(_2, new f(1).iushln(I - k - 1));
        A2 = A2.redMul(D2), _2 = D2.redSqr(), R3 = R3.redMul(_2), I = k;
      }
      return A2;
    }, i.prototype.invm = function(s) {
      var u = s._invmp(this.m);
      return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
    }, i.prototype.pow = function(s, u) {
      if (u.isZero())
        return new f(1).toRed(this);
      if (u.cmpn(1) === 0)
        return s.clone();
      var c = 4, b3 = new Array(1 << c);
      b3[0] = new f(1).toRed(this), b3[1] = s;
      for (var l2 = 2;l2 < b3.length; l2++)
        b3[l2] = this.mul(b3[l2 - 1], s);
      var n = b3[0], d2 = 0, w3 = 0, g2 = u.bitLength() % 26;
      for (g2 === 0 && (g2 = 26), l2 = u.length - 1;l2 >= 0; l2--) {
        for (var _2 = u.words[l2], A2 = g2 - 1;A2 >= 0; A2--) {
          var R3 = _2 >> A2 & 1;
          if (n !== b3[0] && (n = this.sqr(n)), R3 === 0 && d2 === 0) {
            w3 = 0;
            continue;
          }
          d2 <<= 1, d2 |= R3, w3++, !(w3 !== c && (l2 !== 0 || A2 !== 0)) && (n = this.mul(n, b3[d2]), w3 = 0, d2 = 0);
        }
        g2 = 26;
      }
      return n;
    }, i.prototype.convertTo = function(s) {
      var u = s.umod(this.m);
      return u === s ? u.clone() : u;
    }, i.prototype.convertFrom = function(s) {
      var u = s.clone();
      return u.red = null, u;
    }, f.mont = function(s) {
      return new a2(s);
    };
    function a2(h2) {
      i.call(this, h2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(a2, i), a2.prototype.convertTo = function(s) {
      return this.imod(s.ushln(this.shift));
    }, a2.prototype.convertFrom = function(s) {
      var u = this.imod(s.mul(this.rinv));
      return u.red = null, u;
    }, a2.prototype.imul = function(s, u) {
      if (s.isZero() || u.isZero())
        return s.words[0] = 0, s.length = 1, s;
      var c = s.imul(u), b3 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l2 = c.isub(b3).iushrn(this.shift), n = l2;
      return l2.cmp(this.m) >= 0 ? n = l2.isub(this.m) : l2.cmpn(0) < 0 && (n = l2.iadd(this.m)), n._forceRed(this);
    }, a2.prototype.mul = function(s, u) {
      if (s.isZero() || u.isZero())
        return new f(0)._forceRed(this);
      var c = s.mul(u), b3 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l2 = c.isub(b3).iushrn(this.shift), n = l2;
      return l2.cmp(this.m) >= 0 ? n = l2.isub(this.m) : l2.cmpn(0) < 0 && (n = l2.iadd(this.m)), n._forceRed(this);
    }, a2.prototype.invm = function(s) {
      var u = this.imod(s._invmp(this.m).mul(this.r2));
      return u._forceRed(this);
    };
  })(typeof kl > "u" || kl, n2);
});
var Ks = T((yk, o2) => {
  var Rf = Ws(), oA = on();
  function sA(t) {
    var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
    return { blinder: r, unblinder: e.invm(t.modulus) };
  }
  function f2(t) {
    var e = t.modulus.byteLength(), r;
    do
      r = new Rf(oA(e));
    while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r;
  }
  function a2(t, e) {
    var r = sA(e), o3 = e.modulus.byteLength(), f = new Rf(t).mul(r.blinder).umod(e.modulus), p2 = f.toRed(Rf.mont(e.prime1)), m2 = f.toRed(Rf.mont(e.prime2)), y2 = e.coefficient, M2 = e.prime1, x3 = e.prime2, S = p2.redPow(e.exponent1).fromRed(), E3 = m2.redPow(e.exponent2).fromRed(), B = S.isub(E3).imul(y2).umod(M2).imul(x3);
    return E3.iadd(B).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o3);
  }
  a2.getr = f2;
  o2.exports = a2;
});
var s2 = T((wk, hA) => {
  hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var ri = T((h2, Ll) => {
  (function(t, e) {
    function r(v3, i) {
      if (!v3)
        throw new Error(i || "Assertion failed");
    }
    function o2(v3, i) {
      v3.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v3.prototype = new a2, v3.prototype.constructor = v3;
    }
    function f(v3, i, a2) {
      if (f.isBN(v3))
        return v3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v3 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v3 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h3) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h3);
      if (typeof i == "object")
        return this._initArray(i, a2, h3);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h3) : (this._parseBase(i, a2, s), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
    }, f.prototype._initNumber = function(i, a2, h3) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
    }, f.prototype._initArray = function(i, a2, h3) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h3 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h3 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v3, i) {
      var a2 = v3.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y2(v3, i, a2) {
      var h3 = m2(v3, a2);
      return a2 - 1 >= i && (h3 |= m2(v3, a2 - 1) << 4), h3;
    }
    f.prototype._parseHex = function(i, a2, h3) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h3 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y2(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v3, i, a2, h3) {
      for (var s = 0, u = Math.min(v3.length, a2), c = i;c < u; c++) {
        var b3 = v3.charCodeAt(c) - 48;
        s *= h3, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h3) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h3, b3 = c % s, l2 = Math.min(c, c - b3) + h3, n = 0, d2 = h3;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h3;
      if (i === 16 || i === "hex") {
        h3 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h3 = u.toString(16) + h3);h3.length % a2 !== 0; )
          h3 = "0" + h3;
        return this.negative !== 0 && (h3 = "-" + h3), h3;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h3 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h3 = g2 + h3 : h3 = x3[n - g2.length] + g2 + h3;
        }
        for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
          h3 = "0" + h3;
        return this.negative !== 0 && (h3 = "-" + h3), h3;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h3) {
      var s = this.byteLength(), u = h3 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h3 = 0;
      return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h3 = 0;
      return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v3) {
      for (var i = new Array(v3.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h3 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v3.words[h3] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h3 = this._zeroBits(this.words[a2]);
        if (i += h3, h3 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h3 = 0;h3 < a2.length; h3++)
        this.words[h3] = this.words[h3] & i.words[h3];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h3;
      this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
      for (var s = 0;s < h3.length; s++)
        this.words[s] = a2.words[s] ^ h3.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
      this._expand(a2), h3 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h3 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h3), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h3 = i / 26 | 0, s = i % 26;
      return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s : this.words[h3] = this.words[h3] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h3, s;
      this.length > i.length ? (h3 = this, s = i) : (h3 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h3.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h3.length; c++)
        a2 = (h3.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h3.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h3 !== this)
        for (;c < h3.length; c++)
          this.words[c] = h3.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h3 = this.cmp(i);
      if (h3 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h3 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative;
      var h3 = v3.length + i.length | 0;
      a2.length = h3, h3 = h3 - 1 | 0;
      var s = v3.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h3; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _2 = Math.max(0, n - v3.length + 1);_2 <= g2; _2++) {
          var A2 = n - _2 | 0;
          s = v3.words[A2] | 0, u = i.words[_2] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h3) {
      var s = i.words, u = a2.words, c = h3.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _2 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z2 = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_2, X) | 0, d2 = Math.imul(_2, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_2, Q) | 0, d2 = d2 + Math.imul(_2, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_2, te) | 0, d2 = d2 + Math.imul(_2, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_2, ie) | 0, d2 = d2 + Math.imul(_2, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_2, fe) | 0, d2 = d2 + Math.imul(_2, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_2, oe) | 0, d2 = d2 + Math.imul(_2, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_2, he) | 0, d2 = d2 + Math.imul(_2, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z2, X) | 0, d2 = Math.imul(Z2, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_2, le) | 0, d2 = d2 + Math.imul(_2, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z2, Q) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_2, ce2) | 0, d2 = d2 + Math.imul(_2, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_2, ve) | 0, d2 = d2 + Math.imul(_2, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z2, ce2) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h3.length++), h3;
    };
    Math.imul || (L2 = q);
    function ge(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative, a2.length = v3.length + i.length;
      for (var h3 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h3 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v3.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v3.words[d2] | 0, g2 = i.words[n] | 0, _2 = w3 * g2, A2 = _2 & 67108863;
          c = c + (_2 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h3 = c, c = s;
      }
      return h3 !== 0 ? a2.words[u] = h3 : a2.length--, a2.strip();
    }
    function _e(v3, i, a2) {
      var h3 = new N3;
      return h3.mulp(v3, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h3, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h3 = L2(this, i, a2) : s < 63 ? h3 = q(this, i, a2) : s < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
    };
    function N3(v3, i) {
      this.x = v3, this.y = i;
    }
    N3.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h3 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h3, i);
      return a2;
    }, N3.prototype.revBin = function(i, a2, h3) {
      if (i === 0 || i === h3 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N3.prototype.permute = function(i, a2, h3, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h3[i[b3]];
    }, N3.prototype.transform = function(i, a2, h3, s, u, c) {
      this.permute(c, i, a2, h3, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _2 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h3[w3 + A2], I = s[w3 + A2], Me = h3[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _2 * k;
            k = g2 * k + _2 * Me, Me = D2, h3[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h3[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _2, _2 = n * _2 + d2 * g2, g2 = D2);
          }
    }, N3.prototype.guessLen13b = function(i, a2) {
      var h3 = Math.max(a2, i) | 1, s = h3 & 1, u = 0;
      for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N3.prototype.conjugate = function(i, a2, h3) {
      if (!(h3 <= 1))
        for (var s = 0;s < h3 / 2; s++) {
          var u = i[s];
          i[s] = i[h3 - s - 1], i[h3 - s - 1] = u, u = a2[s], a2[s] = -a2[h3 - s - 1], a2[h3 - s - 1] = -u;
        }
    }, N3.prototype.normalize13b = function(i, a2) {
      for (var h3 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h3;
        i[s] = u & 67108863, u < 67108864 ? h3 = 0 : h3 = u / 67108864 | 0;
      }
      return i;
    }, N3.prototype.convert13b = function(i, a2, h3, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h3[2 * c] = u & 8191, u = u >>> 13, h3[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h3[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N3.prototype.stub = function(i) {
      for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
        a2[h3] = 0;
      return a2;
    }, N3.prototype.mulp = function(i, a2, h3) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _2 = h3.words;
      _2.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
        var s = (this.words[h3] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h3] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h3 = this, s = 0;s < a2.length && a2[s] === 0; s++, h3 = h3.sqr())
        ;
      if (++s < a2.length)
        for (var u = h3.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h3 = h3.mul(u));
      return h3;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h3 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h3 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h3] = this.words[u];
        for (u = 0;u < h3; u++)
          this.words[u] = 0;
        this.length += h3;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h3) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h3;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h3) {
      return r(this.negative === 0), this.iushrn(i, a2, h3);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h3 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h3)
        return false;
      var u = this.words[h3];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h3 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
        return this;
      if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h3) {
      var s = i.length + h3, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h3] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h3] = c & 67108863;
      }
      for (;u < this.length - h3; u++)
        c = (this.words[u + h3] | 0) + b3, b3 = c >> 26, this.words[u + h3] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h3 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h3 = 26 - b3, h3 !== 0 && (u = u.ushln(h3), s.iushln(h3), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _2 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g2);s.negative !== 0; )
          _2--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _2);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h3 !== 0 && s.iushrn(h3), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h3) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h3 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h3 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h3.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h3 = 0, s = this.length - 1;s >= 0; s--)
        h3 = (a2 * h3 + (this.words[s] | 0)) % i;
      return h3;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
        var s = (this.words[h3] | 0) + a2 * 67108864;
        this.words[h3] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h3 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h3.isEven(); )
        a2.iushrn(1), h3.iushrn(1), ++l2;
      for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _2 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _2 < 26; ++_2, A2 <<= 1)
          ;
        if (_2 > 0)
          for (h3.iushrn(_2);_2-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h3) >= 0 ? (a2.isub(h3), s.isub(c), u.isub(b3)) : (h3.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h3.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h3 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h3.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h3) >= 0 ? (a2.isub(h3), s.isub(u)) : (h3.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h3 = i.clone();
      a2.negative = 0, h3.negative = 0;
      for (var s = 0;a2.isEven() && h3.isEven(); s++)
        a2.iushrn(1), h3.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h3.isEven(); )
          h3.iushrn(1);
        var u = a2.cmp(h3);
        if (u < 0) {
          var c = a2;
          a2 = h3, h3 = c;
        } else if (u === 0 || h3.cmpn(1) === 0)
          break;
        a2.isub(h3);
      } while (true);
      return h3.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h3 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h3)
        return this._expand(h3 + 1), this.words[h3] |= s, this;
      for (var u = s, c = h3;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h3;
      if (this.length > 1)
        h3 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h3 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h3 | 0 : h3;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
        var s = this.words[h3] | 0, u = i.words[h3] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P3(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v3, i) {
      this.name = v3, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h3;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
      while (h3 > this.n);
      var s = h3 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h3 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h3, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h3) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
        var s = i.words[h3] | 0;
        a2 += s * 977, i.words[h3] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
        var s = (i.words[h3] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h3] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P3(v3) {
      if (typeof v3 == "string") {
        var i = f._prime(v3);
        this.m = i.p, this.prime = i;
      } else
        r(v3.gtn(1), "modulus must be greater than 1"), this.m = v3, this.prime = null;
    }
    P3.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P3.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P3.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P3.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P3.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h3 = i.add(a2);
      return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
    }, P3.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h3 = i.iadd(a2);
      return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
    }, P3.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h3 = i.sub(a2);
      return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
    }, P3.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h3 = i.isub(a2);
      return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
    }, P3.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P3.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P3.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P3.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P3.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P3.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h3 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h3);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _2 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _2);
        var I = this.pow(d2, new f(1).iushln(_2 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _2 = R3;
      }
      return w3;
    }, P3.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P3.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h3 = 4, s = new Array(1 << h3);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h3 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P3.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P3.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v3) {
      P3.call(this, v3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P3), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h3 = i.imul(a2), s = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h3.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h3 = i.mul(a2), s = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h3.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof Ll > "u" || Ll, h2);
});
var Nl = T((d2) => {
  var js = d2;
  function uA(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t != "string") {
      for (var o2 = 0;o2 < t.length; o2++)
        r[o2] = t[o2] | 0;
      return r;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var o2 = 0;o2 < t.length; o2 += 2)
        r.push(parseInt(t[o2] + t[o2 + 1], 16));
    } else
      for (var o2 = 0;o2 < t.length; o2++) {
        var f = t.charCodeAt(o2), p2 = f >> 8, m2 = f & 255;
        p2 ? r.push(p2, m2) : r.push(m2);
      }
    return r;
  }
  js.toArray = uA;
  function u2(t) {
    return t.length === 1 ? "0" + t : t;
  }
  js.zero2 = u2;
  function l2(t) {
    for (var e = "", r = 0;r < t.length; r++)
      e += u2(t[r].toString(16));
    return e;
  }
  js.toHex = l2;
  js.encode = function(e, r) {
    return r === "hex" ? l2(e) : e;
  };
});
var or = T((c2) => {
  var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
  Pr.assert = dA;
  Pr.toArray = Zs.toArray;
  Pr.zero2 = Zs.zero2;
  Pr.toHex = Zs.toHex;
  Pr.encode = Zs.encode;
  function cA(t, e, r) {
    var o2 = new Array(Math.max(t.bitLength(), r) + 1);
    o2.fill(0);
    for (var f = 1 << e + 1, p2 = t.clone(), m2 = 0;m2 < o2.length; m2++) {
      var y2, M2 = p2.andln(f - 1);
      p2.isOdd() ? (M2 > (f >> 1) - 1 ? y2 = (f >> 1) - M2 : y2 = M2, p2.isubn(y2)) : y2 = 0, o2[m2] = y2, p2.iushrn(1);
    }
    return o2;
  }
  Pr.getNAF = cA;
  function pA(t, e) {
    var r = [[], []];
    t = t.clone(), e = e.clone();
    for (var o2 = 0, f = 0, p2;t.cmpn(-o2) > 0 || e.cmpn(-f) > 0; ) {
      var m2 = t.andln(3) + o2 & 3, y2 = e.andln(3) + f & 3;
      m2 === 3 && (m2 = -1), y2 === 3 && (y2 = -1);
      var M2;
      (m2 & 1) === 0 ? M2 = 0 : (p2 = t.andln(7) + o2 & 7, (p2 === 3 || p2 === 5) && y2 === 2 ? M2 = -m2 : M2 = m2), r[0].push(M2);
      var x3;
      (y2 & 1) === 0 ? x3 = 0 : (p2 = e.andln(7) + f & 7, (p2 === 3 || p2 === 5) && m2 === 2 ? x3 = -y2 : x3 = y2), r[1].push(x3), 2 * o2 === M2 + 1 && (o2 = 1 - o2), 2 * f === x3 + 1 && (f = 1 - f), t.iushrn(1), e.iushrn(1);
    }
    return r;
  }
  Pr.getJSF = pA;
  function vA(t, e, r) {
    var o2 = "_" + e;
    t.prototype[e] = function() {
      return this[o2] !== undefined ? this[o2] : this[o2] = r.call(this);
    };
  }
  Pr.cachedProperty = vA;
  function bA(t) {
    return typeof t == "string" ? Pr.toArray(t, "hex") : t;
  }
  Pr.parseBytes = bA;
  function mA(t) {
    return new lA(t, "hex", "le");
  }
  Pr.intFromLE = mA;
});
var Oa = T((xk, p2) => {
  var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
  function Xi(t, e) {
    this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  p2.exports = Xi;
  Xi.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Xi.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Xi.prototype._fixedNafMul = function(e, r) {
    $s(e.precomputed);
    var o2 = e._getDoubles(), f = Vs(r, 1, this._bitLength), p3 = (1 << o2.step + 1) - (o2.step % 2 === 0 ? 2 : 1);
    p3 /= 3;
    var m2 = [], y2, M2;
    for (y2 = 0;y2 < f.length; y2 += o2.step) {
      M2 = 0;
      for (var x3 = y2 + o2.step - 1;x3 >= y2; x3--)
        M2 = (M2 << 1) + f[x3];
      m2.push(M2);
    }
    for (var S = this.jpoint(null, null, null), E3 = this.jpoint(null, null, null), B = p3;B > 0; B--) {
      for (y2 = 0;y2 < m2.length; y2++)
        M2 = m2[y2], M2 === B ? E3 = E3.mixedAdd(o2.points[y2]) : M2 === -B && (E3 = E3.mixedAdd(o2.points[y2].neg()));
      S = S.add(E3);
    }
    return S.toP();
  };
  Xi.prototype._wnafMul = function(e, r) {
    var o2 = 4, f = e._getNAFPoints(o2);
    o2 = f.wnd;
    for (var p3 = f.points, m2 = Vs(r, o2, this._bitLength), y2 = this.jpoint(null, null, null), M2 = m2.length - 1;M2 >= 0; M2--) {
      for (var x3 = 0;M2 >= 0 && m2[M2] === 0; M2--)
        x3++;
      if (M2 >= 0 && x3++, y2 = y2.dblp(x3), M2 < 0)
        break;
      var S = m2[M2];
      $s(S !== 0), e.type === "affine" ? S > 0 ? y2 = y2.mixedAdd(p3[S - 1 >> 1]) : y2 = y2.mixedAdd(p3[-S - 1 >> 1].neg()) : S > 0 ? y2 = y2.add(p3[S - 1 >> 1]) : y2 = y2.add(p3[-S - 1 >> 1].neg());
    }
    return e.type === "affine" ? y2.toP() : y2;
  };
  Xi.prototype._wnafMulAdd = function(e, r, o2, f, p3) {
    var m2 = this._wnafT1, y2 = this._wnafT2, M2 = this._wnafT3, x3 = 0, S, E3, B;
    for (S = 0;S < f; S++) {
      B = r[S];
      var q = B._getNAFPoints(e);
      m2[S] = q.wnd, y2[S] = q.points;
    }
    for (S = f - 1;S >= 1; S -= 2) {
      var L2 = S - 1, ge = S;
      if (m2[L2] !== 1 || m2[ge] !== 1) {
        M2[L2] = Vs(o2[L2], m2[L2], this._bitLength), M2[ge] = Vs(o2[ge], m2[ge], this._bitLength), x3 = Math.max(M2[L2].length, x3), x3 = Math.max(M2[ge].length, x3);
        continue;
      }
      var _e = [r[L2], null, null, r[ge]];
      r[L2].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L2].add(r[ge]), _e[2] = r[L2].toJ().mixedAdd(r[ge].neg())) : r[L2].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L2].toJ().mixedAdd(r[ge]), _e[2] = r[L2].add(r[ge].neg())) : (_e[1] = r[L2].toJ().mixedAdd(r[ge]), _e[2] = r[L2].toJ().mixedAdd(r[ge].neg()));
      var N3 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o2[L2], o2[ge]);
      for (x3 = Math.max(we[0].length, x3), M2[L2] = new Array(x3), M2[ge] = new Array(x3), E3 = 0;E3 < x3; E3++) {
        var ye = we[0][E3] | 0, xe = we[1][E3] | 0;
        M2[L2][E3] = N3[(ye + 1) * 3 + (xe + 1)], M2[ge][E3] = 0, y2[L2] = _e;
      }
    }
    var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
    for (S = x3;S >= 0; S--) {
      for (var Ae2 = 0;S >= 0; ) {
        var P3 = true;
        for (E3 = 0;E3 < f; E3++)
          Ee[E3] = M2[E3][S] | 0, Ee[E3] !== 0 && (P3 = false);
        if (!P3)
          break;
        Ae2++, S--;
      }
      if (S >= 0 && Ae2++, Re = Re.dblp(Ae2), S < 0)
        break;
      for (E3 = 0;E3 < f; E3++) {
        var Se2 = Ee[E3];
        Se2 !== 0 && (Se2 > 0 ? B = y2[E3][Se2 - 1 >> 1] : Se2 < 0 && (B = y2[E3][-Se2 - 1 >> 1].neg()), B.type === "affine" ? Re = Re.mixedAdd(B) : Re = Re.add(B));
      }
    }
    for (S = 0;S < f; S++)
      y2[S] = null;
    return p3 ? Re : Re.toP();
  };
  function _r(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Xi.BasePoint = _r;
  _r.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  _r.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Xi.prototype.decodePoint = function(e, r) {
    e = Ca.toArray(e, r);
    var o2 = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o2) {
      e[0] === 6 ? $s(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s(e[e.length - 1] % 2 === 1);
      var f = this.point(e.slice(1, 1 + o2), e.slice(1 + o2, 1 + 2 * o2));
      return f;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o2)
      return this.pointFromX(e.slice(1, 1 + o2), e[0] === 3);
    throw new Error("Unknown point format");
  };
  _r.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  _r.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(), o2 = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(o2) : [4].concat(o2, this.getY().toArray("be", r));
  };
  _r.prototype.encode = function(e, r) {
    return Ca.encode(this._encode(r), e);
  };
  _r.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r = { doubles: null, naf: null, beta: null };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
  };
  _r.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
  };
  _r.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var o2 = [this], f = this, p3 = 0;p3 < r; p3 += e) {
      for (var m2 = 0;m2 < e; m2++)
        f = f.dbl();
      o2.push(f);
    }
    return { step: e, points: o2 };
  };
  _r.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r = [this], o2 = (1 << e) - 1, f = o2 === 1 ? null : this.dbl(), p3 = 1;p3 < o2; p3++)
      r[p3] = r[p3 - 1].add(f);
    return { wnd: e, points: r };
  };
  _r.prototype._getBeta = function() {
    return null;
  };
  _r.prototype.dblp = function(e) {
    for (var r = this, o2 = 0;o2 < e; o2++)
      r = r.dbl();
    return r;
  };
});
var b22 = T((Sk, v22) => {
  var yA = or(), lt3 = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
  function xr(t) {
    Bf.call(this, "short", t), this.a = new lt3(t.a, 16).toRed(this.red), this.b = new lt3(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Dl(xr, Bf);
  v22.exports = xr;
  xr.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r, o2;
      if (e.beta)
        r = new lt3(e.beta, 16).toRed(this.red);
      else {
        var f = this._getEndoRoots(this.p);
        r = f[0].cmp(f[1]) < 0 ? f[0] : f[1], r = r.toRed(this.red);
      }
      if (e.lambda)
        o2 = new lt3(e.lambda, 16);
      else {
        var p2 = this._getEndoRoots(this.n);
        this.g.mul(p2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o2 = p2[0] : (o2 = p2[1], wA(this.g.mul(o2).x.cmp(this.g.x.redMul(r)) === 0));
      }
      var m2;
      return e.basis ? m2 = e.basis.map(function(y2) {
        return { a: new lt3(y2.a, 16), b: new lt3(y2.b, 16) };
      }) : m2 = this._getEndoBasis(o2), { beta: r, lambda: o2, basis: m2 };
    }
  };
  xr.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : lt3.mont(e), o2 = new lt3(2).toRed(r).redInvm(), f = o2.redNeg(), p2 = new lt3(3).toRed(r).redNeg().redSqrt().redMul(o2), m2 = f.redAdd(p2).fromRed(), y2 = f.redSub(p2).fromRed();
    return [m2, y2];
  };
  xr.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o2 = e, f = this.n.clone(), p2 = new lt3(1), m2 = new lt3(0), y2 = new lt3(0), M2 = new lt3(1), x3, S, E3, B, q, L2, ge, _e = 0, N3, we;o2.cmpn(0) !== 0; ) {
      var ye = f.div(o2);
      N3 = f.sub(ye.mul(o2)), we = y2.sub(ye.mul(p2));
      var xe = M2.sub(ye.mul(m2));
      if (!E3 && N3.cmp(r) < 0)
        x3 = ge.neg(), S = p2, E3 = N3.neg(), B = we;
      else if (E3 && ++_e === 2)
        break;
      ge = N3, f = o2, o2 = N3, y2 = p2, p2 = we, M2 = m2, m2 = xe;
    }
    q = N3.neg(), L2 = we;
    var Re = E3.sqr().add(B.sqr()), Ee = q.sqr().add(L2.sqr());
    return Ee.cmp(Re) >= 0 && (q = x3, L2 = S), E3.negative && (E3 = E3.neg(), B = B.neg()), q.negative && (q = q.neg(), L2 = L2.neg()), [{ a: E3, b: B }, { a: q, b: L2 }];
  };
  xr.prototype._endoSplit = function(e) {
    var r = this.endo.basis, o2 = r[0], f = r[1], p2 = f.b.mul(e).divRound(this.n), m2 = o2.b.neg().mul(e).divRound(this.n), y2 = p2.mul(o2.a), M2 = m2.mul(f.a), x3 = p2.mul(o2.b), S = m2.mul(f.b), E3 = e.sub(y2).sub(M2), B = x3.add(S).neg();
    return { k1: E3, k2: B };
  };
  xr.prototype.pointFromX = function(e, r) {
    e = new lt3(e, 16), e.red || (e = e.toRed(this.red));
    var o2 = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f = o2.redSqrt();
    if (f.redSqr().redSub(o2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var p2 = f.fromRed().isOdd();
    return (r && !p2 || !r && p2) && (f = f.redNeg()), this.point(e, f);
  };
  xr.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var { x: r, y: o2 } = e, f = this.a.redMul(r), p2 = r.redSqr().redMul(r).redIAdd(f).redIAdd(this.b);
    return o2.redSqr().redISub(p2).cmpn(0) === 0;
  };
  xr.prototype._endoWnafMulAdd = function(e, r, o2) {
    for (var f = this._endoWnafT1, p2 = this._endoWnafT2, m2 = 0;m2 < e.length; m2++) {
      var y2 = this._endoSplit(r[m2]), M2 = e[m2], x3 = M2._getBeta();
      y2.k1.negative && (y2.k1.ineg(), M2 = M2.neg(true)), y2.k2.negative && (y2.k2.ineg(), x3 = x3.neg(true)), f[m2 * 2] = M2, f[m2 * 2 + 1] = x3, p2[m2 * 2] = y2.k1, p2[m2 * 2 + 1] = y2.k2;
    }
    for (var S = this._wnafMulAdd(1, f, p2, m2 * 2, o2), E3 = 0;E3 < m2 * 2; E3++)
      f[E3] = null, p2[E3] = null;
    return S;
  };
  function Ct(t, e, r, o2) {
    Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt3(e, 16), this.y = new lt3(r, 16), o2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  Dl(Ct, Bf.BasePoint);
  xr.prototype.point = function(e, r, o2) {
    return new Ct(this, e, r, o2);
  };
  xr.prototype.pointFromJSON = function(e, r) {
    return Ct.fromJSON(this, e, r);
  };
  Ct.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var o2 = this.curve, f = function(p2) {
          return o2.point(p2.x.redMul(o2.endo.beta), p2.y);
        };
        e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f) } };
      }
      return r;
    }
  };
  Ct.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  Ct.fromJSON = function(e, r, o2) {
    typeof r == "string" && (r = JSON.parse(r));
    var f = e.point(r[0], r[1], o2);
    if (!r[2])
      return f;
    function p2(y2) {
      return e.point(y2[0], y2[1], o2);
    }
    var m2 = r[2];
    return f.precomputed = { beta: null, doubles: m2.doubles && { step: m2.doubles.step, points: [f].concat(m2.doubles.points.map(p2)) }, naf: m2.naf && { wnd: m2.naf.wnd, points: [f].concat(m2.naf.points.map(p2)) } }, f;
  };
  Ct.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Ct.prototype.isInfinity = function() {
    return this.inf;
  };
  Ct.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var o2 = r.redSqr().redISub(this.x).redISub(e.x), f = r.redMul(this.x.redSub(o2)).redISub(this.y);
    return this.curve.point(o2, f);
  };
  Ct.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r = this.curve.a, o2 = this.x.redSqr(), f = e.redInvm(), p2 = o2.redAdd(o2).redIAdd(o2).redIAdd(r).redMul(f), m2 = p2.redSqr().redISub(this.x.redAdd(this.x)), y2 = p2.redMul(this.x.redSub(m2)).redISub(this.y);
    return this.curve.point(m2, y2);
  };
  Ct.prototype.getX = function() {
    return this.x.fromRed();
  };
  Ct.prototype.getY = function() {
    return this.y.fromRed();
  };
  Ct.prototype.mul = function(e) {
    return e = new lt3(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  Ct.prototype.mulAdd = function(e, r, o2) {
    var f = [this, r], p2 = [e, o2];
    return this.curve.endo ? this.curve._endoWnafMulAdd(f, p2) : this.curve._wnafMulAdd(1, f, p2, 2);
  };
  Ct.prototype.jmulAdd = function(e, r, o2) {
    var f = [this, r], p2 = [e, o2];
    return this.curve.endo ? this.curve._endoWnafMulAdd(f, p2, true) : this.curve._wnafMulAdd(1, f, p2, 2, true);
  };
  Ct.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  Ct.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var o2 = this.precomputed, f = function(p2) {
        return p2.neg();
      };
      r.precomputed = { naf: o2.naf && { wnd: o2.naf.wnd, points: o2.naf.points.map(f) }, doubles: o2.doubles && { step: o2.doubles.step, points: o2.doubles.points.map(f) } };
    }
    return r;
  };
  Ct.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function Wt(t, e, r, o2) {
    Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt3(0)) : (this.x = new lt3(e, 16), this.y = new lt3(r, 16), this.z = new lt3(o2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  Dl(Wt, Bf.BasePoint);
  xr.prototype.jpoint = function(e, r, o2) {
    return new Wt(this, e, r, o2);
  };
  Wt.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), o2 = this.x.redMul(r), f = this.y.redMul(r).redMul(e);
    return this.curve.point(o2, f);
  };
  Wt.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  Wt.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r = e.z.redSqr(), o2 = this.z.redSqr(), f = this.x.redMul(r), p2 = e.x.redMul(o2), m2 = this.y.redMul(r.redMul(e.z)), y2 = e.y.redMul(o2.redMul(this.z)), M2 = f.redSub(p2), x3 = m2.redSub(y2);
    if (M2.cmpn(0) === 0)
      return x3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var S = M2.redSqr(), E3 = S.redMul(M2), B = f.redMul(S), q = x3.redSqr().redIAdd(E3).redISub(B).redISub(B), L2 = x3.redMul(B.redISub(q)).redISub(m2.redMul(E3)), ge = this.z.redMul(e.z).redMul(M2);
    return this.curve.jpoint(q, L2, ge);
  };
  Wt.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r = this.z.redSqr(), o2 = this.x, f = e.x.redMul(r), p2 = this.y, m2 = e.y.redMul(r).redMul(this.z), y2 = o2.redSub(f), M2 = p2.redSub(m2);
    if (y2.cmpn(0) === 0)
      return M2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var x3 = y2.redSqr(), S = x3.redMul(y2), E3 = o2.redMul(x3), B = M2.redSqr().redIAdd(S).redISub(E3).redISub(E3), q = M2.redMul(E3.redISub(B)).redISub(p2.redMul(S)), L2 = this.z.redMul(y2);
    return this.curve.jpoint(B, q, L2);
  };
  Wt.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
      var o2 = this;
      for (r = 0;r < e; r++)
        o2 = o2.dbl();
      return o2;
    }
    var f = this.curve.a, p2 = this.curve.tinv, m2 = this.x, y2 = this.y, M2 = this.z, x3 = M2.redSqr().redSqr(), S = y2.redAdd(y2);
    for (r = 0;r < e; r++) {
      var E3 = m2.redSqr(), B = S.redSqr(), q = B.redSqr(), L2 = E3.redAdd(E3).redIAdd(E3).redIAdd(f.redMul(x3)), ge = m2.redMul(B), _e = L2.redSqr().redISub(ge.redAdd(ge)), N3 = ge.redISub(_e), we = L2.redMul(N3);
      we = we.redIAdd(we).redISub(q);
      var ye = S.redMul(M2);
      r + 1 < e && (x3 = x3.redMul(q)), m2 = _e, M2 = ye, S = we;
    }
    return this.curve.jpoint(m2, S.redMul(p2), M2);
  };
  Wt.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  Wt.prototype._zeroDbl = function() {
    var e, r, o2;
    if (this.zOne) {
      var f = this.x.redSqr(), p2 = this.y.redSqr(), m2 = p2.redSqr(), y2 = this.x.redAdd(p2).redSqr().redISub(f).redISub(m2);
      y2 = y2.redIAdd(y2);
      var M2 = f.redAdd(f).redIAdd(f), x3 = M2.redSqr().redISub(y2).redISub(y2), S = m2.redIAdd(m2);
      S = S.redIAdd(S), S = S.redIAdd(S), e = x3, r = M2.redMul(y2.redISub(x3)).redISub(S), o2 = this.y.redAdd(this.y);
    } else {
      var E3 = this.x.redSqr(), B = this.y.redSqr(), q = B.redSqr(), L2 = this.x.redAdd(B).redSqr().redISub(E3).redISub(q);
      L2 = L2.redIAdd(L2);
      var ge = E3.redAdd(E3).redIAdd(E3), _e = ge.redSqr(), N3 = q.redIAdd(q);
      N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), e = _e.redISub(L2).redISub(L2), r = ge.redMul(L2.redISub(e)).redISub(N3), o2 = this.y.redMul(this.z), o2 = o2.redIAdd(o2);
    }
    return this.curve.jpoint(e, r, o2);
  };
  Wt.prototype._threeDbl = function() {
    var e, r, o2;
    if (this.zOne) {
      var f = this.x.redSqr(), p2 = this.y.redSqr(), m2 = p2.redSqr(), y2 = this.x.redAdd(p2).redSqr().redISub(f).redISub(m2);
      y2 = y2.redIAdd(y2);
      var M2 = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), x3 = M2.redSqr().redISub(y2).redISub(y2);
      e = x3;
      var S = m2.redIAdd(m2);
      S = S.redIAdd(S), S = S.redIAdd(S), r = M2.redMul(y2.redISub(x3)).redISub(S), o2 = this.y.redAdd(this.y);
    } else {
      var E3 = this.z.redSqr(), B = this.y.redSqr(), q = this.x.redMul(B), L2 = this.x.redSub(E3).redMul(this.x.redAdd(E3));
      L2 = L2.redAdd(L2).redIAdd(L2);
      var ge = q.redIAdd(q);
      ge = ge.redIAdd(ge);
      var _e = ge.redAdd(ge);
      e = L2.redSqr().redISub(_e), o2 = this.y.redAdd(this.z).redSqr().redISub(B).redISub(E3);
      var N3 = B.redSqr();
      N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), r = L2.redMul(ge.redISub(e)).redISub(N3);
    }
    return this.curve.jpoint(e, r, o2);
  };
  Wt.prototype._dbl = function() {
    var e = this.curve.a, r = this.x, o2 = this.y, f = this.z, p2 = f.redSqr().redSqr(), m2 = r.redSqr(), y2 = o2.redSqr(), M2 = m2.redAdd(m2).redIAdd(m2).redIAdd(e.redMul(p2)), x3 = r.redAdd(r);
    x3 = x3.redIAdd(x3);
    var S = x3.redMul(y2), E3 = M2.redSqr().redISub(S.redAdd(S)), B = S.redISub(E3), q = y2.redSqr();
    q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
    var L2 = M2.redMul(B).redISub(q), ge = o2.redAdd(o2).redMul(f);
    return this.curve.jpoint(E3, L2, ge);
  };
  Wt.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr(), f = r.redSqr(), p2 = e.redAdd(e).redIAdd(e), m2 = p2.redSqr(), y2 = this.x.redAdd(r).redSqr().redISub(e).redISub(f);
    y2 = y2.redIAdd(y2), y2 = y2.redAdd(y2).redIAdd(y2), y2 = y2.redISub(m2);
    var M2 = y2.redSqr(), x3 = f.redIAdd(f);
    x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3);
    var S = p2.redIAdd(y2).redSqr().redISub(m2).redISub(M2).redISub(x3), E3 = r.redMul(S);
    E3 = E3.redIAdd(E3), E3 = E3.redIAdd(E3);
    var B = this.x.redMul(M2).redISub(E3);
    B = B.redIAdd(B), B = B.redIAdd(B);
    var q = this.y.redMul(S.redMul(x3.redISub(S)).redISub(y2.redMul(M2)));
    q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
    var L2 = this.z.redAdd(y2).redSqr().redISub(o2).redISub(M2);
    return this.curve.jpoint(B, q, L2);
  };
  Wt.prototype.mul = function(e, r) {
    return e = new lt3(e, r), this.curve._wnafMul(this, e);
  };
  Wt.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r = this.z.redSqr(), o2 = e.z.redSqr();
    if (this.x.redMul(o2).redISub(e.x.redMul(r)).cmpn(0) !== 0)
      return false;
    var f = r.redMul(this.z), p2 = o2.redMul(e.z);
    return this.y.redMul(p2).redISub(e.y.redMul(f)).cmpn(0) === 0;
  };
  Wt.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(), o2 = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(o2) === 0)
      return true;
    for (var f = e.clone(), p2 = this.curve.redN.redMul(r);; ) {
      if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
        return false;
      if (o2.redIAdd(p2), this.x.cmp(o2) === 0)
        return true;
    }
  };
  Wt.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  Wt.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var y2 = T((Ek, g2) => {
  var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
  function If(t) {
    Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  m2(If, Gs);
  g2.exports = If;
  If.prototype.validate = function(e) {
    var r = e.normalize().x, o2 = r.redSqr(), f = o2.redMul(r).redAdd(o2.redMul(this.a)).redAdd(r), p2 = f.redSqrt();
    return p2.redSqr().cmp(f) === 0;
  };
  function Ot(t, e, r) {
    Gs.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  m2(Ot, Gs.BasePoint);
  If.prototype.decodePoint = function(e, r) {
    return this.point(MA.toArray(e, r), 1);
  };
  If.prototype.point = function(e, r) {
    return new Ot(this, e, r);
  };
  If.prototype.pointFromJSON = function(e) {
    return Ot.fromJSON(this, e);
  };
  Ot.prototype.precompute = function() {
  };
  Ot.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Ot.fromJSON = function(e, r) {
    return new Ot(e, r[0], r[1] || e.one);
  };
  Ot.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Ot.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  Ot.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r = e.redSqr(), o2 = this.x.redSub(this.z), f = o2.redSqr(), p2 = r.redSub(f), m3 = r.redMul(f), y3 = p2.redMul(f.redAdd(this.curve.a24.redMul(p2)));
    return this.curve.point(m3, y3);
  };
  Ot.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ot.prototype.diffAdd = function(e, r) {
    var o2 = this.x.redAdd(this.z), f = this.x.redSub(this.z), p2 = e.x.redAdd(e.z), m3 = e.x.redSub(e.z), y3 = m3.redMul(o2), M2 = p2.redMul(f), x3 = r.z.redMul(y3.redAdd(M2).redSqr()), S = r.x.redMul(y3.redISub(M2).redSqr());
    return this.curve.point(x3, S);
  };
  Ot.prototype.mul = function(e) {
    for (var r = e.clone(), o2 = this, f = this.curve.point(null, null), p2 = this, m3 = [];r.cmpn(0) !== 0; r.iushrn(1))
      m3.push(r.andln(1));
    for (var y3 = m3.length - 1;y3 >= 0; y3--)
      m3[y3] === 0 ? (o2 = o2.diffAdd(f, p2), f = f.dbl()) : (f = o2.diffAdd(f, p2), o2 = o2.dbl());
    return f;
  };
  Ot.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ot.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ot.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  Ot.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  Ot.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var _2 = T((Ak, M2) => {
  var _A = or(), Ai = ri(), w22 = Ie(), Ys = Oa(), xA = _A.assert;
  function ii(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  w22(ii, Ys);
  M2.exports = ii;
  ii.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  ii.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  ii.prototype.jpoint = function(e, r, o2, f) {
    return this.point(e, r, o2, f);
  };
  ii.prototype.pointFromX = function(e, r) {
    e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
    var o2 = e.redSqr(), f = this.c2.redSub(this.a.redMul(o2)), p2 = this.one.redSub(this.c2.redMul(this.d).redMul(o2)), m2 = f.redMul(p2.redInvm()), y3 = m2.redSqrt();
    if (y3.redSqr().redSub(m2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var M3 = y3.fromRed().isOdd();
    return (r && !M3 || !r && M3) && (y3 = y3.redNeg()), this.point(e, y3);
  };
  ii.prototype.pointFromY = function(e, r) {
    e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
    var o2 = e.redSqr(), f = o2.redSub(this.c2), p2 = o2.redMul(this.d).redMul(this.c2).redSub(this.a), m2 = f.redMul(p2.redInvm());
    if (m2.cmp(this.zero) === 0) {
      if (r)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var y3 = m2.redSqrt();
    if (y3.redSqr().redSub(m2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return y3.fromRed().isOdd() !== r && (y3 = y3.redNeg()), this.point(y3, e);
  };
  ii.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r = e.x.redSqr(), o2 = e.y.redSqr(), f = r.redMul(this.a).redAdd(o2), p2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o2)));
    return f.cmp(p2) === 0;
  };
  function at2(t, e, r, o2, f) {
    Ys.BasePoint.call(this, t, "projective"), e === null && r === null && o2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e, 16), this.y = new Ai(r, 16), this.z = o2 ? new Ai(o2, 16) : this.curve.one, this.t = f && new Ai(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  w22(at2, Ys.BasePoint);
  ii.prototype.pointFromJSON = function(e) {
    return at2.fromJSON(this, e);
  };
  ii.prototype.point = function(e, r, o2, f) {
    return new at2(this, e, r, o2, f);
  };
  at2.fromJSON = function(e, r) {
    return new at2(e, r[0], r[1], r[2]);
  };
  at2.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  at2.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  at2.prototype._extDbl = function() {
    var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr();
    o2 = o2.redIAdd(o2);
    var f = this.curve._mulA(e), p2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m2 = f.redAdd(r), y3 = m2.redSub(o2), M3 = f.redSub(r), x3 = p2.redMul(y3), S = m2.redMul(M3), E3 = p2.redMul(M3), B = y3.redMul(m2);
    return this.curve.point(x3, S, B, E3);
  };
  at2.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o2 = this.y.redSqr(), f, p2, m2, y3, M3, x3;
    if (this.curve.twisted) {
      y3 = this.curve._mulA(r);
      var S = y3.redAdd(o2);
      this.zOne ? (f = e.redSub(r).redSub(o2).redMul(S.redSub(this.curve.two)), p2 = S.redMul(y3.redSub(o2)), m2 = S.redSqr().redSub(S).redSub(S)) : (M3 = this.z.redSqr(), x3 = S.redSub(M3).redISub(M3), f = e.redSub(r).redISub(o2).redMul(x3), p2 = S.redMul(y3.redSub(o2)), m2 = S.redMul(x3));
    } else
      y3 = r.redAdd(o2), M3 = this.curve._mulC(this.z).redSqr(), x3 = y3.redSub(M3).redSub(M3), f = this.curve._mulC(e.redISub(y3)).redMul(x3), p2 = this.curve._mulC(y3).redMul(r.redISub(o2)), m2 = y3.redMul(x3);
    return this.curve.point(f, p2, m2);
  };
  at2.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  at2.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o2 = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f = this.t.redMul(this.curve.dd).redMul(e.t), p2 = this.z.redMul(e.z.redAdd(e.z)), m2 = o2.redSub(r), y3 = p2.redSub(f), M3 = p2.redAdd(f), x3 = o2.redAdd(r), S = m2.redMul(y3), E3 = M3.redMul(x3), B = m2.redMul(x3), q = y3.redMul(M3);
    return this.curve.point(S, E3, q, B);
  };
  at2.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z), o2 = r.redSqr(), f = this.x.redMul(e.x), p2 = this.y.redMul(e.y), m2 = this.curve.d.redMul(f).redMul(p2), y3 = o2.redSub(m2), M3 = o2.redAdd(m2), x3 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(p2), S = r.redMul(y3).redMul(x3), E3, B;
    return this.curve.twisted ? (E3 = r.redMul(M3).redMul(p2.redSub(this.curve._mulA(f))), B = y3.redMul(M3)) : (E3 = r.redMul(M3).redMul(p2.redSub(f)), B = this.curve._mulC(y3).redMul(M3)), this.curve.point(S, E3, B);
  };
  at2.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  at2.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  at2.prototype.mulAdd = function(e, r, o2) {
    return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, false);
  };
  at2.prototype.jmulAdd = function(e, r, o2) {
    return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, true);
  };
  at2.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  at2.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  at2.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  at2.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  at2.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  at2.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0)
      return true;
    for (var o2 = e.clone(), f = this.curve.redN.redMul(this.z);; ) {
      if (o2.iadd(this.curve.n), o2.cmp(this.curve.p) >= 0)
        return false;
      if (r.redIAdd(f), this.x.cmp(r) === 0)
        return true;
    }
  };
  at2.prototype.toP = at2.prototype.normalize;
  at2.prototype.mixedAdd = at2.prototype.add;
});
var Pl = T((x22) => {
  var Xs = x22;
  Xs.base = Oa();
  Xs.short = b22();
  Xs.mont = y2();
  Xs.edwards = _2();
});
var Cr = T((it) => {
  var SA = ar(), EA = Ie();
  it.inherits = EA;
  function AA(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function RA(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f = 0;f < t.length; f += 2)
            r.push(parseInt(t[f] + t[f + 1], 16));
      } else
        for (var o2 = 0, f = 0;f < t.length; f++) {
          var p2 = t.charCodeAt(f);
          p2 < 128 ? r[o2++] = p2 : p2 < 2048 ? (r[o2++] = p2 >> 6 | 192, r[o2++] = p2 & 63 | 128) : AA(t, f) ? (p2 = 65536 + ((p2 & 1023) << 10) + (t.charCodeAt(++f) & 1023), r[o2++] = p2 >> 18 | 240, r[o2++] = p2 >> 12 & 63 | 128, r[o2++] = p2 >> 6 & 63 | 128, r[o2++] = p2 & 63 | 128) : (r[o2++] = p2 >> 12 | 224, r[o2++] = p2 >> 6 & 63 | 128, r[o2++] = p2 & 63 | 128);
        }
    else
      for (f = 0;f < t.length; f++)
        r[f] = t[f] | 0;
    return r;
  }
  it.toArray = RA;
  function BA(t) {
    for (var e = "", r = 0;r < t.length; r++)
      e += E22(t[r].toString(16));
    return e;
  }
  it.toHex = BA;
  function S2(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  it.htonl = S2;
  function qA(t, e) {
    for (var r = "", o2 = 0;o2 < t.length; o2++) {
      var f = t[o2];
      e === "little" && (f = S2(f)), r += A2(f.toString(16));
    }
    return r;
  }
  it.toHex32 = qA;
  function E22(t) {
    return t.length === 1 ? "0" + t : t;
  }
  it.zero2 = E22;
  function A2(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  it.zero8 = A2;
  function IA(t, e, r, o2) {
    var f = r - e;
    SA(f % 4 === 0);
    for (var p2 = new Array(f / 4), m2 = 0, y3 = e;m2 < p2.length; m2++, y3 += 4) {
      var M2;
      o2 === "big" ? M2 = t[y3] << 24 | t[y3 + 1] << 16 | t[y3 + 2] << 8 | t[y3 + 3] : M2 = t[y3 + 3] << 24 | t[y3 + 2] << 16 | t[y3 + 1] << 8 | t[y3], p2[m2] = M2 >>> 0;
    }
    return p2;
  }
  it.join32 = IA;
  function TA(t, e) {
    for (var r = new Array(t.length * 4), o2 = 0, f = 0;o2 < t.length; o2++, f += 4) {
      var p2 = t[o2];
      e === "big" ? (r[f] = p2 >>> 24, r[f + 1] = p2 >>> 16 & 255, r[f + 2] = p2 >>> 8 & 255, r[f + 3] = p2 & 255) : (r[f + 3] = p2 >>> 24, r[f + 2] = p2 >>> 16 & 255, r[f + 1] = p2 >>> 8 & 255, r[f] = p2 & 255);
    }
    return r;
  }
  it.split32 = TA;
  function kA(t, e) {
    return t >>> e | t << 32 - e;
  }
  it.rotr32 = kA;
  function LA(t, e) {
    return t << e | t >>> 32 - e;
  }
  it.rotl32 = LA;
  function NA(t, e) {
    return t + e >>> 0;
  }
  it.sum32 = NA;
  function DA(t, e, r) {
    return t + e + r >>> 0;
  }
  it.sum32_3 = DA;
  function PA(t, e, r, o2) {
    return t + e + r + o2 >>> 0;
  }
  it.sum32_4 = PA;
  function CA(t, e, r, o2, f) {
    return t + e + r + o2 + f >>> 0;
  }
  it.sum32_5 = CA;
  function OA(t, e, r, o2) {
    var f = t[e], p2 = t[e + 1], m2 = o2 + p2 >>> 0, y3 = (m2 < o2 ? 1 : 0) + r + f;
    t[e] = y3 >>> 0, t[e + 1] = m2;
  }
  it.sum64 = OA;
  function FA(t, e, r, o2) {
    var f = e + o2 >>> 0, p2 = (f < e ? 1 : 0) + t + r;
    return p2 >>> 0;
  }
  it.sum64_hi = FA;
  function UA(t, e, r, o2) {
    var f = e + o2;
    return f >>> 0;
  }
  it.sum64_lo = UA;
  function zA(t, e, r, o2, f, p2, m2, y3) {
    var M2 = 0, x3 = e;
    x3 = x3 + o2 >>> 0, M2 += x3 < e ? 1 : 0, x3 = x3 + p2 >>> 0, M2 += x3 < p2 ? 1 : 0, x3 = x3 + y3 >>> 0, M2 += x3 < y3 ? 1 : 0;
    var S = t + r + f + m2 + M2;
    return S >>> 0;
  }
  it.sum64_4_hi = zA;
  function HA(t, e, r, o2, f, p2, m2, y3) {
    var M2 = e + o2 + p2 + y3;
    return M2 >>> 0;
  }
  it.sum64_4_lo = HA;
  function WA(t, e, r, o2, f, p2, m2, y3, M2, x3) {
    var S = 0, E3 = e;
    E3 = E3 + o2 >>> 0, S += E3 < e ? 1 : 0, E3 = E3 + p2 >>> 0, S += E3 < p2 ? 1 : 0, E3 = E3 + y3 >>> 0, S += E3 < y3 ? 1 : 0, E3 = E3 + x3 >>> 0, S += E3 < x3 ? 1 : 0;
    var B = t + r + f + m2 + M2 + S;
    return B >>> 0;
  }
  it.sum64_5_hi = WA;
  function KA(t, e, r, o2, f, p2, m2, y3, M2, x3) {
    var S = e + o2 + p2 + y3 + x3;
    return S >>> 0;
  }
  it.sum64_5_lo = KA;
  function jA(t, e, r) {
    var o2 = e << 32 - r | t >>> r;
    return o2 >>> 0;
  }
  it.rotr64_hi = jA;
  function ZA(t, e, r) {
    var o2 = t << 32 - r | e >>> r;
    return o2 >>> 0;
  }
  it.rotr64_lo = ZA;
  function VA(t, e, r) {
    return t >>> r;
  }
  it.shr64_hi = VA;
  function $A(t, e, r) {
    var o2 = t << 32 - r | e >>> r;
    return o2 >>> 0;
  }
  it.shr64_lo = $A;
});
var Tf = T((B2) => {
  var R22 = Cr(), GA = ar();
  function Js() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  B2.BlockHash = Js;
  Js.prototype.update = function(e, r) {
    if (e = R22.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var o2 = e.length % this._delta8;
      this.pending = e.slice(e.length - o2, e.length), this.pending.length === 0 && (this.pending = null), e = R22.join32(e, 0, e.length - o2, this.endian);
      for (var f = 0;f < e.length; f += this._delta32)
        this._update(e, f, f + this._delta32);
    }
    return this;
  };
  Js.prototype.digest = function(e) {
    return this.update(this._pad()), GA(this.pending === null), this._digest(e);
  };
  Js.prototype._pad = function() {
    var e = this.pendingTotal, r = this._delta8, o2 = r - (e + this.padLength) % r, f = new Array(o2 + this.padLength);
    f[0] = 128;
    for (var p2 = 1;p2 < o2; p2++)
      f[p2] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var m2 = 8;m2 < this.padLength; m2++)
        f[p2++] = 0;
      f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = e >>> 24 & 255, f[p2++] = e >>> 16 & 255, f[p2++] = e >>> 8 & 255, f[p2++] = e & 255;
    } else
      for (f[p2++] = e & 255, f[p2++] = e >>> 8 & 255, f[p2++] = e >>> 16 & 255, f[p2++] = e >>> 24 & 255, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, m2 = 8;m2 < this.padLength; m2++)
        f[p2++] = 0;
    return f;
  };
});
var Cl = T((Ri) => {
  var YA = Cr(), ni = YA.rotr32;
  function XA(t, e, r, o2) {
    if (t === 0)
      return q2(e, r, o2);
    if (t === 1 || t === 3)
      return T2(e, r, o2);
    if (t === 2)
      return I2(e, r, o2);
  }
  Ri.ft_1 = XA;
  function q2(t, e, r) {
    return t & e ^ ~t & r;
  }
  Ri.ch32 = q2;
  function I2(t, e, r) {
    return t & e ^ t & r ^ e & r;
  }
  Ri.maj32 = I2;
  function T2(t, e, r) {
    return t ^ e ^ r;
  }
  Ri.p32 = T2;
  function JA(t) {
    return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
  }
  Ri.s0_256 = JA;
  function QA(t) {
    return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
  }
  Ri.s1_256 = QA;
  function eR(t) {
    return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
  }
  Ri.g0_256 = eR;
  function tR(t) {
    return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
  }
  Ri.g1_256 = tR;
});
var N22 = T((Tk, L2) => {
  var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k2 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
  function fi() {
    if (!(this instanceof fi))
      return new fi;
    k2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  kf.inherits(fi, k2);
  L2.exports = fi;
  fi.blockSize = 512;
  fi.outSize = 160;
  fi.hmacStrength = 80;
  fi.padLength = 64;
  fi.prototype._update = function(e, r) {
    for (var o2 = this.W, f = 0;f < 16; f++)
      o2[f] = e[r + f];
    for (;f < o2.length; f++)
      o2[f] = Ol(o2[f - 3] ^ o2[f - 8] ^ o2[f - 14] ^ o2[f - 16], 1);
    var p2 = this.h[0], m2 = this.h[1], y3 = this.h[2], M2 = this.h[3], x3 = this.h[4];
    for (f = 0;f < o2.length; f++) {
      var S = ~~(f / 20), E3 = nR(Ol(p2, 5), fR(S, m2, y3, M2), x3, o2[f], aR[S]);
      x3 = M2, M2 = y3, y3 = Ol(m2, 30), m2 = p2, p2 = E3;
    }
    this.h[0] = Fa(this.h[0], p2), this.h[1] = Fa(this.h[1], m2), this.h[2] = Fa(this.h[2], y3), this.h[3] = Fa(this.h[3], M2), this.h[4] = Fa(this.h[4], x3);
  };
  fi.prototype._digest = function(e) {
    return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
  };
});
var Fl = T((kk, P22) => {
  var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function ai() {
    if (!(this instanceof ai))
      return new ai;
    D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
  }
  Lf.inherits(ai, D2);
  P22.exports = ai;
  ai.blockSize = 512;
  ai.outSize = 256;
  ai.hmacStrength = 192;
  ai.padLength = 64;
  ai.prototype._update = function(e, r) {
    for (var o2 = this.W, f = 0;f < 16; f++)
      o2[f] = e[r + f];
    for (;f < o2.length; f++)
      o2[f] = hR(bR(o2[f - 2]), o2[f - 7], vR(o2[f - 15]), o2[f - 16]);
    var p2 = this.h[0], m2 = this.h[1], y3 = this.h[2], M2 = this.h[3], x3 = this.h[4], S = this.h[5], E3 = this.h[6], B = this.h[7];
    for (sR(this.k.length === o2.length), f = 0;f < o2.length; f++) {
      var q = uR(B, pR(x3), lR(x3, S, E3), this.k[f], o2[f]), L2 = Or(cR(p2), dR(p2, m2, y3));
      B = E3, E3 = S, S = x3, x3 = Or(M2, q), M2 = y3, y3 = m2, m2 = p2, p2 = Or(q, L2);
    }
    this.h[0] = Or(this.h[0], p2), this.h[1] = Or(this.h[1], m2), this.h[2] = Or(this.h[2], y3), this.h[3] = Or(this.h[3], M2), this.h[4] = Or(this.h[4], x3), this.h[5] = Or(this.h[5], S), this.h[6] = Or(this.h[6], E3), this.h[7] = Or(this.h[7], B);
  };
  ai.prototype._digest = function(e) {
    return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
  };
});
var F2 = T((Lk, O2) => {
  var Ul = Cr(), C2 = Fl();
  function Bi() {
    if (!(this instanceof Bi))
      return new Bi;
    C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  Ul.inherits(Bi, C2);
  O2.exports = Bi;
  Bi.blockSize = 512;
  Bi.outSize = 224;
  Bi.hmacStrength = 192;
  Bi.padLength = 64;
  Bi.prototype._digest = function(e) {
    return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
  };
});
var Wl = T((Nk, W2) => {
  var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U2 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function Fr3() {
    if (!(this instanceof Fr3))
      return new Fr3;
    H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
  }
  ir.inherits(Fr3, H2);
  W2.exports = Fr3;
  Fr3.blockSize = 1024;
  Fr3.outSize = 512;
  Fr3.hmacStrength = 192;
  Fr3.padLength = 128;
  Fr3.prototype._prepareBlock = function(e, r) {
    for (var o2 = this.W, f = 0;f < 32; f++)
      o2[f] = e[r + f];
    for (;f < o2.length; f += 2) {
      var p2 = DR(o2[f - 4], o2[f - 3]), m2 = PR(o2[f - 4], o2[f - 3]), y3 = o2[f - 14], M2 = o2[f - 13], x3 = LR(o2[f - 30], o2[f - 29]), S = NR(o2[f - 30], o2[f - 29]), E3 = o2[f - 32], B = o2[f - 31];
      o2[f] = wR(p2, m2, y3, M2, x3, S, E3, B), o2[f + 1] = MR(p2, m2, y3, M2, x3, S, E3, B);
    }
  };
  Fr3.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var o2 = this.W, f = this.h[0], p2 = this.h[1], m2 = this.h[2], y3 = this.h[3], M2 = this.h[4], x3 = this.h[5], S = this.h[6], E3 = this.h[7], B = this.h[8], q = this.h[9], L2 = this.h[10], ge = this.h[11], _e = this.h[12], N3 = this.h[13], we = this.h[14], ye = this.h[15];
    yR(this.k.length === o2.length);
    for (var xe = 0;xe < o2.length; xe += 2) {
      var Re = we, Ee = ye, Ae2 = TR(B, q), P3 = kR(B, q), Se2 = ER(B, q, L2, ge, _e, N3), v3 = AR(B, q, L2, ge, _e, N3), i = this.k[xe], a2 = this.k[xe + 1], h2 = o2[xe], s = o2[xe + 1], u = _R(Re, Ee, Ae2, P3, Se2, v3, i, a2, h2, s), c = xR(Re, Ee, Ae2, P3, Se2, v3, i, a2, h2, s);
      Re = qR(f, p2), Ee = IR(f, p2), Ae2 = RR(f, p2, m2, y3, M2, x3), P3 = BR(f, p2, m2, y3, M2, x3);
      var b3 = zl(Re, Ee, Ae2, P3), l2 = Hl(Re, Ee, Ae2, P3);
      we = _e, ye = N3, _e = L2, N3 = ge, L2 = B, ge = q, B = zl(S, E3, u, c), q = Hl(E3, E3, u, c), S = M2, E3 = x3, M2 = m2, x3 = y3, m2 = f, y3 = p2, f = zl(u, c, b3, l2), p2 = Hl(u, c, b3, l2);
    }
    Ji(this.h, 0, f, p2), Ji(this.h, 2, m2, y3), Ji(this.h, 4, M2, x3), Ji(this.h, 6, S, E3), Ji(this.h, 8, B, q), Ji(this.h, 10, L2, ge), Ji(this.h, 12, _e, N3), Ji(this.h, 14, we, ye);
  };
  Fr3.prototype._digest = function(e) {
    return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
  };
  function ER(t, e, r, o2, f) {
    var p2 = t & r ^ ~t & f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function AR(t, e, r, o2, f, p2) {
    var m2 = e & o2 ^ ~e & p2;
    return m2 < 0 && (m2 += 4294967296), m2;
  }
  function RR(t, e, r, o2, f) {
    var p2 = t & r ^ t & f ^ r & f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function BR(t, e, r, o2, f, p2) {
    var m2 = e & o2 ^ e & p2 ^ o2 & p2;
    return m2 < 0 && (m2 += 4294967296), m2;
  }
  function qR(t, e) {
    var r = oi(t, e, 28), o2 = oi(e, t, 2), f = oi(e, t, 7), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function IR(t, e) {
    var r = si(t, e, 28), o2 = si(e, t, 2), f = si(e, t, 7), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function TR(t, e) {
    var r = oi(t, e, 14), o2 = oi(t, e, 18), f = oi(e, t, 9), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function kR(t, e) {
    var r = si(t, e, 14), o2 = si(t, e, 18), f = si(e, t, 9), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function LR(t, e) {
    var r = oi(t, e, 1), o2 = oi(t, e, 8), f = U2(t, e, 7), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function NR(t, e) {
    var r = si(t, e, 1), o2 = si(t, e, 8), f = z2(t, e, 7), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function DR(t, e) {
    var r = oi(t, e, 19), o2 = oi(e, t, 29), f = U2(t, e, 6), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
  function PR(t, e) {
    var r = si(t, e, 19), o2 = si(e, t, 29), f = z2(t, e, 6), p2 = r ^ o2 ^ f;
    return p2 < 0 && (p2 += 4294967296), p2;
  }
});
var Z2 = T((Dk, j2) => {
  var Kl = Cr(), K2 = Wl();
  function qi() {
    if (!(this instanceof qi))
      return new qi;
    K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  Kl.inherits(qi, K2);
  j2.exports = qi;
  qi.blockSize = 1024;
  qi.outSize = 384;
  qi.hmacStrength = 192;
  qi.padLength = 128;
  qi.prototype._digest = function(e) {
    return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
  };
});
var V2 = T((Df) => {
  Df.sha1 = N22();
  Df.sha224 = F2();
  Df.sha256 = Fl();
  Df.sha384 = Z2();
  Df.sha512 = Wl();
});
var Q2 = T((J2) => {
  var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X2 = CR.BlockHash;
  function hi() {
    if (!(this instanceof hi))
      return new hi;
    X2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  On.inherits(hi, X2);
  J2.ripemd160 = hi;
  hi.blockSize = 512;
  hi.outSize = 160;
  hi.hmacStrength = 192;
  hi.padLength = 64;
  hi.prototype._update = function(e, r) {
    for (var o2 = this.h[0], f = this.h[1], p2 = this.h[2], m2 = this.h[3], y3 = this.h[4], M2 = o2, x3 = f, S = p2, E3 = m2, B = y3, q = 0;q < 80; q++) {
      var L2 = $2(Qs(G2(o2, Y2(q, f, p2, m2), e[UR[q] + r], OR(q)), HR[q]), y3);
      o2 = y3, y3 = m2, m2 = Qs(p2, 10), p2 = f, f = L2, L2 = $2(Qs(G2(M2, Y2(79 - q, x3, S, E3), e[zR[q] + r], FR(q)), WR[q]), B), M2 = B, B = E3, E3 = Qs(S, 10), S = x3, x3 = L2;
    }
    L2 = Ua(this.h[1], p2, E3), this.h[1] = Ua(this.h[2], m2, B), this.h[2] = Ua(this.h[3], y3, M2), this.h[3] = Ua(this.h[4], o2, x3), this.h[4] = Ua(this.h[0], f, S), this.h[0] = L2;
  };
  hi.prototype._digest = function(e) {
    return e === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
  };
  function Y2(t, e, r, o2) {
    return t <= 15 ? e ^ r ^ o2 : t <= 31 ? e & r | ~e & o2 : t <= 47 ? (e | ~r) ^ o2 : t <= 63 ? e & o2 | r & ~o2 : e ^ (r | ~o2);
  }
  function OR(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function FR(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var ty = T((Ok, ey) => {
  var KR = Cr(), jR = ar();
  function Pf(t, e, r) {
    if (!(this instanceof Pf))
      return new Pf(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
  }
  ey.exports = Pf;
  Pf.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
    for (var r = e.length;r < this.blockSize; r++)
      e.push(0);
    for (r = 0;r < e.length; r++)
      e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
      e[r] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  Pf.prototype.update = function(e, r) {
    return this.inner.update(e, r), this;
  };
  Pf.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var e0 = T((ry) => {
  var Kt = ry;
  Kt.utils = Cr();
  Kt.common = Tf();
  Kt.sha = V2();
  Kt.ripemd = Q2();
  Kt.hmac = ty();
  Kt.sha1 = Kt.sha.sha1;
  Kt.sha256 = Kt.sha.sha256;
  Kt.sha224 = Kt.sha.sha224;
  Kt.sha384 = Kt.sha.sha384;
  Kt.sha512 = Kt.sha.sha512;
  Kt.ripemd160 = Kt.ripemd.ripemd160;
});
var ny = T((Uk, iy) => {
  iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var t0 = T((oy) => {
  var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
  function ay(t) {
    t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  Zl.PresetCurve = ay;
  function en(t, e) {
    Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
      var r = new ay(e);
      return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
    } });
  }
  en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
  en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var Vl;
  try {
    Vl = ny();
  } catch {
    Vl = undefined;
  }
  en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
});
var uy = T((Hk, hy) => {
  var VR = e0(), Fn = Nl(), sy = ar();
  function tn(t) {
    if (!(this instanceof tn))
      return new tn(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o2 = Fn.toArray(t.pers, t.persEnc || "hex");
    sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o2);
  }
  hy.exports = tn;
  tn.prototype._init = function(e, r, o2) {
    var f = e.concat(r).concat(o2);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var p2 = 0;p2 < this.V.length; p2++)
      this.K[p2] = 0, this.V[p2] = 1;
    this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  tn.prototype._hmac = function() {
    return new VR.hmac(this.hash, this.K);
  };
  tn.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  tn.prototype.reseed = function(e, r, o2, f) {
    typeof r != "string" && (f = o2, o2 = r, r = null), e = Fn.toArray(e, r), o2 = Fn.toArray(o2, f), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o2 || [])), this._reseed = 1;
  };
  tn.prototype.generate = function(e, r, o2, f) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r != "string" && (f = o2, o2 = r, r = null), o2 && (o2 = Fn.toArray(o2, f || "hex"), this._update(o2));
    for (var p2 = [];p2.length < e; )
      this.V = this._hmac().update(this.V).digest(), p2 = p2.concat(this.V);
    var m2 = p2.slice(0, e);
    return this._update(o2), this._reseed++, Fn.encode(m2, r);
  };
});
var dy = T((Wk, ly) => {
  var $R = ri(), GR = or(), $l = GR.assert;
  function Gt(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  ly.exports = Gt;
  Gt.fromPublic = function(e, r, o2) {
    return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o2 });
  };
  Gt.fromPrivate = function(e, r, o2) {
    return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o2 });
  };
  Gt.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  Gt.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
  };
  Gt.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  Gt.prototype._importPrivate = function(e, r) {
    this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  Gt.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r);
  };
  Gt.prototype.derive = function(e) {
    return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  Gt.prototype.sign = function(e, r, o2) {
    return this.ec.sign(e, this, r, o2);
  };
  Gt.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this);
  };
  Gt.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var vy = T((Kk, py) => {
  var r0 = ri(), Xl = or(), YR = Xl.assert;
  function i0(t, e) {
    if (t instanceof i0)
      return t;
    this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  py.exports = i0;
  function XR() {
    this.place = 0;
  }
  function Gl(t, e) {
    var r = t[e.place++];
    if (!(r & 128))
      return r;
    var o2 = r & 15;
    if (o2 === 0 || o2 > 4)
      return false;
    for (var f = 0, p2 = 0, m2 = e.place;p2 < o2; p2++, m2++)
      f <<= 8, f |= t[m2], f >>>= 0;
    return f <= 127 ? false : (e.place = m2, f);
  }
  function cy(t) {
    for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  i0.prototype._importDER = function(e, r) {
    e = Xl.toArray(e, r);
    var o2 = new XR;
    if (e[o2.place++] !== 48)
      return false;
    var f = Gl(e, o2);
    if (f === false || f + o2.place !== e.length || e[o2.place++] !== 2)
      return false;
    var p2 = Gl(e, o2);
    if (p2 === false)
      return false;
    var m2 = e.slice(o2.place, p2 + o2.place);
    if (o2.place += p2, e[o2.place++] !== 2)
      return false;
    var y3 = Gl(e, o2);
    if (y3 === false || e.length !== y3 + o2.place)
      return false;
    var M2 = e.slice(o2.place, y3 + o2.place);
    if (m2[0] === 0)
      if (m2[1] & 128)
        m2 = m2.slice(1);
      else
        return false;
    if (M2[0] === 0)
      if (M2[1] & 128)
        M2 = M2.slice(1);
      else
        return false;
    return this.r = new r0(m2), this.s = new r0(M2), this.recoveryParam = null, true;
  };
  function Yl(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128);--r; )
      t.push(e >>> (r << 3) & 255);
    t.push(e);
  }
  i0.prototype.toDER = function(e) {
    var r = this.r.toArray(), o2 = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), o2[0] & 128 && (o2 = [0].concat(o2)), r = cy(r), o2 = cy(o2);!o2[0] && !(o2[1] & 128); )
      o2 = o2.slice(1);
    var f = [2];
    Yl(f, r.length), f = f.concat(r), f.push(2), Yl(f, o2.length);
    var p2 = f.concat(o2), m2 = [48];
    return Yl(m2, p2.length), m2 = m2.concat(p2), Xl.encode(m2, e);
  };
});
var yy = T((jk, gy) => {
  var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
  function Sr(t) {
    if (!(this instanceof Sr))
      return new Sr(t);
    typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  gy.exports = Sr;
  Sr.prototype.keyPair = function(e) {
    return new Ql(this, e);
  };
  Sr.prototype.keyFromPrivate = function(e, r) {
    return Ql.fromPrivate(this, e, r);
  };
  Sr.prototype.keyFromPublic = function(e, r) {
    return Ql.fromPublic(this, e, r);
  };
  Sr.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o2 = this.n.byteLength(), f = this.n.sub(new Un(2));; ) {
      var p2 = new Un(r.generate(o2));
      if (!(p2.cmp(f) > 0))
        return p2.iaddn(1), this.keyFromPrivate(p2);
    }
  };
  Sr.prototype._truncateToN = function(e, r) {
    var o2 = e.byteLength() * 8 - this.n.bitLength();
    return o2 > 0 && (e = e.ushrn(o2)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  Sr.prototype.sign = function(e, r, o2, f) {
    typeof o2 == "object" && (f = o2, o2 = null), f || (f = {}), r = this.keyFromPrivate(r, o2), e = this._truncateToN(new Un(e, 16));
    for (var p2 = this.n.byteLength(), m2 = r.getPrivate().toArray("be", p2), y3 = e.toArray("be", p2), M2 = new by({ hash: this.hash, entropy: m2, nonce: y3, pers: f.pers, persEnc: f.persEnc || "utf8" }), x3 = this.n.sub(new Un(1)), S = 0;; S++) {
      var E3 = f.k ? f.k(S) : new Un(M2.generate(this.n.byteLength()));
      if (E3 = this._truncateToN(E3, true), !(E3.cmpn(1) <= 0 || E3.cmp(x3) >= 0)) {
        var B = this.g.mul(E3);
        if (!B.isInfinity()) {
          var q = B.getX(), L2 = q.umod(this.n);
          if (L2.cmpn(0) !== 0) {
            var ge = E3.invm(this.n).mul(L2.mul(r.getPrivate()).iadd(e));
            if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
              var _e = (B.getY().isOdd() ? 1 : 0) | (q.cmp(L2) !== 0 ? 2 : 0);
              return f.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L2, s: ge, recoveryParam: _e });
            }
          }
        }
      }
    }
  };
  Sr.prototype.verify = function(e, r, o2, f) {
    e = this._truncateToN(new Un(e, 16)), o2 = this.keyFromPublic(o2, f), r = new n0(r, "hex");
    var { r: p2, s: m2 } = r;
    if (p2.cmpn(1) < 0 || p2.cmp(this.n) >= 0 || m2.cmpn(1) < 0 || m2.cmp(this.n) >= 0)
      return false;
    var y3 = m2.invm(this.n), M2 = y3.mul(e).umod(this.n), x3 = y3.mul(p2).umod(this.n), S;
    return this.curve._maxwellTrick ? (S = this.g.jmulAdd(M2, o2.getPublic(), x3), S.isInfinity() ? false : S.eqXToP(p2)) : (S = this.g.mulAdd(M2, o2.getPublic(), x3), S.isInfinity() ? false : S.getX().umod(this.n).cmp(p2) === 0);
  };
  Sr.prototype.recoverPubKey = function(t, e, r, o2) {
    my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o2);
    var f = this.n, p2 = new Un(t), m2 = e.r, y3 = e.s, M2 = r & 1, x3 = r >> 1;
    if (m2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x3)
      throw new Error("Unable to find sencond key candinate");
    x3 ? m2 = this.curve.pointFromX(m2.add(this.curve.n), M2) : m2 = this.curve.pointFromX(m2, M2);
    var S = e.r.invm(f), E3 = f.sub(p2).mul(S).umod(f), B = y3.mul(S).umod(f);
    return this.g.mulAdd(E3, m2, B);
  };
  Sr.prototype.getKeyRecoveryParam = function(t, e, r, o2) {
    if (e = new n0(e, o2), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var f = 0;f < 4; f++) {
      var p2;
      try {
        p2 = this.recoverPubKey(t, e, f);
      } catch {
        continue;
      }
      if (p2.eq(r))
        return f;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var xy = T((Zk, _y) => {
  var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
  function Ft(t, e) {
    this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
  }
  Ft.fromPublic = function(e, r) {
    return r instanceof Ft ? r : new Ft(e, { pub: r });
  };
  Ft.fromSecret = function(e, r) {
    return r instanceof Ft ? r : new Ft(e, { secret: r });
  };
  Ft.prototype.secret = function() {
    return this._secret;
  };
  Cf(Ft, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  Cf(Ft, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  Cf(Ft, "privBytes", function() {
    var e = this.eddsa, r = this.hash(), o2 = e.encodingLength - 1, f = r.slice(0, e.encodingLength);
    return f[0] &= 248, f[o2] &= 127, f[o2] |= 64, f;
  });
  Cf(Ft, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  Cf(Ft, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  Cf(Ft, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  Ft.prototype.sign = function(e) {
    return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  Ft.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this);
  };
  Ft.prototype.getSecret = function(e) {
    return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
  };
  Ft.prototype.getPublic = function(e) {
    return za.encode(this.pubBytes(), e);
  };
  _y.exports = Ft;
});
var Ey = T((Vk, Sy) => {
  var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
  function zn(t, e) {
    this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  a0(zn, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  a0(zn, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  a0(zn, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  a0(zn, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  zn.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  zn.prototype.toHex = function() {
    return f0.encode(this.toBytes(), "hex").toUpperCase();
  };
  Sy.exports = zn;
});
var Iy = T(($k, qy) => {
  var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
  function nr(t) {
    if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
      return new nr(t);
    t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
  }
  qy.exports = nr;
  nr.prototype.sign = function(e, r) {
    e = Ry(e);
    var o2 = this.keyFromSecret(r), f = this.hashInt(o2.messagePrefix(), e), p2 = this.g.mul(f), m2 = this.encodePoint(p2), y3 = this.hashInt(m2, o2.pubBytes(), e).mul(o2.priv()), M2 = f.add(y3).umod(this.curve.n);
    return this.makeSignature({ R: p2, S: M2, Rencoded: m2 });
  };
  nr.prototype.verify = function(e, r, o2) {
    e = Ry(e), r = this.makeSignature(r);
    var f = this.keyFromPublic(o2), p2 = this.hashInt(r.Rencoded(), f.pubBytes(), e), m2 = this.g.mul(r.S()), y3 = r.R().add(f.pub().mul(p2));
    return y3.eq(m2);
  };
  nr.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0;r < arguments.length; r++)
      e.update(arguments[r]);
    return Of.intFromLE(e.digest()).umod(this.curve.n);
  };
  nr.prototype.keyFromPublic = function(e) {
    return By.fromPublic(this, e);
  };
  nr.prototype.keyFromSecret = function(e) {
    return By.fromSecret(this, e);
  };
  nr.prototype.makeSignature = function(e) {
    return e instanceof Ay ? e : new Ay(this, e);
  };
  nr.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
  };
  nr.prototype.decodePoint = function(e) {
    e = Of.parseBytes(e);
    var r = e.length - 1, o2 = e.slice(0, r).concat(e[r] & -129), f = (e[r] & 128) !== 0, p2 = Of.intFromLE(o2);
    return this.curve.pointFromY(p2, f);
  };
  nr.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  nr.prototype.decodeInt = function(e) {
    return Of.intFromLE(e);
  };
  nr.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var o0 = T((Ty) => {
  var Hn = Ty;
  Hn.version = s2().version;
  Hn.utils = or();
  Hn.rand = As();
  Hn.curve = Pl();
  Hn.curves = t0();
  Hn.ec = yy();
  Hn.eddsa = Iy();
});
var td = T((ky, ed) => {
  (function(t, e) {
    function r(v3, i) {
      if (!v3)
        throw new Error(i || "Assertion failed");
    }
    function o2(v3, i) {
      v3.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v3.prototype = new a2, v3.prototype.constructor = v3;
    }
    function f(v3, i, a2) {
      if (f.isBN(v3))
        return v3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v3 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v3 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h2) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h2);
      if (typeof i == "object")
        return this._initArray(i, a2, h2);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h2) : (this._parseBase(i, a2, s), h2 === "le" && this._initArray(this.toArray(), a2, h2)));
    }, f.prototype._initNumber = function(i, a2, h2) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), a2, h2);
    }, f.prototype._initArray = function(i, a2, h2) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h2 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h2 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v3, i) {
      var a2 = v3.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y3(v3, i, a2) {
      var h2 = m2(v3, a2);
      return a2 - 1 >= i && (h2 |= m2(v3, a2 - 1) << 4), h2;
    }
    f.prototype._parseHex = function(i, a2, h2) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h2 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v3, i, a2, h2) {
      for (var s = 0, u = Math.min(v3.length, a2), c = i;c < u; c++) {
        var b3 = v3.charCodeAt(c) - 48;
        s *= h2, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h2) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h2, b3 = c % s, l2 = Math.min(c, c - b3) + h2, n = 0, d2 = h2;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h2;
      if (i === 16 || i === "hex") {
        h2 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h2 = x3[6 - l2.length] + l2 + h2 : h2 = l2 + h2, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h2 = u.toString(16) + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h2 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h2 = g2 + h2 : h2 = x3[n - g2.length] + g2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h2) {
      var s = this.byteLength(), u = h2 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h2 = 0;
      return a2 >= 4096 && (h2 += 13, a2 >>>= 13), a2 >= 64 && (h2 += 7, a2 >>>= 7), a2 >= 8 && (h2 += 4, a2 >>>= 4), a2 >= 2 && (h2 += 2, a2 >>>= 2), h2 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h2 = 0;
      return (a2 & 8191) === 0 && (h2 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h2 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h2 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h2 += 2, a2 >>>= 2), (a2 & 1) === 0 && h2++, h2;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v3) {
      for (var i = new Array(v3.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h2 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v3.words[h2] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h2 = this._zeroBits(this.words[a2]);
        if (i += h2, h2 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h2 = 0;h2 < a2.length; h2++)
        this.words[h2] = this.words[h2] & i.words[h2];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h2;
      this.length > i.length ? (a2 = this, h2 = i) : (a2 = i, h2 = this);
      for (var s = 0;s < h2.length; s++)
        this.words[s] = a2.words[s] ^ h2.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h2 = i % 26;
      this._expand(a2), h2 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h2 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h2), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h2 = i / 26 | 0, s = i % 26;
      return this._expand(h2 + 1), a2 ? this.words[h2] = this.words[h2] | 1 << s : this.words[h2] = this.words[h2] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h2, s;
      this.length > i.length ? (h2 = this, s = i) : (h2 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h2.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h2.length; c++)
        a2 = (h2.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h2.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h2 !== this)
        for (;c < h2.length; c++)
          this.words[c] = h2.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h2 = this.cmp(i);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h2 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative;
      var h2 = v3.length + i.length | 0;
      a2.length = h2, h2 = h2 - 1 | 0;
      var s = v3.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h2; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v3.length + 1);_3 <= g2; _3++) {
          var A2 = n - _3 | 0;
          s = v3.words[A2] | 0, u = i.words[_3] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h2) {
      var s = i.words, u = a2.words, c = h2.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _3 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F3 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z3 = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h2.negative = i.negative ^ a2.negative, h2.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_3, X) | 0, d2 = Math.imul(_3, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_3, Q) | 0, d2 = d2 + Math.imul(_3, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_3, te) | 0, d2 = d2 + Math.imul(_3, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_3, ie) | 0, d2 = d2 + Math.imul(_3, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F3, X), n = Math.imul(F3, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_3, fe) | 0, d2 = d2 + Math.imul(_3, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F3, Q) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_3, oe) | 0, d2 = d2 + Math.imul(_3, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F3, te) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_3, he) | 0, d2 = d2 + Math.imul(_3, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z3, X) | 0, d2 = Math.imul(Z3, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_3, le) | 0, d2 = d2 + Math.imul(_3, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z3, Q) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F3, fe) | 0, n = n + Math.imul(F3, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_3, ce2) | 0, d2 = d2 + Math.imul(_3, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F3, oe) | 0, n = n + Math.imul(F3, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_3, ve) | 0, d2 = d2 + Math.imul(_3, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F3, ce2) | 0, n = n + Math.imul(F3, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z3, ce2) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h2.length++), h2;
    };
    Math.imul || (L2 = q);
    function ge(v3, i, a2) {
      a2.negative = i.negative ^ v3.negative, a2.length = v3.length + i.length;
      for (var h2 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h2 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v3.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v3.words[d2] | 0, g2 = i.words[n] | 0, _3 = w3 * g2, A2 = _3 & 67108863;
          c = c + (_3 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h2 = c, c = s;
      }
      return h2 !== 0 ? a2.words[u] = h2 : a2.length--, a2.strip();
    }
    function _e(v3, i, a2) {
      var h2 = new N3;
      return h2.mulp(v3, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h2, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h2 = L2(this, i, a2) : s < 63 ? h2 = q(this, i, a2) : s < 1024 ? h2 = ge(this, i, a2) : h2 = _e(this, i, a2), h2;
    };
    function N3(v3, i) {
      this.x = v3, this.y = i;
    }
    N3.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h2 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h2, i);
      return a2;
    }, N3.prototype.revBin = function(i, a2, h2) {
      if (i === 0 || i === h2 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N3.prototype.permute = function(i, a2, h2, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h2[i[b3]];
    }, N3.prototype.transform = function(i, a2, h2, s, u, c) {
      this.permute(c, i, a2, h2, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _3 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h2[w3 + A2], I = s[w3 + A2], Me = h2[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _3 * k;
            k = g2 * k + _3 * Me, Me = D2, h2[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h2[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _3, _3 = n * _3 + d2 * g2, g2 = D2);
          }
    }, N3.prototype.guessLen13b = function(i, a2) {
      var h2 = Math.max(a2, i) | 1, s = h2 & 1, u = 0;
      for (h2 = h2 / 2 | 0;h2; h2 = h2 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N3.prototype.conjugate = function(i, a2, h2) {
      if (!(h2 <= 1))
        for (var s = 0;s < h2 / 2; s++) {
          var u = i[s];
          i[s] = i[h2 - s - 1], i[h2 - s - 1] = u, u = a2[s], a2[s] = -a2[h2 - s - 1], a2[h2 - s - 1] = -u;
        }
    }, N3.prototype.normalize13b = function(i, a2) {
      for (var h2 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h2;
        i[s] = u & 67108863, u < 67108864 ? h2 = 0 : h2 = u / 67108864 | 0;
      }
      return i;
    }, N3.prototype.convert13b = function(i, a2, h2, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h2[2 * c] = u & 8191, u = u >>> 13, h2[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h2[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N3.prototype.stub = function(i) {
      for (var a2 = new Array(i), h2 = 0;h2 < i; h2++)
        a2[h2] = 0;
      return a2;
    }, N3.prototype.mulp = function(i, a2, h2) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _3 = h2.words;
      _3.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _3, c, s, u), this.conjugate(_3, c, s), this.normalize13b(_3, s), h2.negative = i.negative ^ a2.negative, h2.length = i.length + a2.length, h2.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h2 = 0;h2 < this.length; h2++) {
        var s = (this.words[h2] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h2] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h2] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h2 = this, s = 0;s < a2.length && a2[s] === 0; s++, h2 = h2.sqr())
        ;
      if (++s < a2.length)
        for (var u = h2.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h2 = h2.mul(u));
      return h2;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h2 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h2] = this.words[u];
        for (u = 0;u < h2; u++)
          this.words[u] = 0;
        this.length += h2;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h2) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h2;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h2) {
      return r(this.negative === 0), this.iushrn(i, a2, h2);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return false;
      var u = this.words[h2];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (a2 !== 0 && h2++, this.length = Math.min(h2, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h2) {
      var s = i.length + h2, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h2] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h2] = c & 67108863;
      }
      for (;u < this.length - h2; u++)
        c = (this.words[u + h2] | 0) + b3, b3 = c >> 26, this.words[u + h2] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h2 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h2 = 26 - b3, h2 !== 0 && (u = u.ushln(h2), s.iushln(h2), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _3 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_3 = Math.min(_3 / c | 0, 67108863), s._ishlnsubmul(u, _3, g2);s.negative !== 0; )
          _3--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _3);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h2 !== 0 && s.iushrn(h2), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h2) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h2 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h2.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h2 = 0, s = this.length - 1;s >= 0; s--)
        h2 = (a2 * h2 + (this.words[s] | 0)) % i;
      return h2;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = (this.words[h2] | 0) + a2 * 67108864;
        this.words[h2] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h2.isEven(); )
        a2.iushrn(1), h2.iushrn(1), ++l2;
      for (var n = h2.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _3 = 0, A2 = 1;(h2.words[0] & A2) === 0 && _3 < 26; ++_3, A2 <<= 1)
          ;
        if (_3 > 0)
          for (h2.iushrn(_3);_3-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(c), u.isub(b3)) : (h2.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h2.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h2.clone();a2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h2.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h2.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(u)) : (h2.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h2 = i.clone();
      a2.negative = 0, h2.negative = 0;
      for (var s = 0;a2.isEven() && h2.isEven(); s++)
        a2.iushrn(1), h2.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h2.isEven(); )
          h2.iushrn(1);
        var u = a2.cmp(h2);
        if (u < 0) {
          var c = a2;
          a2 = h2, h2 = c;
        } else if (u === 0 || h2.cmpn(1) === 0)
          break;
        a2.isub(h2);
      } while (true);
      return h2.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= s, this;
      for (var u = s, c = h2;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h2 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = this.words[h2] | 0, u = i.words[h2] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P3(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v3, i) {
      this.name = v3, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h2 = a2.bitLength();
      while (h2 > this.n);
      var s = h2 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h2 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h2, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h2) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = i.words[h2] | 0;
        a2 += s * 977, i.words[h2] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = (i.words[h2] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h2] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P3(v3) {
      if (typeof v3 == "string") {
        var i = f._prime(v3);
        this.m = i.p, this.prime = i;
      } else
        r(v3.gtn(1), "modulus must be greater than 1"), this.m = v3, this.prime = null;
    }
    P3.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P3.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P3.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P3.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P3.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.add(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, P3.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.iadd(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, P3.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.sub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, P3.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.isub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, P3.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P3.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P3.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P3.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P3.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P3.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h2 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h2);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _3 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _3);
        var I = this.pow(d2, new f(1).iushln(_3 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _3 = R3;
      }
      return w3;
    }, P3.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P3.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h2 = 4, s = new Array(1 << h2);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h2 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P3.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P3.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v3) {
      P3.call(this, v3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P3), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h2 = i.imul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h2 = i.mul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof ed > "u" || ed, ky);
});
var h0 = T((Yk, Ly) => {
  var s0 = Ut2(), Ff = s0.Buffer, Er2 = {}, Ar2;
  for (Ar2 in s0)
    !s0.hasOwnProperty(Ar2) || Ar2 === "SlowBuffer" || Ar2 === "Buffer" || (Er2[Ar2] = s0[Ar2]);
  var Uf = Er2.Buffer = {};
  for (Ar2 in Ff)
    !Ff.hasOwnProperty(Ar2) || Ar2 === "allocUnsafe" || Ar2 === "allocUnsafeSlow" || (Uf[Ar2] = Ff[Ar2]);
  Er2.Buffer.prototype = Ff.prototype;
  (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return Ff(t, e, r);
  });
  Uf.alloc || (Uf.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var o2 = Ff(t);
    return !e || e.length === 0 ? o2.fill(0) : typeof r == "string" ? o2.fill(e, r) : o2.fill(e), o2;
  });
  if (!Er2.kStringMaxLength)
    try {
      Er2.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  Er2.constants || (Er2.constants = { MAX_LENGTH: Er2.kMaxLength }, Er2.kStringMaxLength && (Er2.constants.MAX_STRING_LENGTH = Er2.kStringMaxLength));
  Ly.exports = Er2;
});
var u0 = T((Ny) => {
  var aB = Ie();
  function Rr2(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  Ny.Reporter = Rr2;
  Rr2.prototype.isError = function(e) {
    return e instanceof zf;
  };
  Rr2.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  Rr2.prototype.restore = function(e) {
    let r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
  };
  Rr2.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  Rr2.prototype.exitKey = function(e) {
    let r = this._reporterState;
    r.path = r.path.slice(0, e - 1);
  };
  Rr2.prototype.leaveKey = function(e, r, o2) {
    let f = this._reporterState;
    this.exitKey(e), f.obj !== null && (f.obj[r] = o2);
  };
  Rr2.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  Rr2.prototype.enterObject = function() {
    let e = this._reporterState, r = e.obj;
    return e.obj = {}, r;
  };
  Rr2.prototype.leaveObject = function(e) {
    let r = this._reporterState, o2 = r.obj;
    return r.obj = e, o2;
  };
  Rr2.prototype.error = function(e) {
    let r, o2 = this._reporterState, f = e instanceof zf;
    if (f ? r = e : r = new zf(o2.path.map(function(p2) {
      return "[" + JSON.stringify(p2) + "]";
    }).join(""), e.message || e, e.stack), !o2.options.partial)
      throw r;
    return f || o2.errors.push(r), r;
  };
  Rr2.prototype.wrapResult = function(e) {
    let r = this._reporterState;
    return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
  };
  function zf(t, e) {
    this.path = t, this.rethrow(e);
  }
  aB(zf, Error);
  zf.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  };
});
var Kf = T((rd) => {
  var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
  function Br3(t, e) {
    if (l0.call(this, e), !Hf.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  oB(Br3, l0);
  rd.DecoderBuffer = Br3;
  Br3.isDecoderBuffer = function(e) {
    return e instanceof Br3 ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  Br3.prototype.save = function() {
    return { offset: this.offset, reporter: l0.prototype.save.call(this) };
  };
  Br3.prototype.restore = function(e) {
    let r = new Br3(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
  };
  Br3.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  Br3.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  Br3.prototype.skip = function(e, r) {
    if (!(this.offset + e <= this.length))
      return this.error(r || "DecoderBuffer overrun");
    let o2 = new Br3(this.base);
    return o2._reporterState = this._reporterState, o2.offset = this.offset, o2.length = this.offset + e, this.offset += e, o2;
  };
  Br3.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function Wf(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r) {
        return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = Hf.byteLength(t);
    else if (Hf.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  rd.EncoderBuffer = Wf;
  Wf.isEncoderBuffer = function(e) {
    return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  Wf.prototype.join = function(e, r) {
    return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o2) {
      o2.join(e, r), r += o2.length;
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
  };
});
var d0 = T((Qk, Py) => {
  var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function Ue(t, e, r) {
    let o2 = {};
    this._baseState = o2, o2.name = r, o2.enc = t, o2.parent = e || null, o2.children = null, o2.tag = null, o2.args = null, o2.reverseArgs = null, o2.choice = null, o2.optional = false, o2.any = false, o2.obj = false, o2.use = null, o2.useDecoder = null, o2.key = null, o2.default = null, o2.explicit = null, o2.implicit = null, o2.contains = null, o2.parent || (o2.children = [], this._wrap());
  }
  Py.exports = Ue;
  var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  Ue.prototype.clone = function() {
    let e = this._baseState, r = {};
    cB.forEach(function(f) {
      r[f] = e[f];
    });
    let o2 = new this.constructor(r.parent);
    return o2._baseState = r, o2;
  };
  Ue.prototype._wrap = function() {
    let e = this._baseState;
    lB.forEach(function(r) {
      this[r] = function() {
        let f = new this.constructor(this);
        return e.children.push(f), f[r].apply(f, arguments);
      };
    }, this);
  };
  Ue.prototype._init = function(e) {
    let r = this._baseState;
    Qt(r.parent === null), e.call(this), r.children = r.children.filter(function(o2) {
      return o2._baseState.parent === this;
    }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
  };
  Ue.prototype._useArgs = function(e) {
    let r = this._baseState, o2 = e.filter(function(f) {
      return f instanceof this.constructor;
    }, this);
    e = e.filter(function(f) {
      return !(f instanceof this.constructor);
    }, this), o2.length !== 0 && (Qt(r.children === null), r.children = o2, o2.forEach(function(f) {
      f._baseState.parent = this;
    }, this)), e.length !== 0 && (Qt(r.args === null), r.args = e, r.reverseArgs = e.map(function(f) {
      if (typeof f != "object" || f.constructor !== Object)
        return f;
      let p2 = {};
      return Object.keys(f).forEach(function(m2) {
        m2 == (m2 | 0) && (m2 |= 0);
        let y3 = f[m2];
        p2[y3] = m2;
      }), p2;
    }));
  };
  dB.forEach(function(t) {
    Ue.prototype[t] = function() {
      let r = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r.enc);
    };
  });
  Dy.forEach(function(t) {
    Ue.prototype[t] = function() {
      let r = this._baseState, o2 = Array.prototype.slice.call(arguments);
      return Qt(r.tag === null), r.tag = t, this._useArgs(o2), this;
    };
  });
  Ue.prototype.use = function(e) {
    Qt(e);
    let r = this._baseState;
    return Qt(r.use === null), r.use = e, this;
  };
  Ue.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  Ue.prototype.def = function(e) {
    let r = this._baseState;
    return Qt(r.default === null), r.default = e, r.optional = true, this;
  };
  Ue.prototype.explicit = function(e) {
    let r = this._baseState;
    return Qt(r.explicit === null && r.implicit === null), r.explicit = e, this;
  };
  Ue.prototype.implicit = function(e) {
    let r = this._baseState;
    return Qt(r.explicit === null && r.implicit === null), r.implicit = e, this;
  };
  Ue.prototype.obj = function() {
    let e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = true, r.length !== 0 && this._useArgs(r), this;
  };
  Ue.prototype.key = function(e) {
    let r = this._baseState;
    return Qt(r.key === null), r.key = e, this;
  };
  Ue.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  Ue.prototype.choice = function(e) {
    let r = this._baseState;
    return Qt(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o2) {
      return e[o2];
    })), this;
  };
  Ue.prototype.contains = function(e) {
    let r = this._baseState;
    return Qt(r.use === null), r.contains = e, this;
  };
  Ue.prototype._decode = function(e, r) {
    let o2 = this._baseState;
    if (o2.parent === null)
      return e.wrapResult(o2.children[0]._decode(e, r));
    let f = o2.default, p2 = true, m2 = null;
    if (o2.key !== null && (m2 = e.enterKey(o2.key)), o2.optional) {
      let M2 = null;
      if (o2.explicit !== null ? M2 = o2.explicit : o2.implicit !== null ? M2 = o2.implicit : o2.tag !== null && (M2 = o2.tag), M2 === null && !o2.any) {
        let x3 = e.save();
        try {
          o2.choice === null ? this._decodeGeneric(o2.tag, e, r) : this._decodeChoice(e, r), p2 = true;
        } catch {
          p2 = false;
        }
        e.restore(x3);
      } else if (p2 = this._peekTag(e, M2, o2.any), e.isError(p2))
        return p2;
    }
    let y3;
    if (o2.obj && p2 && (y3 = e.enterObject()), p2) {
      if (o2.explicit !== null) {
        let x3 = this._decodeTag(e, o2.explicit);
        if (e.isError(x3))
          return x3;
        e = x3;
      }
      let M2 = e.offset;
      if (o2.use === null && o2.choice === null) {
        let x3;
        o2.any && (x3 = e.save());
        let S = this._decodeTag(e, o2.implicit !== null ? o2.implicit : o2.tag, o2.any);
        if (e.isError(S))
          return S;
        o2.any ? f = e.raw(x3) : e = S;
      }
      if (r && r.track && o2.tag !== null && r.track(e.path(), M2, e.length, "tagged"), r && r.track && o2.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o2.any || (o2.choice === null ? f = this._decodeGeneric(o2.tag, e, r) : f = this._decodeChoice(e, r)), e.isError(f))
        return f;
      if (!o2.any && o2.choice === null && o2.children !== null && o2.children.forEach(function(S) {
        S._decode(e, r);
      }), o2.contains && (o2.tag === "octstr" || o2.tag === "bitstr")) {
        let x3 = new uB(f);
        f = this._getUse(o2.contains, e._reporterState.obj)._decode(x3, r);
      }
    }
    return o2.obj && p2 && (f = e.leaveObject(y3)), o2.key !== null && (f !== null || p2 === true) ? e.leaveKey(m2, o2.key, f) : m2 !== null && e.exitKey(m2), f;
  };
  Ue.prototype._decodeGeneric = function(e, r, o2) {
    let f = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f.args[0], o2) : /str$/.test(e) ? this._decodeStr(r, e, o2) : e === "objid" && f.args ? this._decodeObjid(r, f.args[0], f.args[1], o2) : e === "objid" ? this._decodeObjid(r, null, null, o2) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o2) : e === "null_" ? this._decodeNull(r, o2) : e === "bool" ? this._decodeBool(r, o2) : e === "objDesc" ? this._decodeStr(r, e, o2) : e === "int" || e === "enum" ? this._decodeInt(r, f.args && f.args[0], o2) : f.use !== null ? this._getUse(f.use, r._reporterState.obj)._decode(r, o2) : r.error("unknown tag: " + e);
  };
  Ue.prototype._getUse = function(e, r) {
    let o2 = this._baseState;
    return o2.useDecoder = this._use(e, r), Qt(o2.useDecoder._baseState.parent === null), o2.useDecoder = o2.useDecoder._baseState.children[0], o2.implicit !== o2.useDecoder._baseState.implicit && (o2.useDecoder = o2.useDecoder.clone(), o2.useDecoder._baseState.implicit = o2.implicit), o2.useDecoder;
  };
  Ue.prototype._decodeChoice = function(e, r) {
    let o2 = this._baseState, f = null, p2 = false;
    return Object.keys(o2.choice).some(function(m2) {
      let y3 = e.save(), M2 = o2.choice[m2];
      try {
        let x3 = M2._decode(e, r);
        if (e.isError(x3))
          return false;
        f = { type: m2, value: x3 }, p2 = true;
      } catch {
        return e.restore(y3), false;
      }
      return true;
    }, this), p2 ? f : e.error("Choice not matched");
  };
  Ue.prototype._createEncoderBuffer = function(e) {
    return new hB(e, this.reporter);
  };
  Ue.prototype._encode = function(e, r, o2) {
    let f = this._baseState;
    if (f.default !== null && f.default === e)
      return;
    let p2 = this._encodeValue(e, r, o2);
    if (p2 !== undefined && !this._skipDefault(p2, r, o2))
      return p2;
  };
  Ue.prototype._encodeValue = function(e, r, o2) {
    let f = this._baseState;
    if (f.parent === null)
      return f.children[0]._encode(e, r || new sB);
    let p2 = null;
    if (this.reporter = r, f.optional && e === undefined)
      if (f.default !== null)
        e = f.default;
      else
        return;
    let m2 = null, y3 = false;
    if (f.any)
      p2 = this._createEncoderBuffer(e);
    else if (f.choice)
      p2 = this._encodeChoice(e, r);
    else if (f.contains)
      m2 = this._getUse(f.contains, o2)._encode(e, r), y3 = true;
    else if (f.children)
      m2 = f.children.map(function(M2) {
        if (M2._baseState.tag === "null_")
          return M2._encode(null, r, e);
        if (M2._baseState.key === null)
          return r.error("Child should have a key");
        let x3 = r.enterKey(M2._baseState.key);
        if (typeof e != "object")
          return r.error("Child expected, but input is not object");
        let S = M2._encode(e[M2._baseState.key], r, e);
        return r.leaveKey(x3), S;
      }, this).filter(function(M2) {
        return M2;
      }), m2 = this._createEncoderBuffer(m2);
    else if (f.tag === "seqof" || f.tag === "setof") {
      if (!(f.args && f.args.length === 1))
        return r.error("Too many args for : " + f.tag);
      if (!Array.isArray(e))
        return r.error("seqof/setof, but data is not Array");
      let M2 = this.clone();
      M2._baseState.implicit = null, m2 = this._createEncoderBuffer(e.map(function(x3) {
        let S = this._baseState;
        return this._getUse(S.args[0], e)._encode(x3, r);
      }, M2));
    } else
      f.use !== null ? p2 = this._getUse(f.use, o2)._encode(e, r) : (m2 = this._encodePrimitive(f.tag, e), y3 = true);
    if (!f.any && f.choice === null) {
      let M2 = f.implicit !== null ? f.implicit : f.tag, x3 = f.implicit === null ? "universal" : "context";
      M2 === null ? f.use === null && r.error("Tag could be omitted only for .use()") : f.use === null && (p2 = this._encodeComposite(M2, y3, x3, m2));
    }
    return f.explicit !== null && (p2 = this._encodeComposite(f.explicit, false, "context", p2)), p2;
  };
  Ue.prototype._encodeChoice = function(e, r) {
    let o2 = this._baseState, f = o2.choice[e.type];
    return f || Qt(false, e.type + " not found in " + JSON.stringify(Object.keys(o2.choice))), f._encode(e.value, r);
  };
  Ue.prototype._encodePrimitive = function(e, r) {
    let o2 = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r, e);
    if (e === "objid" && o2.args)
      return this._encodeObjid(r, o2.reverseArgs[0], o2.args[1]);
    if (e === "objid")
      return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r, o2.args && o2.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r);
    if (e === "objDesc")
      return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e);
  };
  Ue.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  Ue.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var c0 = T((Wn) => {
  function Cy(t) {
    let e = {};
    return Object.keys(t).forEach(function(r) {
      (r | 0) == r && (r = r | 0);
      let o2 = t[r];
      e[o2] = r;
    }), e;
  }
  Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  Wn.tagClassByName = Cy(Wn.tagClass);
  Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  Wn.tagByName = Cy(Wn.tag);
});
var nd = T((tL, Uy) => {
  var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
  function Fy(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur3, this.tree._init(t.body);
  }
  Uy.exports = Fy;
  Fy.prototype.encode = function(e, r) {
    return this.tree._encode(e, r).join();
  };
  function Ur3(t) {
    Oy.call(this, "der", t);
  }
  pB(Ur3, Oy);
  Ur3.prototype._encodeComposite = function(e, r, o2, f) {
    let p2 = vB(e, r, o2, this.reporter);
    if (f.length < 128) {
      let M2 = Ii.alloc(2);
      return M2[0] = p2, M2[1] = f.length, this._createEncoderBuffer([M2, f]);
    }
    let m2 = 1;
    for (let M2 = f.length;M2 >= 256; M2 >>= 8)
      m2++;
    let y3 = Ii.alloc(1 + 1 + m2);
    y3[0] = p2, y3[1] = 128 | m2;
    for (let M2 = 1 + m2, x3 = f.length;x3 > 0; M2--, x3 >>= 8)
      y3[M2] = x3 & 255;
    return this._createEncoderBuffer([y3, f]);
  };
  Ur3.prototype._encodeStr = function(e, r) {
    if (r === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
      let o2 = Ii.alloc(e.length * 2);
      for (let f = 0;f < e.length; f++)
        o2.writeUInt16BE(e.charCodeAt(f), f * 2);
      return this._createEncoderBuffer(o2);
    } else
      return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
  };
  Ur3.prototype._encodeObjid = function(e, r, o2) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("string objid given, but no values map found");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r[e].split(/[\s.]+/g);
      for (let y3 = 0;y3 < e.length; y3++)
        e[y3] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let y3 = 0;y3 < e.length; y3++)
        e[y3] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!o2) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let f = 0;
    for (let y3 = 0;y3 < e.length; y3++) {
      let M2 = e[y3];
      for (f++;M2 >= 128; M2 >>= 7)
        f++;
    }
    let p2 = Ii.alloc(f), m2 = p2.length - 1;
    for (let y3 = e.length - 1;y3 >= 0; y3--) {
      let M2 = e[y3];
      for (p2[m2--] = M2 & 127;(M2 >>= 7) > 0; )
        p2[m2--] = 128 | M2 & 127;
    }
    return this._createEncoderBuffer(p2);
  };
  function qr(t) {
    return t < 10 ? "0" + t : t;
  }
  Ur3.prototype._encodeTime = function(e, r) {
    let o2, f = new Date(e);
    return r === "gentime" ? o2 = [qr(f.getUTCFullYear()), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o2 = [qr(f.getUTCFullYear() % 100), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o2, "octstr");
  };
  Ur3.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Ur3.prototype._encodeInt = function(e, r) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r[e];
    }
    if (typeof e != "number" && !Ii.isBuffer(e)) {
      let p2 = e.toArray();
      !e.sign && p2[0] & 128 && p2.unshift(0), e = Ii.from(p2);
    }
    if (Ii.isBuffer(e)) {
      let p2 = e.length;
      e.length === 0 && p2++;
      let m2 = Ii.alloc(p2);
      return e.copy(m2), e.length === 0 && (m2[0] = 0), this._createEncoderBuffer(m2);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let o2 = 1;
    for (let p2 = e;p2 >= 256; p2 >>= 8)
      o2++;
    let f = new Array(o2);
    for (let p2 = f.length - 1;p2 >= 0; p2--)
      f[p2] = e & 255, e >>= 8;
    return f[0] & 128 && f.unshift(0), this._createEncoderBuffer(Ii.from(f));
  };
  Ur3.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Ur3.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
  };
  Ur3.prototype._skipDefault = function(e, r, o2) {
    let f = this._baseState, p2;
    if (f.default === null)
      return false;
    let m2 = e.join();
    if (f.defaultBuffer === undefined && (f.defaultBuffer = this._encodeValue(f.default, r, o2).join()), m2.length !== f.defaultBuffer.length)
      return false;
    for (p2 = 0;p2 < m2.length; p2++)
      if (m2[p2] !== f.defaultBuffer[p2])
        return false;
    return true;
  };
  function vB(t, e, r, o2) {
    let f;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
      f = id.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      f = t;
    else
      return o2.error("Unknown tag: " + t);
    return f >= 31 ? o2.error("Multi-octet tag encoding unsupported") : (e || (f |= 32), f |= id.tagClassByName[r || "universal"] << 6, f);
  }
});
var Hy = T((rL, zy) => {
  var bB = Ie(), fd = nd();
  function ad(t) {
    fd.call(this, t), this.enc = "pem";
  }
  bB(ad, fd);
  zy.exports = ad;
  ad.prototype.encode = function(e, r) {
    let f = fd.prototype.encode.call(this, e).toString("base64"), p2 = ["-----BEGIN " + r.label + "-----"];
    for (let m2 = 0;m2 < f.length; m2 += 64)
      p2.push(f.slice(m2, m2 + 64));
    return p2.push("-----END " + r.label + "-----"), p2.join(`
`);
  };
});
var od = T((Ky) => {
  var Wy = Ky;
  Wy.der = nd();
  Wy.pem = Hy();
});
var hd = T((nL, Yy) => {
  var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
  function $y(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
  }
  Yy.exports = $y;
  $y.prototype.decode = function(e, r) {
    return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
  };
  function sr(t) {
    Vy.call(this, "der", t);
  }
  mB(sr, Vy);
  sr.prototype._peekTag = function(e, r, o2) {
    if (e.isEmpty())
      return false;
    let f = e.save(), p2 = sd(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(p2) ? p2 : (e.restore(f), p2.tag === r || p2.tagStr === r || p2.tagStr + "of" === r || o2);
  };
  sr.prototype._decodeTag = function(e, r, o2) {
    let f = sd(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(f))
      return f;
    let p2 = Gy(e, f.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(p2))
      return p2;
    if (!o2 && f.tag !== r && f.tagStr !== r && f.tagStr + "of" !== r)
      return e.error('Failed to match tag: "' + r + '"');
    if (f.primitive || p2 !== null)
      return e.skip(p2, 'Failed to match body of: "' + r + '"');
    let m2 = e.save(), y3 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(y3) ? y3 : (p2 = e.offset - m2.offset, e.restore(m2), e.skip(p2, 'Failed to match body of: "' + r + '"'));
  };
  sr.prototype._skipUntilEnd = function(e, r) {
    for (;; ) {
      let o2 = sd(e, r);
      if (e.isError(o2))
        return o2;
      let f = Gy(e, o2.primitive, r);
      if (e.isError(f))
        return f;
      let p2;
      if (o2.primitive || f !== null ? p2 = e.skip(f) : p2 = this._skipUntilEnd(e, r), e.isError(p2))
        return p2;
      if (o2.tagStr === "end")
        break;
    }
  };
  sr.prototype._decodeList = function(e, r, o2, f) {
    let p2 = [];
    for (;!e.isEmpty(); ) {
      let m2 = this._peekTag(e, "end");
      if (e.isError(m2))
        return m2;
      let y3 = o2.decode(e, "der", f);
      if (e.isError(y3) && m2)
        break;
      p2.push(y3);
    }
    return p2;
  };
  sr.prototype._decodeStr = function(e, r) {
    if (r === "bitstr") {
      let o2 = e.readUInt8();
      return e.isError(o2) ? o2 : { unused: o2, data: e.raw() };
    } else if (r === "bmpstr") {
      let o2 = e.raw();
      if (o2.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let f = "";
      for (let p2 = 0;p2 < o2.length / 2; p2++)
        f += String.fromCharCode(o2.readUInt16BE(p2 * 2));
      return f;
    } else if (r === "numstr") {
      let o2 = e.raw().toString("ascii");
      return this._isNumstr(o2) ? o2 : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r === "octstr")
        return e.raw();
      if (r === "objDesc")
        return e.raw();
      if (r === "printstr") {
        let o2 = e.raw().toString("ascii");
        return this._isPrintstr(o2) ? o2 : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
    }
  };
  sr.prototype._decodeObjid = function(e, r, o2) {
    let f, p2 = [], m2 = 0, y3 = 0;
    for (;!e.isEmpty(); )
      y3 = e.readUInt8(), m2 <<= 7, m2 |= y3 & 127, (y3 & 128) === 0 && (p2.push(m2), m2 = 0);
    y3 & 128 && p2.push(m2);
    let M2 = p2[0] / 40 | 0, x3 = p2[0] % 40;
    if (o2 ? f = p2 : f = [M2, x3].concat(p2.slice(1)), r) {
      let S = r[f.join(" ")];
      S === undefined && (S = r[f.join(".")]), S !== undefined && (f = S);
    }
    return f;
  };
  sr.prototype._decodeTime = function(e, r) {
    let o2 = e.raw().toString(), f, p2, m2, y3, M2, x3;
    if (r === "gentime")
      f = o2.slice(0, 4) | 0, p2 = o2.slice(4, 6) | 0, m2 = o2.slice(6, 8) | 0, y3 = o2.slice(8, 10) | 0, M2 = o2.slice(10, 12) | 0, x3 = o2.slice(12, 14) | 0;
    else if (r === "utctime")
      f = o2.slice(0, 2) | 0, p2 = o2.slice(2, 4) | 0, m2 = o2.slice(4, 6) | 0, y3 = o2.slice(6, 8) | 0, M2 = o2.slice(8, 10) | 0, x3 = o2.slice(10, 12) | 0, f < 70 ? f = 2000 + f : f = 1900 + f;
    else
      return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(f, p2 - 1, m2, y3, M2, x3, 0);
  };
  sr.prototype._decodeNull = function() {
    return null;
  };
  sr.prototype._decodeBool = function(e) {
    let r = e.readUInt8();
    return e.isError(r) ? r : r !== 0;
  };
  sr.prototype._decodeInt = function(e, r) {
    let o2 = e.raw(), f = new gB(o2);
    return r && (f = r[f.toString(10)] || f), f;
  };
  sr.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
  };
  function sd(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r))
      return r;
    let o2 = Zy.tagClass[r >> 6], f = (r & 32) === 0;
    if ((r & 31) === 31) {
      let m2 = r;
      for (r = 0;(m2 & 128) === 128; ) {
        if (m2 = t.readUInt8(e), t.isError(m2))
          return m2;
        r <<= 7, r |= m2 & 127;
      }
    } else
      r &= 31;
    let p2 = Zy.tag[r];
    return { cls: o2, primitive: f, tag: r, tagStr: p2 };
  }
  function Gy(t, e, r) {
    let o2 = t.readUInt8(r);
    if (t.isError(o2))
      return o2;
    if (!e && o2 === 128)
      return null;
    if ((o2 & 128) === 0)
      return o2;
    let f = o2 & 127;
    if (f > 4)
      return t.error("length octect is too long");
    o2 = 0;
    for (let p2 = 0;p2 < f; p2++) {
      o2 <<= 8;
      let m2 = t.readUInt8(r);
      if (t.isError(m2))
        return m2;
      o2 |= m2;
    }
    return o2;
  }
});
var Jy = T((fL, Xy) => {
  var yB = Ie(), wB = h0().Buffer, ud = hd();
  function ld(t) {
    ud.call(this, t), this.enc = "pem";
  }
  yB(ld, ud);
  Xy.exports = ld;
  ld.prototype.decode = function(e, r) {
    let o2 = e.toString().split(/[\r\n]+/g), f = r.label.toUpperCase(), p2 = /^-----(BEGIN|END) ([^-]+)-----$/, m2 = -1, y3 = -1;
    for (let S = 0;S < o2.length; S++) {
      let E3 = o2[S].match(p2);
      if (E3 !== null && E3[2] === f)
        if (m2 === -1) {
          if (E3[1] !== "BEGIN")
            break;
          m2 = S;
        } else {
          if (E3[1] !== "END")
            break;
          y3 = S;
          break;
        }
    }
    if (m2 === -1 || y3 === -1)
      throw new Error("PEM section not found for: " + f);
    let M2 = o2.slice(m2 + 1, y3).join("");
    M2.replace(/[^a-z0-9+/=]+/gi, "");
    let x3 = wB.from(M2, "base64");
    return ud.prototype.decode.call(this, x3, r);
  };
});
var dd = T((e3) => {
  var Qy = e3;
  Qy.der = hd();
  Qy.pem = Jy();
});
var r3 = T((t3) => {
  var MB = od(), _B = dd(), xB = Ie(), SB = t3;
  SB.define = function(e, r) {
    return new jf(e, r);
  };
  function jf(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  jf.prototype._createNamed = function(e) {
    let r = this.name;
    function o2(f) {
      this._initNamed(f, r);
    }
    return xB(o2, e), o2.prototype._initNamed = function(p2, m2) {
      e.call(this, p2, m2);
    }, new o2(this);
  };
  jf.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
  };
  jf.prototype.decode = function(e, r, o2) {
    return this._getDecoder(r).decode(e, o2);
  };
  jf.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
  };
  jf.prototype.encode = function(e, r, o2) {
    return this._getEncoder(r).encode(e, o2);
  };
});
var n3 = T((i3) => {
  var p0 = i3;
  p0.Reporter = u0().Reporter;
  p0.DecoderBuffer = Kf().DecoderBuffer;
  p0.EncoderBuffer = Kf().EncoderBuffer;
  p0.Node = d0();
});
var o3 = T((a3) => {
  var f3 = a3;
  f3._reverse = function(e) {
    let r = {};
    return Object.keys(e).forEach(function(o2) {
      (o2 | 0) == o2 && (o2 = o2 | 0);
      let f = e[o2];
      r[f] = o2;
    }), r;
  };
  f3.der = c0();
});
var cd = T((s3) => {
  var Zf = s3;
  Zf.bignum = td();
  Zf.define = r3().define;
  Zf.base = n3();
  Zf.constants = o3();
  Zf.decoders = dd();
  Zf.encoders = od();
});
var d3 = T((lL, l3) => {
  var zr = cd(), h3 = zr.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), EB = zr.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), pd = zr.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), AB = zr.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
  }), RB = zr.define("RelativeDistinguishedName", function() {
    this.setof(EB);
  }), BB = zr.define("RDNSequence", function() {
    this.seqof(RB);
  }), u3 = zr.define("Name", function() {
    this.choice({ rdnSequence: this.use(BB) });
  }), qB = zr.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
  }), IB = zr.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), TB = zr.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
  }), kB = zr.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
  });
  l3.exports = kB;
});
var p3 = T((Wr) => {
  var Hr = cd();
  Wr.certificate = d3();
  var LB = Hr.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  Wr.RSAPrivateKey = LB;
  var NB = Hr.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  Wr.RSAPublicKey = NB;
  var DB = Hr.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
  });
  Wr.PublicKey = DB;
  var c3 = Hr.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), PB = Hr.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
  });
  Wr.PrivateKey = PB;
  var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  Wr.EncryptedPrivateKey = CB;
  var OB = Hr.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  Wr.DSAPrivateKey = OB;
  Wr.DSAparam = Hr.define("DSAparam", function() {
    this.int();
  });
  var FB = Hr.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
  });
  Wr.ECPrivateKey = FB;
  var UB = Hr.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  Wr.signature = Hr.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var v3 = T((cL, zB) => {
  zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var m3 = T((pL, b3) => {
  var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
  b3.exports = function(t, e) {
    var r = t.toString(), o2 = r.match(HB), f;
    if (o2) {
      var m2 = "aes" + o2[1], y3 = v0.from(o2[2], "hex"), M2 = v0.from(o2[3].replace(/[\r\n]/g, ""), "base64"), x3 = jB(e, y3.slice(0, 8), parseInt(o2[1], 10)).key, S = [], E3 = ZB.createDecipheriv(m2, x3, y3);
      S.push(E3.update(M2)), S.push(E3.final()), f = v0.concat(S);
    } else {
      var p2 = r.match(KB);
      f = v0.from(p2[2].replace(/[\r\n]/g, ""), "base64");
    }
    var B = r.match(WB)[1];
    return { tag: B, data: f };
  };
});
var Ha = T((vL, y3) => {
  var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
  y3.exports = g3;
  function g3(t) {
    var e;
    typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
    var r = $B(t, e), o2 = r.tag, f = r.data, p2, m2;
    switch (o2) {
      case "CERTIFICATE":
        m2 = fr.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (m2 || (m2 = fr.PublicKey.decode(f, "der")), p2 = m2.algorithm.algorithm.join("."), p2) {
          case "1.2.840.113549.1.1.1":
            return fr.RSAPublicKey.decode(m2.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return m2.subjectPrivateKey = m2.subjectPublicKey, { type: "ec", data: m2 };
          case "1.2.840.10040.4.1":
            return m2.algorithm.params.pub_key = fr.DSAparam.decode(m2.subjectPublicKey.data, "der"), { type: "dsa", data: m2.algorithm.params };
          default:
            throw new Error("unknown key id " + p2);
        }
      case "ENCRYPTED PRIVATE KEY":
        f = fr.EncryptedPrivateKey.decode(f, "der"), f = XB(f, e);
      case "PRIVATE KEY":
        switch (m2 = fr.PrivateKey.decode(f, "der"), p2 = m2.algorithm.algorithm.join("."), p2) {
          case "1.2.840.113549.1.1.1":
            return fr.RSAPrivateKey.decode(m2.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: m2.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m2.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return m2.algorithm.params.priv_key = fr.DSAparam.decode(m2.subjectPrivateKey, "der"), { type: "dsa", params: m2.algorithm.params };
          default:
            throw new Error("unknown key id " + p2);
        }
      case "RSA PUBLIC KEY":
        return fr.RSAPublicKey.decode(f, "der");
      case "RSA PRIVATE KEY":
        return fr.RSAPrivateKey.decode(f, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: fr.DSAPrivateKey.decode(f, "der") };
      case "EC PRIVATE KEY":
        return f = fr.ECPrivateKey.decode(f, "der"), { curve: f.parameters.value, privateKey: f.privateKey };
      default:
        throw new Error("unknown key type " + o2);
    }
  }
  g3.signature = fr.signature;
  function XB(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt, o2 = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f = VB[t.algorithm.decrypt.cipher.algo.join(".")], p2 = t.algorithm.decrypt.cipher.iv, m2 = t.subjectPrivateKey, y4 = parseInt(f.split("-")[1], 10) / 8, M2 = YB.pbkdf2Sync(e, r, o2, y4, "sha1"), x3 = GB.createDecipheriv(f, M2, p2), S = [];
    return S.push(x3.update(m2)), S.push(x3.final()), vd.concat(S);
  }
});
var bd = T((bL, JB) => {
  JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var _3 = T((mL, m0) => {
  var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
  function iq(t, e, r, o2, f) {
    var p2 = tq(e);
    if (p2.curve) {
      if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return nq(t, p2);
    } else if (p2.type === "dsa") {
      if (o2 !== "dsa")
        throw new Error("wrong private key type");
      return fq(t, p2, r);
    } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = Yt.concat([f, t]);
    for (var m2 = p2.modulus.byteLength(), y3 = [0, 1];t.length + y3.length + 1 < m2; )
      y3.push(255);
    y3.push(0);
    for (var M2 = -1;++M2 < t.length; )
      y3.push(t[M2]);
    var x3 = QB(y3, p2);
    return x3;
  }
  function nq(t, e) {
    var r = rq[e.curve.join(".")];
    if (!r)
      throw new Error("unknown curve " + e.curve.join("."));
    var o2 = new eq(r), f = o2.keyFromPrivate(e.privateKey), p2 = f.sign(t);
    return Yt.from(p2.toDER());
  }
  function fq(t, e, r) {
    for (var o2 = e.params.priv_key, f = e.params.p, p2 = e.params.q, m2 = e.params.g, y3 = new b0(0), M2, x3 = md(t, p2).mod(p2), S = false, E3 = w3(o2, p2, t, r);S === false; )
      M2 = M3(p2, E3, r), y3 = sq(m2, M2, f, p2), S = M2.invm(p2).imul(x3.add(o2.mul(y3))).mod(p2), S.cmpn(0) === 0 && (S = false, y3 = new b0(0));
    return aq(y3, S);
  }
  function aq(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r = t.length + e.length + 4, o2 = [48, r, 2, t.length];
    return o2 = o2.concat(t, [2, e.length], e), Yt.from(o2);
  }
  function w3(t, e, r, o2) {
    if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
      var f = Yt.alloc(e.byteLength() - t.length);
      t = Yt.concat([f, t]);
    }
    var p2 = r.length, m2 = oq(r, e), y3 = Yt.alloc(p2);
    y3.fill(1);
    var M2 = Yt.alloc(p2);
    return M2 = Kn(o2, M2).update(y3).update(Yt.from([0])).update(t).update(m2).digest(), y3 = Kn(o2, M2).update(y3).digest(), M2 = Kn(o2, M2).update(y3).update(Yt.from([1])).update(t).update(m2).digest(), y3 = Kn(o2, M2).update(y3).digest(), { k: M2, v: y3 };
  }
  function md(t, e) {
    var r = new b0(t), o2 = (t.length << 3) - e.bitLength();
    return o2 > 0 && r.ishrn(o2), r;
  }
  function oq(t, e) {
    t = md(t, e), t = t.mod(e);
    var r = Yt.from(t.toArray());
    if (r.length < e.byteLength()) {
      var o2 = Yt.alloc(e.byteLength() - r.length);
      r = Yt.concat([o2, r]);
    }
    return r;
  }
  function M3(t, e, r) {
    var o2, f;
    do {
      for (o2 = Yt.alloc(0);o2.length * 8 < t.bitLength(); )
        e.v = Kn(r, e.k).update(e.v).digest(), o2 = Yt.concat([o2, e.v]);
      f = md(o2, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
    } while (f.cmp(t) !== -1);
    return f;
  }
  function sq(t, e, r, o2) {
    return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o2);
  }
  m0.exports = iq;
  m0.exports.getKey = w3;
  m0.exports.makeKey = M3;
});
var A3 = T((gL, E3) => {
  var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
  function lq(t, e, r, o2, f) {
    var p2 = S3(r);
    if (p2.type === "ec") {
      if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return dq(t, e, p2);
    } else if (p2.type === "dsa") {
      if (o2 !== "dsa")
        throw new Error("wrong public key type");
      return cq(t, e, p2);
    } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = gd.concat([f, e]);
    for (var m2 = p2.modulus.byteLength(), y3 = [1], M2 = 0;e.length + y3.length + 2 < m2; )
      y3.push(255), M2++;
    y3.push(0);
    for (var x4 = -1;++x4 < e.length; )
      y3.push(e[x4]);
    y3 = gd.from(y3);
    var S = Wa.mont(p2.modulus);
    t = new Wa(t).toRed(S), t = t.redPow(new Wa(p2.publicExponent)), t = gd.from(t.fromRed().toArray());
    var E4 = M2 < 8 ? 1 : 0;
    for (m2 = Math.min(t.length, y3.length), t.length !== y3.length && (E4 = 1), x4 = -1;++x4 < m2; )
      E4 |= t[x4] ^ y3[x4];
    return E4 === 0;
  }
  function dq(t, e, r) {
    var o2 = uq[r.data.algorithm.curve.join(".")];
    if (!o2)
      throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
    var f = new hq(o2), p2 = r.data.subjectPrivateKey.data;
    return f.verify(e, t, p2);
  }
  function cq(t, e, r) {
    var o2 = r.data.p, f = r.data.q, p2 = r.data.g, m2 = r.data.pub_key, y3 = S3.signature.decode(t, "der"), M2 = y3.s, x4 = y3.r;
    x3(M2, f), x3(x4, f);
    var S = Wa.mont(o2), E4 = M2.invm(f), B = p2.toRed(S).redPow(new Wa(e).mul(E4).mod(f)).fromRed().mul(m2.toRed(S).redPow(x4.mul(E4).mod(f)).fromRed()).mod(o2).mod(f);
    return B.cmp(x4) === 0;
  }
  function x3(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  E3.exports = lq;
});
var k3 = T((yL, T3) => {
  var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
  Object.keys(jn).forEach(function(t) {
    jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
  });
  function Ka(t) {
    y0.Writable.call(this);
    var e = jn[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  I3(Ka, y0.Writable);
  Ka.prototype._write = function(e, r, o2) {
    this._hash.update(e), o2();
  };
  Ka.prototype.update = function(e, r) {
    return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
  };
  Ka.prototype.sign = function(e, r) {
    this.end();
    var o2 = this._hash.digest(), f = pq(o2, e, this._hashType, this._signType, this._tag);
    return r ? f.toString(r) : f;
  };
  function ja(t) {
    y0.Writable.call(this);
    var e = jn[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  I3(ja, y0.Writable);
  ja.prototype._write = function(e, r, o2) {
    this._hash.update(e), o2();
  };
  ja.prototype.update = function(e, r) {
    return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
  };
  ja.prototype.verify = function(e, r, o2) {
    typeof r == "string" && (r = g0.from(r, o2)), this.end();
    var f = this._hash.digest();
    return vq(r, f, e, this._signType, this._tag);
  };
  function R3(t) {
    return new Ka(t);
  }
  function B3(t) {
    return new ja(t);
  }
  T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
});
var N3 = T((L3, yd) => {
  (function(t, e) {
    function r(v5, i) {
      if (!v5)
        throw new Error(i || "Assertion failed");
    }
    function o2(v5, i) {
      v5.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v5.prototype = new a2, v5.prototype.constructor = v5;
    }
    function f(v5, i, a2) {
      if (f.isBN(v5))
        return v5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v5 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v5 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h2) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h2);
      if (typeof i == "object")
        return this._initArray(i, a2, h2);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h2) : (this._parseBase(i, a2, s), h2 === "le" && this._initArray(this.toArray(), a2, h2)));
    }, f.prototype._initNumber = function(i, a2, h2) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), a2, h2);
    }, f.prototype._initArray = function(i, a2, h2) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h2 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h2 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v5, i) {
      var a2 = v5.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y3(v5, i, a2) {
      var h2 = m2(v5, a2);
      return a2 - 1 >= i && (h2 |= m2(v5, a2 - 1) << 4), h2;
    }
    f.prototype._parseHex = function(i, a2, h2) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h2 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v5, i, a2, h2) {
      for (var s = 0, u = Math.min(v5.length, a2), c = i;c < u; c++) {
        var b3 = v5.charCodeAt(c) - 48;
        s *= h2, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h2) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h2, b3 = c % s, l2 = Math.min(c, c - b3) + h2, n = 0, d2 = h2;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h2;
      if (i === 16 || i === "hex") {
        h2 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h2 = x3[6 - l2.length] + l2 + h2 : h2 = l2 + h2, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h2 = u.toString(16) + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h2 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h2 = g2 + h2 : h2 = x3[n - g2.length] + g2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h2) {
      var s = this.byteLength(), u = h2 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h2 = 0;
      return a2 >= 4096 && (h2 += 13, a2 >>>= 13), a2 >= 64 && (h2 += 7, a2 >>>= 7), a2 >= 8 && (h2 += 4, a2 >>>= 4), a2 >= 2 && (h2 += 2, a2 >>>= 2), h2 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h2 = 0;
      return (a2 & 8191) === 0 && (h2 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h2 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h2 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h2 += 2, a2 >>>= 2), (a2 & 1) === 0 && h2++, h2;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v5) {
      for (var i = new Array(v5.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h2 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v5.words[h2] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h2 = this._zeroBits(this.words[a2]);
        if (i += h2, h2 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h2 = 0;h2 < a2.length; h2++)
        this.words[h2] = this.words[h2] & i.words[h2];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h2;
      this.length > i.length ? (a2 = this, h2 = i) : (a2 = i, h2 = this);
      for (var s = 0;s < h2.length; s++)
        this.words[s] = a2.words[s] ^ h2.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h2 = i % 26;
      this._expand(a2), h2 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h2 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h2), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h2 = i / 26 | 0, s = i % 26;
      return this._expand(h2 + 1), a2 ? this.words[h2] = this.words[h2] | 1 << s : this.words[h2] = this.words[h2] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h2, s;
      this.length > i.length ? (h2 = this, s = i) : (h2 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h2.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h2.length; c++)
        a2 = (h2.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h2.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h2 !== this)
        for (;c < h2.length; c++)
          this.words[c] = h2.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h2 = this.cmp(i);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h2 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v5, i, a2) {
      a2.negative = i.negative ^ v5.negative;
      var h2 = v5.length + i.length | 0;
      a2.length = h2, h2 = h2 - 1 | 0;
      var s = v5.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h2; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v5.length + 1);_4 <= g2; _4++) {
          var A2 = n - _4 | 0;
          s = v5.words[A2] | 0, u = i.words[_4] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h2) {
      var s = i.words, u = a2.words, c = h2.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _4 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F3 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z3 = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h2.negative = i.negative ^ a2.negative, h2.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_4, X) | 0, d2 = Math.imul(_4, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_4, Q) | 0, d2 = d2 + Math.imul(_4, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_4, te) | 0, d2 = d2 + Math.imul(_4, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_4, ie) | 0, d2 = d2 + Math.imul(_4, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F3, X), n = Math.imul(F3, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_4, fe) | 0, d2 = d2 + Math.imul(_4, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F3, Q) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_4, oe) | 0, d2 = d2 + Math.imul(_4, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F3, te) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_4, he) | 0, d2 = d2 + Math.imul(_4, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z3, X) | 0, d2 = Math.imul(Z3, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_4, le) | 0, d2 = d2 + Math.imul(_4, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z3, Q) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F3, fe) | 0, n = n + Math.imul(F3, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_4, ce2) | 0, d2 = d2 + Math.imul(_4, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F3, oe) | 0, n = n + Math.imul(F3, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_4, ve) | 0, d2 = d2 + Math.imul(_4, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F3, ce2) | 0, n = n + Math.imul(F3, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z3, ce2) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h2.length++), h2;
    };
    Math.imul || (L2 = q);
    function ge(v5, i, a2) {
      a2.negative = i.negative ^ v5.negative, a2.length = v5.length + i.length;
      for (var h2 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h2 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v5.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v5.words[d2] | 0, g2 = i.words[n] | 0, _4 = w3 * g2, A2 = _4 & 67108863;
          c = c + (_4 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h2 = c, c = s;
      }
      return h2 !== 0 ? a2.words[u] = h2 : a2.length--, a2.strip();
    }
    function _e(v5, i, a2) {
      var h2 = new N4;
      return h2.mulp(v5, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h2, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h2 = L2(this, i, a2) : s < 63 ? h2 = q(this, i, a2) : s < 1024 ? h2 = ge(this, i, a2) : h2 = _e(this, i, a2), h2;
    };
    function N4(v5, i) {
      this.x = v5, this.y = i;
    }
    N4.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h2 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h2, i);
      return a2;
    }, N4.prototype.revBin = function(i, a2, h2) {
      if (i === 0 || i === h2 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N4.prototype.permute = function(i, a2, h2, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h2[i[b3]];
    }, N4.prototype.transform = function(i, a2, h2, s, u, c) {
      this.permute(c, i, a2, h2, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _4 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h2[w3 + A2], I = s[w3 + A2], Me = h2[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _4 * k;
            k = g2 * k + _4 * Me, Me = D2, h2[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h2[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _4, _4 = n * _4 + d2 * g2, g2 = D2);
          }
    }, N4.prototype.guessLen13b = function(i, a2) {
      var h2 = Math.max(a2, i) | 1, s = h2 & 1, u = 0;
      for (h2 = h2 / 2 | 0;h2; h2 = h2 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N4.prototype.conjugate = function(i, a2, h2) {
      if (!(h2 <= 1))
        for (var s = 0;s < h2 / 2; s++) {
          var u = i[s];
          i[s] = i[h2 - s - 1], i[h2 - s - 1] = u, u = a2[s], a2[s] = -a2[h2 - s - 1], a2[h2 - s - 1] = -u;
        }
    }, N4.prototype.normalize13b = function(i, a2) {
      for (var h2 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h2;
        i[s] = u & 67108863, u < 67108864 ? h2 = 0 : h2 = u / 67108864 | 0;
      }
      return i;
    }, N4.prototype.convert13b = function(i, a2, h2, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h2[2 * c] = u & 8191, u = u >>> 13, h2[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h2[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N4.prototype.stub = function(i) {
      for (var a2 = new Array(i), h2 = 0;h2 < i; h2++)
        a2[h2] = 0;
      return a2;
    }, N4.prototype.mulp = function(i, a2, h2) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _4 = h2.words;
      _4.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _4, c, s, u), this.conjugate(_4, c, s), this.normalize13b(_4, s), h2.negative = i.negative ^ a2.negative, h2.length = i.length + a2.length, h2.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h2 = 0;h2 < this.length; h2++) {
        var s = (this.words[h2] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h2] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h2] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h2 = this, s = 0;s < a2.length && a2[s] === 0; s++, h2 = h2.sqr())
        ;
      if (++s < a2.length)
        for (var u = h2.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h2 = h2.mul(u));
      return h2;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h2 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h2] = this.words[u];
        for (u = 0;u < h2; u++)
          this.words[u] = 0;
        this.length += h2;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h2) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h2;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h2) {
      return r(this.negative === 0), this.iushrn(i, a2, h2);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return false;
      var u = this.words[h2];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (a2 !== 0 && h2++, this.length = Math.min(h2, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h2) {
      var s = i.length + h2, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h2] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h2] = c & 67108863;
      }
      for (;u < this.length - h2; u++)
        c = (this.words[u + h2] | 0) + b3, b3 = c >> 26, this.words[u + h2] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h2 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h2 = 26 - b3, h2 !== 0 && (u = u.ushln(h2), s.iushln(h2), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _4 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_4 = Math.min(_4 / c | 0, 67108863), s._ishlnsubmul(u, _4, g2);s.negative !== 0; )
          _4--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _4);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h2 !== 0 && s.iushrn(h2), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h2) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h2 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h2.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h2 = 0, s = this.length - 1;s >= 0; s--)
        h2 = (a2 * h2 + (this.words[s] | 0)) % i;
      return h2;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = (this.words[h2] | 0) + a2 * 67108864;
        this.words[h2] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h2.isEven(); )
        a2.iushrn(1), h2.iushrn(1), ++l2;
      for (var n = h2.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _4 = 0, A2 = 1;(h2.words[0] & A2) === 0 && _4 < 26; ++_4, A2 <<= 1)
          ;
        if (_4 > 0)
          for (h2.iushrn(_4);_4-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(c), u.isub(b3)) : (h2.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h2.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h2.clone();a2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h2.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h2.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(u)) : (h2.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h2 = i.clone();
      a2.negative = 0, h2.negative = 0;
      for (var s = 0;a2.isEven() && h2.isEven(); s++)
        a2.iushrn(1), h2.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h2.isEven(); )
          h2.iushrn(1);
        var u = a2.cmp(h2);
        if (u < 0) {
          var c = a2;
          a2 = h2, h2 = c;
        } else if (u === 0 || h2.cmpn(1) === 0)
          break;
        a2.isub(h2);
      } while (true);
      return h2.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= s, this;
      for (var u = s, c = h2;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h2 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = this.words[h2] | 0, u = i.words[h2] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P3(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v5, i) {
      this.name = v5, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h2 = a2.bitLength();
      while (h2 > this.n);
      var s = h2 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h2 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h2, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h2) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = i.words[h2] | 0;
        a2 += s * 977, i.words[h2] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = (i.words[h2] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h2] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P3(v5) {
      if (typeof v5 == "string") {
        var i = f._prime(v5);
        this.m = i.p, this.prime = i;
      } else
        r(v5.gtn(1), "modulus must be greater than 1"), this.m = v5, this.prime = null;
    }
    P3.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P3.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P3.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P3.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P3.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.add(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, P3.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.iadd(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, P3.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.sub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, P3.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.isub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, P3.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P3.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P3.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P3.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P3.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P3.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h2 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h2);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _4 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _4);
        var I = this.pow(d2, new f(1).iushln(_4 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _4 = R3;
      }
      return w3;
    }, P3.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P3.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h2 = 4, s = new Array(1 << h2);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h2 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P3.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P3.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v5) {
      P3.call(this, v5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P3), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h2 = i.imul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h2 = i.mul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof yd > "u" || yd, L3);
});
var P3 = T((wL, D3) => {
  var bq = o0(), mq = N3();
  D3.exports = function(e) {
    return new Zn(e);
  };
  var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  hr.p224 = hr.secp224r1;
  hr.p256 = hr.secp256r1 = hr.prime256v1;
  hr.p192 = hr.secp192r1 = hr.prime192v1;
  hr.p384 = hr.secp384r1;
  hr.p521 = hr.secp521r1;
  function Zn(t) {
    this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
  }
  Zn.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Zn.prototype.computeSecret = function(t, e, r) {
    e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
    var o2 = this.curve.keyFromPublic(t).getPublic(), f = o2.mul(this.keys.getPrivate()).getX();
    return wd(f, r, this.curveType.byteLength);
  };
  Zn.prototype.getPublicKey = function(t, e) {
    var r = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
  };
  Zn.prototype.getPrivateKey = function(t) {
    return wd(this.keys.getPrivate(), t);
  };
  Zn.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
  };
  Zn.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
    var r = new mq(t);
    return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
  };
  function wd(t, e, r) {
    Array.isArray(t) || (t = t.toArray());
    var o2 = new Buffer(t);
    if (r && o2.length < r) {
      var f = new Buffer(r - o2.length);
      f.fill(0), o2 = Buffer.concat([f, o2]);
    }
    return e ? o2.toString(e) : o2;
  }
});
var _d = T((ML, C3) => {
  var gq = bf(), Md = Te().Buffer;
  C3.exports = function(t, e) {
    for (var r = Md.alloc(0), o2 = 0, f;r.length < e; )
      f = yq(o2++), r = Md.concat([r, gq("sha1").update(t).update(f).digest()]);
    return r.slice(0, e);
  };
  function yq(t) {
    var e = Md.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var xd = T((_L, O3) => {
  O3.exports = function(e, r) {
    for (var o2 = e.length, f = -1;++f < o2; )
      e[f] ^= r[f];
    return e;
  };
});
var w0 = T((F3, Sd) => {
  (function(t, e) {
    function r(v5, i) {
      if (!v5)
        throw new Error(i || "Assertion failed");
    }
    function o2(v5, i) {
      v5.super_ = i;
      var a2 = function() {
      };
      a2.prototype = i.prototype, v5.prototype = new a2, v5.prototype.constructor = v5;
    }
    function f(v5, i, a2) {
      if (f.isBN(v5))
        return v5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, v5 !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v5 || 0, i || 10, a2 || "be"));
    }
    typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
    var p2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
    } catch {
    }
    f.isBN = function(i) {
      return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
    }, f.max = function(i, a2) {
      return i.cmp(a2) > 0 ? i : a2;
    }, f.min = function(i, a2) {
      return i.cmp(a2) < 0 ? i : a2;
    }, f.prototype._init = function(i, a2, h2) {
      if (typeof i == "number")
        return this._initNumber(i, a2, h2);
      if (typeof i == "object")
        return this._initArray(i, a2, h2);
      a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
      var s = 0;
      i[0] === "-" && (s++, this.negative = 1), s < i.length && (a2 === 16 ? this._parseHex(i, s, h2) : (this._parseBase(i, a2, s), h2 === "le" && this._initArray(this.toArray(), a2, h2)));
    }, f.prototype._initNumber = function(i, a2, h2) {
      i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h2 === "le" && this._initArray(this.toArray(), a2, h2);
    }, f.prototype._initArray = function(i, a2, h2) {
      if (r(typeof i.length == "number"), i.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u, c, b3 = 0;
      if (h2 === "be")
        for (s = i.length - 1, u = 0;s >= 0; s -= 3)
          c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      else if (h2 === "le")
        for (s = 0, u = 0;s < i.length; s += 3)
          c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
      return this.strip();
    };
    function m2(v5, i) {
      var a2 = v5.charCodeAt(i);
      return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
    }
    function y3(v5, i, a2) {
      var h2 = m2(v5, a2);
      return a2 - 1 >= i && (h2 |= m2(v5, a2 - 1) << 4), h2;
    }
    f.prototype._parseHex = function(i, a2, h2) {
      this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
      for (var s = 0;s < this.length; s++)
        this.words[s] = 0;
      var u = 0, c = 0, b3;
      if (h2 === "be")
        for (s = i.length - 1;s >= a2; s -= 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      else {
        var l2 = i.length - a2;
        for (s = l2 % 2 === 0 ? a2 + 1 : a2;s < i.length; s += 2)
          b3 = y3(i, a2, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
      }
      this.strip();
    };
    function M2(v5, i, a2, h2) {
      for (var s = 0, u = Math.min(v5.length, a2), c = i;c < u; c++) {
        var b3 = v5.charCodeAt(c) - 48;
        s *= h2, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
      }
      return s;
    }
    f.prototype._parseBase = function(i, a2, h2) {
      this.words = [0], this.length = 1;
      for (var s = 0, u = 1;u <= 67108863; u *= a2)
        s++;
      s--, u = u / a2 | 0;
      for (var c = i.length - h2, b3 = c % s, l2 = Math.min(c, c - b3) + h2, n = 0, d2 = h2;d2 < l2; d2 += s)
        n = M2(i, d2, d2 + s, a2), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      if (b3 !== 0) {
        var w3 = 1;
        for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
          w3 *= a2;
        this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
      }
      this.strip();
    }, f.prototype.copy = function(i) {
      i.words = new Array(this.length);
      for (var a2 = 0;a2 < this.length; a2++)
        i.words[a2] = this.words[a2];
      i.length = this.length, i.negative = this.negative, i.red = this.red;
    }, f.prototype.clone = function() {
      var i = new f(null);
      return this.copy(i), i;
    }, f.prototype._expand = function(i) {
      for (;this.length < i; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype.strip = function() {
      for (;this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, f.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    f.prototype.toString = function(i, a2) {
      i = i || 10, a2 = a2 | 0 || 1;
      var h2;
      if (i === 16 || i === "hex") {
        h2 = "";
        for (var s = 0, u = 0, c = 0;c < this.length; c++) {
          var b3 = this.words[c], l2 = ((b3 << s | u) & 16777215).toString(16);
          u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h2 = x3[6 - l2.length] + l2 + h2 : h2 = l2 + h2, s += 2, s >= 26 && (s -= 26, c--);
        }
        for (u !== 0 && (h2 = u.toString(16) + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      if (i === (i | 0) && i >= 2 && i <= 36) {
        var n = S[i], d2 = E3[i];
        h2 = "";
        var w3 = this.clone();
        for (w3.negative = 0;!w3.isZero(); ) {
          var g2 = w3.modn(d2).toString(i);
          w3 = w3.idivn(d2), w3.isZero() ? h2 = g2 + h2 : h2 = x3[n - g2.length] + g2 + h2;
        }
        for (this.isZero() && (h2 = "0" + h2);h2.length % a2 !== 0; )
          h2 = "0" + h2;
        return this.negative !== 0 && (h2 = "-" + h2), h2;
      }
      r(false, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var i = this.words[0];
      return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
    }, f.prototype.toJSON = function() {
      return this.toString(16);
    }, f.prototype.toBuffer = function(i, a2) {
      return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
    }, f.prototype.toArray = function(i, a2) {
      return this.toArrayLike(Array, i, a2);
    }, f.prototype.toArrayLike = function(i, a2, h2) {
      var s = this.byteLength(), u = h2 || Math.max(1, s);
      r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
      var c = a2 === "le", b3 = new i(u), l2, n, d2 = this.clone();
      if (c) {
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
        for (;n < u; n++)
          b3[n] = 0;
      } else {
        for (n = 0;n < u - s; n++)
          b3[n] = 0;
        for (n = 0;!d2.isZero(); n++)
          l2 = d2.andln(255), d2.iushrn(8), b3[u - n - 1] = l2;
      }
      return b3;
    }, Math.clz32 ? f.prototype._countBits = function(i) {
      return 32 - Math.clz32(i);
    } : f.prototype._countBits = function(i) {
      var a2 = i, h2 = 0;
      return a2 >= 4096 && (h2 += 13, a2 >>>= 13), a2 >= 64 && (h2 += 7, a2 >>>= 7), a2 >= 8 && (h2 += 4, a2 >>>= 4), a2 >= 2 && (h2 += 2, a2 >>>= 2), h2 + a2;
    }, f.prototype._zeroBits = function(i) {
      if (i === 0)
        return 26;
      var a2 = i, h2 = 0;
      return (a2 & 8191) === 0 && (h2 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h2 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h2 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h2 += 2, a2 >>>= 2), (a2 & 1) === 0 && h2++, h2;
    }, f.prototype.bitLength = function() {
      var i = this.words[this.length - 1], a2 = this._countBits(i);
      return (this.length - 1) * 26 + a2;
    };
    function B(v5) {
      for (var i = new Array(v5.bitLength()), a2 = 0;a2 < i.length; a2++) {
        var h2 = a2 / 26 | 0, s = a2 % 26;
        i[a2] = (v5.words[h2] & 1 << s) >>> s;
      }
      return i;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var i = 0, a2 = 0;a2 < this.length; a2++) {
        var h2 = this._zeroBits(this.words[a2]);
        if (i += h2, h2 !== 26)
          break;
      }
      return i;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(i) {
      return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(i) {
      return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(i) {
      for (;this.length < i.length; )
        this.words[this.length++] = 0;
      for (var a2 = 0;a2 < i.length; a2++)
        this.words[a2] = this.words[a2] | i.words[a2];
      return this.strip();
    }, f.prototype.ior = function(i) {
      return r((this.negative | i.negative) === 0), this.iuor(i);
    }, f.prototype.or = function(i) {
      return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
    }, f.prototype.uor = function(i) {
      return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
    }, f.prototype.iuand = function(i) {
      var a2;
      this.length > i.length ? a2 = i : a2 = this;
      for (var h2 = 0;h2 < a2.length; h2++)
        this.words[h2] = this.words[h2] & i.words[h2];
      return this.length = a2.length, this.strip();
    }, f.prototype.iand = function(i) {
      return r((this.negative | i.negative) === 0), this.iuand(i);
    }, f.prototype.and = function(i) {
      return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
    }, f.prototype.uand = function(i) {
      return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
    }, f.prototype.iuxor = function(i) {
      var a2, h2;
      this.length > i.length ? (a2 = this, h2 = i) : (a2 = i, h2 = this);
      for (var s = 0;s < h2.length; s++)
        this.words[s] = a2.words[s] ^ h2.words[s];
      if (this !== a2)
        for (;s < a2.length; s++)
          this.words[s] = a2.words[s];
      return this.length = a2.length, this.strip();
    }, f.prototype.ixor = function(i) {
      return r((this.negative | i.negative) === 0), this.iuxor(i);
    }, f.prototype.xor = function(i) {
      return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
    }, f.prototype.uxor = function(i) {
      return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
    }, f.prototype.inotn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = Math.ceil(i / 26) | 0, h2 = i % 26;
      this._expand(a2), h2 > 0 && a2--;
      for (var s = 0;s < a2; s++)
        this.words[s] = ~this.words[s] & 67108863;
      return h2 > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h2), this.strip();
    }, f.prototype.notn = function(i) {
      return this.clone().inotn(i);
    }, f.prototype.setn = function(i, a2) {
      r(typeof i == "number" && i >= 0);
      var h2 = i / 26 | 0, s = i % 26;
      return this._expand(h2 + 1), a2 ? this.words[h2] = this.words[h2] | 1 << s : this.words[h2] = this.words[h2] & ~(1 << s), this.strip();
    }, f.prototype.iadd = function(i) {
      var a2;
      if (this.negative !== 0 && i.negative === 0)
        return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && i.negative !== 0)
        return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
      var h2, s;
      this.length > i.length ? (h2 = this, s = i) : (h2 = i, s = this);
      for (var u = 0, c = 0;c < s.length; c++)
        a2 = (h2.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      for (;u !== 0 && c < h2.length; c++)
        a2 = (h2.words[c] | 0) + u, this.words[c] = a2 & 67108863, u = a2 >>> 26;
      if (this.length = h2.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (h2 !== this)
        for (;c < h2.length; c++)
          this.words[c] = h2.words[c];
      return this;
    }, f.prototype.add = function(i) {
      var a2;
      return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
    }, f.prototype.isub = function(i) {
      if (i.negative !== 0) {
        i.negative = 0;
        var a2 = this.iadd(i);
        return i.negative = 1, a2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
      var h2 = this.cmp(i);
      if (h2 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var s, u;
      h2 > 0 ? (s = this, u = i) : (s = i, u = this);
      for (var c = 0, b3 = 0;b3 < u.length; b3++)
        a2 = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      for (;c !== 0 && b3 < s.length; b3++)
        a2 = (s.words[b3] | 0) + c, c = a2 >> 26, this.words[b3] = a2 & 67108863;
      if (c === 0 && b3 < s.length && s !== this)
        for (;b3 < s.length; b3++)
          this.words[b3] = s.words[b3];
      return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
    }, f.prototype.sub = function(i) {
      return this.clone().isub(i);
    };
    function q(v5, i, a2) {
      a2.negative = i.negative ^ v5.negative;
      var h2 = v5.length + i.length | 0;
      a2.length = h2, h2 = h2 - 1 | 0;
      var s = v5.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l2 = c / 67108864 | 0;
      a2.words[0] = b3;
      for (var n = 1;n < h2; n++) {
        for (var d2 = l2 >>> 26, w3 = l2 & 67108863, g2 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v5.length + 1);_4 <= g2; _4++) {
          var A2 = n - _4 | 0;
          s = v5.words[A2] | 0, u = i.words[_4] | 0, c = s * u + w3, d2 += c / 67108864 | 0, w3 = c & 67108863;
        }
        a2.words[n] = w3 | 0, l2 = d2 | 0;
      }
      return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
    }
    var L2 = function(i, a2, h2) {
      var s = i.words, u = a2.words, c = h2.words, b3 = 0, l2, n, d2, w3 = s[0] | 0, g2 = w3 & 8191, _4 = w3 >>> 13, A2 = s[1] | 0, R3 = A2 & 8191, I = A2 >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt3 = s[3] | 0, C2 = nt3 & 8191, O2 = nt3 >>> 13, vt = s[4] | 0, F4 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt3 = s[6] | 0, W = mt3 & 8191, K2 = mt3 >>> 13, gt2 = s[7] | 0, j2 = gt2 & 8191, Z3 = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $2 = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t2 = u[1] | 0, Q = _t2 & 8191, ee = _t2 >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St2 = u[3] | 0, ie = St2 & 8191, ne = St2 >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At3 = u[5] | 0, oe = At3 & 8191, se = At3 >>> 13, Rt2 = u[6] | 0, he = Rt2 & 8191, ue = Rt2 >>> 13, Bt2 = u[7] | 0, le = Bt2 & 8191, de = Bt2 >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
      h2.negative = i.negative ^ a2.negative, h2.length = 19, l2 = Math.imul(g2, X), n = Math.imul(g2, J), n = n + Math.imul(_4, X) | 0, d2 = Math.imul(_4, J);
      var ft2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ft2 >>> 26) | 0, ft2 &= 67108863, l2 = Math.imul(R3, X), n = Math.imul(R3, J), n = n + Math.imul(I, X) | 0, d2 = Math.imul(I, J), l2 = l2 + Math.imul(g2, Q) | 0, n = n + Math.imul(g2, ee) | 0, n = n + Math.imul(_4, Q) | 0, d2 = d2 + Math.imul(_4, ee) | 0;
      var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D2, X) | 0, d2 = Math.imul(D2, J), l2 = l2 + Math.imul(R3, Q) | 0, n = n + Math.imul(R3, ee) | 0, n = n + Math.imul(I, Q) | 0, d2 = d2 + Math.imul(I, ee) | 0, l2 = l2 + Math.imul(g2, te) | 0, n = n + Math.imul(g2, re2) | 0, n = n + Math.imul(_4, te) | 0, d2 = d2 + Math.imul(_4, re2) | 0;
      var qe2 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l2 = Math.imul(C2, X), n = Math.imul(C2, J), n = n + Math.imul(O2, X) | 0, d2 = Math.imul(O2, J), l2 = l2 + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R3, te) | 0, n = n + Math.imul(R3, re2) | 0, n = n + Math.imul(I, te) | 0, d2 = d2 + Math.imul(I, re2) | 0, l2 = l2 + Math.imul(g2, ie) | 0, n = n + Math.imul(g2, ne) | 0, n = n + Math.imul(_4, ie) | 0, d2 = d2 + Math.imul(_4, ne) | 0;
      var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F4, X), n = Math.imul(F4, J), n = n + Math.imul(U, X) | 0, d2 = Math.imul(U, J), l2 = l2 + Math.imul(C2, Q) | 0, n = n + Math.imul(C2, ee) | 0, n = n + Math.imul(O2, Q) | 0, d2 = d2 + Math.imul(O2, ee) | 0, l2 = l2 + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re2) | 0, l2 = l2 + Math.imul(R3, ie) | 0, n = n + Math.imul(R3, ne) | 0, n = n + Math.imul(I, ie) | 0, d2 = d2 + Math.imul(I, ne) | 0, l2 = l2 + Math.imul(g2, fe) | 0, n = n + Math.imul(g2, ae) | 0, n = n + Math.imul(_4, fe) | 0, d2 = d2 + Math.imul(_4, ae) | 0;
      var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d2 = Math.imul(H2, J), l2 = l2 + Math.imul(F4, Q) | 0, n = n + Math.imul(F4, ee) | 0, n = n + Math.imul(U, Q) | 0, d2 = d2 + Math.imul(U, ee) | 0, l2 = l2 + Math.imul(C2, te) | 0, n = n + Math.imul(C2, re2) | 0, n = n + Math.imul(O2, te) | 0, d2 = d2 + Math.imul(O2, re2) | 0, l2 = l2 + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R3, fe) | 0, n = n + Math.imul(R3, ae) | 0, n = n + Math.imul(I, fe) | 0, d2 = d2 + Math.imul(I, ae) | 0, l2 = l2 + Math.imul(g2, oe) | 0, n = n + Math.imul(g2, se) | 0, n = n + Math.imul(_4, oe) | 0, d2 = d2 + Math.imul(_4, se) | 0;
      var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K2, X) | 0, d2 = Math.imul(K2, J), l2 = l2 + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F4, te) | 0, n = n + Math.imul(F4, re2) | 0, n = n + Math.imul(U, te) | 0, d2 = d2 + Math.imul(U, re2) | 0, l2 = l2 + Math.imul(C2, ie) | 0, n = n + Math.imul(C2, ne) | 0, n = n + Math.imul(O2, ie) | 0, d2 = d2 + Math.imul(O2, ne) | 0, l2 = l2 + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R3, oe) | 0, n = n + Math.imul(R3, se) | 0, n = n + Math.imul(I, oe) | 0, d2 = d2 + Math.imul(I, se) | 0, l2 = l2 + Math.imul(g2, he) | 0, n = n + Math.imul(g2, ue) | 0, n = n + Math.imul(_4, he) | 0, d2 = d2 + Math.imul(_4, ue) | 0;
      var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j2, X), n = Math.imul(j2, J), n = n + Math.imul(Z3, X) | 0, d2 = Math.imul(Z3, J), l2 = l2 + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re2) | 0, l2 = l2 + Math.imul(F4, ie) | 0, n = n + Math.imul(F4, ne) | 0, n = n + Math.imul(U, ie) | 0, d2 = d2 + Math.imul(U, ne) | 0, l2 = l2 + Math.imul(C2, fe) | 0, n = n + Math.imul(C2, ae) | 0, n = n + Math.imul(O2, fe) | 0, d2 = d2 + Math.imul(O2, ae) | 0, l2 = l2 + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R3, he) | 0, n = n + Math.imul(R3, ue) | 0, n = n + Math.imul(I, he) | 0, d2 = d2 + Math.imul(I, ue) | 0, l2 = l2 + Math.imul(g2, le) | 0, n = n + Math.imul(g2, de) | 0, n = n + Math.imul(_4, le) | 0, d2 = d2 + Math.imul(_4, de) | 0;
      var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($2, X) | 0, d2 = Math.imul($2, J), l2 = l2 + Math.imul(j2, Q) | 0, n = n + Math.imul(j2, ee) | 0, n = n + Math.imul(Z3, Q) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re2) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F4, fe) | 0, n = n + Math.imul(F4, ae) | 0, n = n + Math.imul(U, fe) | 0, d2 = d2 + Math.imul(U, ae) | 0, l2 = l2 + Math.imul(C2, oe) | 0, n = n + Math.imul(C2, se) | 0, n = n + Math.imul(O2, oe) | 0, d2 = d2 + Math.imul(O2, se) | 0, l2 = l2 + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R3, le) | 0, n = n + Math.imul(R3, de) | 0, n = n + Math.imul(I, le) | 0, d2 = d2 + Math.imul(I, de) | 0, l2 = l2 + Math.imul(g2, ce2) | 0, n = n + Math.imul(g2, pe) | 0, n = n + Math.imul(_4, ce2) | 0, d2 = d2 + Math.imul(_4, pe) | 0;
      var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d2 = Math.imul(Y2, J), l2 = l2 + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j2, te) | 0, n = n + Math.imul(j2, re2) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re2) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F4, oe) | 0, n = n + Math.imul(F4, se) | 0, n = n + Math.imul(U, oe) | 0, d2 = d2 + Math.imul(U, se) | 0, l2 = l2 + Math.imul(C2, he) | 0, n = n + Math.imul(C2, ue) | 0, n = n + Math.imul(O2, he) | 0, d2 = d2 + Math.imul(O2, ue) | 0, l2 = l2 + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R3, ce2) | 0, n = n + Math.imul(R3, pe) | 0, n = n + Math.imul(I, ce2) | 0, d2 = d2 + Math.imul(I, pe) | 0, l2 = l2 + Math.imul(g2, ve) | 0, n = n + Math.imul(g2, be) | 0, n = n + Math.imul(_4, ve) | 0, d2 = d2 + Math.imul(_4, be) | 0;
      var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re2) | 0, l2 = l2 + Math.imul(j2, ie) | 0, n = n + Math.imul(j2, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F4, he) | 0, n = n + Math.imul(F4, ue) | 0, n = n + Math.imul(U, he) | 0, d2 = d2 + Math.imul(U, ue) | 0, l2 = l2 + Math.imul(C2, le) | 0, n = n + Math.imul(C2, de) | 0, n = n + Math.imul(O2, le) | 0, d2 = d2 + Math.imul(O2, de) | 0, l2 = l2 + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce2) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R3, ve) | 0, n = n + Math.imul(R3, be) | 0, n = n + Math.imul(I, ve) | 0, d2 = d2 + Math.imul(I, be) | 0;
      var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re2), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j2, fe) | 0, n = n + Math.imul(j2, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F4, le) | 0, n = n + Math.imul(F4, de) | 0, n = n + Math.imul(U, le) | 0, d2 = d2 + Math.imul(U, de) | 0, l2 = l2 + Math.imul(C2, ce2) | 0, n = n + Math.imul(C2, pe) | 0, n = n + Math.imul(O2, ce2) | 0, d2 = d2 + Math.imul(O2, pe) | 0, l2 = l2 + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
      var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j2, oe) | 0, n = n + Math.imul(j2, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F4, ce2) | 0, n = n + Math.imul(F4, pe) | 0, n = n + Math.imul(U, ce2) | 0, d2 = d2 + Math.imul(U, pe) | 0, l2 = l2 + Math.imul(C2, ve) | 0, n = n + Math.imul(C2, be) | 0, n = n + Math.imul(O2, ve) | 0, d2 = d2 + Math.imul(O2, be) | 0;
      var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j2, he) | 0, n = n + Math.imul(j2, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F4, ve) | 0, n = n + Math.imul(F4, be) | 0, n = n + Math.imul(U, ve) | 0, d2 = d2 + Math.imul(U, be) | 0;
      var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j2, le) | 0, n = n + Math.imul(j2, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce2) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
      var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j2, ce2) | 0, n = n + Math.imul(j2, pe) | 0, n = n + Math.imul(Z3, ce2) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
      var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce2) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j2, ve) | 0, n = n + Math.imul(j2, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
      var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
      var tt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      b3 = (d2 + (n >>> 13) | 0) + (tt3 >>> 26) | 0, tt3 &= 67108863, l2 = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
      var rt3 = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
      return b3 = (d2 + (n >>> 13) | 0) + (rt3 >>> 26) | 0, rt3 &= 67108863, c[0] = ft2, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt3, c[18] = rt3, b3 !== 0 && (c[19] = b3, h2.length++), h2;
    };
    Math.imul || (L2 = q);
    function ge(v5, i, a2) {
      a2.negative = i.negative ^ v5.negative, a2.length = v5.length + i.length;
      for (var h2 = 0, s = 0, u = 0;u < a2.length - 1; u++) {
        var c = s;
        s = 0;
        for (var b3 = h2 & 67108863, l2 = Math.min(u, i.length - 1), n = Math.max(0, u - v5.length + 1);n <= l2; n++) {
          var d2 = u - n, w3 = v5.words[d2] | 0, g2 = i.words[n] | 0, _4 = w3 * g2, A2 = _4 & 67108863;
          c = c + (_4 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c = c + (A2 >>> 26) | 0, s += c >>> 26, c &= 67108863;
        }
        a2.words[u] = b3, h2 = c, c = s;
      }
      return h2 !== 0 ? a2.words[u] = h2 : a2.length--, a2.strip();
    }
    function _e(v5, i, a2) {
      var h2 = new N4;
      return h2.mulp(v5, i, a2);
    }
    f.prototype.mulTo = function(i, a2) {
      var h2, s = this.length + i.length;
      return this.length === 10 && i.length === 10 ? h2 = L2(this, i, a2) : s < 63 ? h2 = q(this, i, a2) : s < 1024 ? h2 = ge(this, i, a2) : h2 = _e(this, i, a2), h2;
    };
    function N4(v5, i) {
      this.x = v5, this.y = i;
    }
    N4.prototype.makeRBT = function(i) {
      for (var a2 = new Array(i), h2 = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
        a2[s] = this.revBin(s, h2, i);
      return a2;
    }, N4.prototype.revBin = function(i, a2, h2) {
      if (i === 0 || i === h2 - 1)
        return i;
      for (var s = 0, u = 0;u < a2; u++)
        s |= (i & 1) << a2 - u - 1, i >>= 1;
      return s;
    }, N4.prototype.permute = function(i, a2, h2, s, u, c) {
      for (var b3 = 0;b3 < c; b3++)
        s[b3] = a2[i[b3]], u[b3] = h2[i[b3]];
    }, N4.prototype.transform = function(i, a2, h2, s, u, c) {
      this.permute(c, i, a2, h2, s, u);
      for (var b3 = 1;b3 < u; b3 <<= 1)
        for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w3 = 0;w3 < u; w3 += l2)
          for (var g2 = n, _4 = d2, A2 = 0;A2 < b3; A2++) {
            var R3 = h2[w3 + A2], I = s[w3 + A2], Me = h2[w3 + A2 + b3], k = s[w3 + A2 + b3], D2 = g2 * Me - _4 * k;
            k = g2 * k + _4 * Me, Me = D2, h2[w3 + A2] = R3 + Me, s[w3 + A2] = I + k, h2[w3 + A2 + b3] = R3 - Me, s[w3 + A2 + b3] = I - k, A2 !== l2 && (D2 = n * g2 - d2 * _4, _4 = n * _4 + d2 * g2, g2 = D2);
          }
    }, N4.prototype.guessLen13b = function(i, a2) {
      var h2 = Math.max(a2, i) | 1, s = h2 & 1, u = 0;
      for (h2 = h2 / 2 | 0;h2; h2 = h2 >>> 1)
        u++;
      return 1 << u + 1 + s;
    }, N4.prototype.conjugate = function(i, a2, h2) {
      if (!(h2 <= 1))
        for (var s = 0;s < h2 / 2; s++) {
          var u = i[s];
          i[s] = i[h2 - s - 1], i[h2 - s - 1] = u, u = a2[s], a2[s] = -a2[h2 - s - 1], a2[h2 - s - 1] = -u;
        }
    }, N4.prototype.normalize13b = function(i, a2) {
      for (var h2 = 0, s = 0;s < a2 / 2; s++) {
        var u = Math.round(i[2 * s + 1] / a2) * 8192 + Math.round(i[2 * s] / a2) + h2;
        i[s] = u & 67108863, u < 67108864 ? h2 = 0 : h2 = u / 67108864 | 0;
      }
      return i;
    }, N4.prototype.convert13b = function(i, a2, h2, s) {
      for (var u = 0, c = 0;c < a2; c++)
        u = u + (i[c] | 0), h2[2 * c] = u & 8191, u = u >>> 13, h2[2 * c + 1] = u & 8191, u = u >>> 13;
      for (c = 2 * a2;c < s; ++c)
        h2[c] = 0;
      r(u === 0), r((u & -8192) === 0);
    }, N4.prototype.stub = function(i) {
      for (var a2 = new Array(i), h2 = 0;h2 < i; h2++)
        a2[h2] = 0;
      return a2;
    }, N4.prototype.mulp = function(i, a2, h2) {
      var s = 2 * this.guessLen13b(i.length, a2.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l2 = new Array(s), n = new Array(s), d2 = new Array(s), w3 = new Array(s), g2 = new Array(s), _4 = h2.words;
      _4.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a2.words, a2.length, d2, s), this.transform(b3, c, l2, n, s, u), this.transform(d2, c, w3, g2, s, u);
      for (var A2 = 0;A2 < s; A2++) {
        var R3 = l2[A2] * w3[A2] - n[A2] * g2[A2];
        n[A2] = l2[A2] * g2[A2] + n[A2] * w3[A2], l2[A2] = R3;
      }
      return this.conjugate(l2, n, s), this.transform(l2, n, _4, c, s, u), this.conjugate(_4, c, s), this.normalize13b(_4, s), h2.negative = i.negative ^ a2.negative, h2.length = i.length + a2.length, h2.strip();
    }, f.prototype.mul = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
    }, f.prototype.mulf = function(i) {
      var a2 = new f(null);
      return a2.words = new Array(this.length + i.length), _e(this, i, a2);
    }, f.prototype.imul = function(i) {
      return this.clone().mulTo(i, this);
    }, f.prototype.imuln = function(i) {
      r(typeof i == "number"), r(i < 67108864);
      for (var a2 = 0, h2 = 0;h2 < this.length; h2++) {
        var s = (this.words[h2] | 0) * i, u = (s & 67108863) + (a2 & 67108863);
        a2 >>= 26, a2 += s / 67108864 | 0, a2 += u >>> 26, this.words[h2] = u & 67108863;
      }
      return a2 !== 0 && (this.words[h2] = a2, this.length++), this;
    }, f.prototype.muln = function(i) {
      return this.clone().imuln(i);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(i) {
      var a2 = B(i);
      if (a2.length === 0)
        return new f(1);
      for (var h2 = this, s = 0;s < a2.length && a2[s] === 0; s++, h2 = h2.sqr())
        ;
      if (++s < a2.length)
        for (var u = h2.sqr();s < a2.length; s++, u = u.sqr())
          a2[s] !== 0 && (h2 = h2.mul(u));
      return h2;
    }, f.prototype.iushln = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 67108863 >>> 26 - a2 << 26 - a2, u;
      if (a2 !== 0) {
        var c = 0;
        for (u = 0;u < this.length; u++) {
          var b3 = this.words[u] & s, l2 = (this.words[u] | 0) - b3 << a2;
          this.words[u] = l2 | c, c = b3 >>> 26 - a2;
        }
        c && (this.words[u] = c, this.length++);
      }
      if (h2 !== 0) {
        for (u = this.length - 1;u >= 0; u--)
          this.words[u + h2] = this.words[u];
        for (u = 0;u < h2; u++)
          this.words[u] = 0;
        this.length += h2;
      }
      return this.strip();
    }, f.prototype.ishln = function(i) {
      return r(this.negative === 0), this.iushln(i);
    }, f.prototype.iushrn = function(i, a2, h2) {
      r(typeof i == "number" && i >= 0);
      var s;
      a2 ? s = (a2 - a2 % 26) / 26 : s = 0;
      var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l2 = h2;
      if (s -= c, s = Math.max(0, s), l2) {
        for (var n = 0;n < c; n++)
          l2.words[n] = this.words[n];
        l2.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, n = 0;n < this.length; n++)
            this.words[n] = this.words[n + c];
        else
          this.words[0] = 0, this.length = 1;
      var d2 = 0;
      for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s); n--) {
        var w3 = this.words[n] | 0;
        this.words[n] = d2 << 26 - u | w3 >>> u, d2 = w3 & b3;
      }
      return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, f.prototype.ishrn = function(i, a2, h2) {
      return r(this.negative === 0), this.iushrn(i, a2, h2);
    }, f.prototype.shln = function(i) {
      return this.clone().ishln(i);
    }, f.prototype.ushln = function(i) {
      return this.clone().iushln(i);
    }, f.prototype.shrn = function(i) {
      return this.clone().ishrn(i);
    }, f.prototype.ushrn = function(i) {
      return this.clone().iushrn(i);
    }, f.prototype.testn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return false;
      var u = this.words[h2];
      return !!(u & s);
    }, f.prototype.imaskn = function(i) {
      r(typeof i == "number" && i >= 0);
      var a2 = i % 26, h2 = (i - a2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h2)
        return this;
      if (a2 !== 0 && h2++, this.length = Math.min(h2, this.length), a2 !== 0) {
        var s = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= s;
      }
      return this.strip();
    }, f.prototype.maskn = function(i) {
      return this.clone().imaskn(i);
    }, f.prototype.iaddn = function(i) {
      return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
    }, f.prototype._iaddn = function(i) {
      this.words[0] += i;
      for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
        this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, f.prototype.isubn = function(i) {
      if (r(typeof i == "number"), r(i < 67108864), i < 0)
        return this.iaddn(-i);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(i), this.negative = 1, this;
      if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
          this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this.strip();
    }, f.prototype.addn = function(i) {
      return this.clone().iaddn(i);
    }, f.prototype.subn = function(i) {
      return this.clone().isubn(i);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(i, a2, h2) {
      var s = i.length + h2, u;
      this._expand(s);
      var c, b3 = 0;
      for (u = 0;u < i.length; u++) {
        c = (this.words[u + h2] | 0) + b3;
        var l2 = (i.words[u] | 0) * a2;
        c -= l2 & 67108863, b3 = (c >> 26) - (l2 / 67108864 | 0), this.words[u + h2] = c & 67108863;
      }
      for (;u < this.length - h2; u++)
        c = (this.words[u + h2] | 0) + b3, b3 = c >> 26, this.words[u + h2] = c & 67108863;
      if (b3 === 0)
        return this.strip();
      for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
        c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
      return this.negative = 1, this.strip();
    }, f.prototype._wordDiv = function(i, a2) {
      var h2 = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
      h2 = 26 - b3, h2 !== 0 && (u = u.ushln(h2), s.iushln(h2), c = u.words[u.length - 1] | 0);
      var l2 = s.length - u.length, n;
      if (a2 !== "mod") {
        n = new f(null), n.length = l2 + 1, n.words = new Array(n.length);
        for (var d2 = 0;d2 < n.length; d2++)
          n.words[d2] = 0;
      }
      var w3 = s.clone()._ishlnsubmul(u, 1, l2);
      w3.negative === 0 && (s = w3, n && (n.words[l2] = 1));
      for (var g2 = l2 - 1;g2 >= 0; g2--) {
        var _4 = (s.words[u.length + g2] | 0) * 67108864 + (s.words[u.length + g2 - 1] | 0);
        for (_4 = Math.min(_4 / c | 0, 67108863), s._ishlnsubmul(u, _4, g2);s.negative !== 0; )
          _4--, s.negative = 0, s._ishlnsubmul(u, 1, g2), s.isZero() || (s.negative ^= 1);
        n && (n.words[g2] = _4);
      }
      return n && n.strip(), s.strip(), a2 !== "div" && h2 !== 0 && s.iushrn(h2), { div: n || null, mod: s };
    }, f.prototype.divmod = function(i, a2, h2) {
      if (r(!i.isZero()), this.isZero())
        return { div: new f(0), mod: new f(0) };
      var s, u, c;
      return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a2), a2 !== "mod" && (s = c.div.neg()), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a2), a2 !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u = c.mod.neg(), h2 && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a2);
    }, f.prototype.div = function(i) {
      return this.divmod(i, "div", false).div;
    }, f.prototype.mod = function(i) {
      return this.divmod(i, "mod", false).mod;
    }, f.prototype.umod = function(i) {
      return this.divmod(i, "mod", true).mod;
    }, f.prototype.divRound = function(i) {
      var a2 = this.divmod(i);
      if (a2.mod.isZero())
        return a2.div;
      var h2 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s = i.ushrn(1), u = i.andln(1), c = h2.cmp(s);
      return c < 0 || u === 1 && c === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, f.prototype.modn = function(i) {
      r(i <= 67108863);
      for (var a2 = (1 << 26) % i, h2 = 0, s = this.length - 1;s >= 0; s--)
        h2 = (a2 * h2 + (this.words[s] | 0)) % i;
      return h2;
    }, f.prototype.idivn = function(i) {
      r(i <= 67108863);
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = (this.words[h2] | 0) + a2 * 67108864;
        this.words[h2] = s / i | 0, a2 = s % i;
      }
      return this.strip();
    }, f.prototype.divn = function(i) {
      return this.clone().idivn(i);
    }, f.prototype.egcd = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l2 = 0;a2.isEven() && h2.isEven(); )
        a2.iushrn(1), h2.iushrn(1), ++l2;
      for (var n = h2.clone(), d2 = a2.clone();!a2.isZero(); ) {
        for (var w3 = 0, g2 = 1;(a2.words[0] & g2) === 0 && w3 < 26; ++w3, g2 <<= 1)
          ;
        if (w3 > 0)
          for (a2.iushrn(w3);w3-- > 0; )
            (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d2)), s.iushrn(1), u.iushrn(1);
        for (var _4 = 0, A2 = 1;(h2.words[0] & A2) === 0 && _4 < 26; ++_4, A2 <<= 1)
          ;
        if (_4 > 0)
          for (h2.iushrn(_4);_4-- > 0; )
            (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d2)), c.iushrn(1), b3.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(c), u.isub(b3)) : (h2.isub(a2), c.isub(s), b3.isub(u));
      }
      return { a: c, b: b3, gcd: h2.iushln(l2) };
    }, f.prototype._invmp = function(i) {
      r(i.negative === 0), r(!i.isZero());
      var a2 = this, h2 = i.clone();
      a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
      for (var s = new f(1), u = new f(0), c = h2.clone();a2.cmpn(1) > 0 && h2.cmpn(1) > 0; ) {
        for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
          ;
        if (b3 > 0)
          for (a2.iushrn(b3);b3-- > 0; )
            s.isOdd() && s.iadd(c), s.iushrn(1);
        for (var n = 0, d2 = 1;(h2.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
          ;
        if (n > 0)
          for (h2.iushrn(n);n-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        a2.cmp(h2) >= 0 ? (a2.isub(h2), s.isub(u)) : (h2.isub(a2), u.isub(s));
      }
      var w3;
      return a2.cmpn(1) === 0 ? w3 = s : w3 = u, w3.cmpn(0) < 0 && w3.iadd(i), w3;
    }, f.prototype.gcd = function(i) {
      if (this.isZero())
        return i.abs();
      if (i.isZero())
        return this.abs();
      var a2 = this.clone(), h2 = i.clone();
      a2.negative = 0, h2.negative = 0;
      for (var s = 0;a2.isEven() && h2.isEven(); s++)
        a2.iushrn(1), h2.iushrn(1);
      do {
        for (;a2.isEven(); )
          a2.iushrn(1);
        for (;h2.isEven(); )
          h2.iushrn(1);
        var u = a2.cmp(h2);
        if (u < 0) {
          var c = a2;
          a2 = h2, h2 = c;
        } else if (u === 0 || h2.cmpn(1) === 0)
          break;
        a2.isub(h2);
      } while (true);
      return h2.iushln(s);
    }, f.prototype.invm = function(i) {
      return this.egcd(i).a.umod(i);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(i) {
      return this.words[0] & i;
    }, f.prototype.bincn = function(i) {
      r(typeof i == "number");
      var a2 = i % 26, h2 = (i - a2) / 26, s = 1 << a2;
      if (this.length <= h2)
        return this._expand(h2 + 1), this.words[h2] |= s, this;
      for (var u = s, c = h2;u !== 0 && c < this.length; c++) {
        var b3 = this.words[c] | 0;
        b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
      }
      return u !== 0 && (this.words[c] = u, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(i) {
      var a2 = i < 0;
      if (this.negative !== 0 && !a2)
        return -1;
      if (this.negative === 0 && a2)
        return 1;
      this.strip();
      var h2;
      if (this.length > 1)
        h2 = 1;
      else {
        a2 && (i = -i), r(i <= 67108863, "Number is too big");
        var s = this.words[0] | 0;
        h2 = s === i ? 0 : s < i ? -1 : 1;
      }
      return this.negative !== 0 ? -h2 | 0 : h2;
    }, f.prototype.cmp = function(i) {
      if (this.negative !== 0 && i.negative === 0)
        return -1;
      if (this.negative === 0 && i.negative !== 0)
        return 1;
      var a2 = this.ucmp(i);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, f.prototype.ucmp = function(i) {
      if (this.length > i.length)
        return 1;
      if (this.length < i.length)
        return -1;
      for (var a2 = 0, h2 = this.length - 1;h2 >= 0; h2--) {
        var s = this.words[h2] | 0, u = i.words[h2] | 0;
        if (s !== u) {
          s < u ? a2 = -1 : s > u && (a2 = 1);
          break;
        }
      }
      return a2;
    }, f.prototype.gtn = function(i) {
      return this.cmpn(i) === 1;
    }, f.prototype.gt = function(i) {
      return this.cmp(i) === 1;
    }, f.prototype.gten = function(i) {
      return this.cmpn(i) >= 0;
    }, f.prototype.gte = function(i) {
      return this.cmp(i) >= 0;
    }, f.prototype.ltn = function(i) {
      return this.cmpn(i) === -1;
    }, f.prototype.lt = function(i) {
      return this.cmp(i) === -1;
    }, f.prototype.lten = function(i) {
      return this.cmpn(i) <= 0;
    }, f.prototype.lte = function(i) {
      return this.cmp(i) <= 0;
    }, f.prototype.eqn = function(i) {
      return this.cmpn(i) === 0;
    }, f.prototype.eq = function(i) {
      return this.cmp(i) === 0;
    }, f.red = function(i) {
      return new P4(i);
    }, f.prototype.toRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
    }, f.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(i) {
      return this.red = i, this;
    }, f.prototype.forceRed = function(i) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
    }, f.prototype.redAdd = function(i) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
    }, f.prototype.redIAdd = function(i) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
    }, f.prototype.redSub = function(i) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
    }, f.prototype.redISub = function(i) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
    }, f.prototype.redShl = function(i) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
    }, f.prototype.redMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
    }, f.prototype.redIMul = function(i) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
    }, f.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(i) {
      return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
    };
    var we = { k256: null, p224: null, p192: null, p25519: null };
    function ye(v5, i) {
      this.name = v5, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ye.prototype._tmp = function() {
      var i = new f(null);
      return i.words = new Array(Math.ceil(this.n / 13)), i;
    }, ye.prototype.ireduce = function(i) {
      var a2 = i, h2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h2 = a2.bitLength();
      while (h2 > this.n);
      var s = h2 < this.n ? -1 : a2.ucmp(this.p);
      return s === 0 ? (a2.words[0] = 0, a2.length = 1) : s > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
    }, ye.prototype.split = function(i, a2) {
      i.iushrn(this.n, 0, a2);
    }, ye.prototype.imulK = function(i) {
      return i.imul(this.k);
    };
    function xe() {
      ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o2(xe, ye), xe.prototype.split = function(i, a2) {
      for (var h2 = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
        a2.words[u] = i.words[u];
      if (a2.length = s, i.length <= 9) {
        i.words[0] = 0, i.length = 1;
        return;
      }
      var c = i.words[9];
      for (a2.words[a2.length++] = c & h2, u = 10;u < i.length; u++) {
        var b3 = i.words[u] | 0;
        i.words[u - 10] = (b3 & h2) << 4 | c >>> 22, c = b3;
      }
      c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
    }, xe.prototype.imulK = function(i) {
      i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = i.words[h2] | 0;
        a2 += s * 977, i.words[h2] = a2 & 67108863, a2 = s * 64 + (a2 / 67108864 | 0);
      }
      return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
    };
    function Re() {
      ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o2(Re, ye);
    function Ee() {
      ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o2(Ee, ye);
    function Ae2() {
      ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
      for (var a2 = 0, h2 = 0;h2 < i.length; h2++) {
        var s = (i.words[h2] | 0) * 19 + a2, u = s & 67108863;
        s >>>= 26, i.words[h2] = u, a2 = s;
      }
      return a2 !== 0 && (i.words[i.length++] = a2), i;
    }, f._prime = function(i) {
      if (we[i])
        return we[i];
      var a2;
      if (i === "k256")
        a2 = new xe;
      else if (i === "p224")
        a2 = new Re;
      else if (i === "p192")
        a2 = new Ee;
      else if (i === "p25519")
        a2 = new Ae2;
      else
        throw new Error("Unknown prime " + i);
      return we[i] = a2, a2;
    };
    function P4(v5) {
      if (typeof v5 == "string") {
        var i = f._prime(v5);
        this.m = i.p, this.prime = i;
      } else
        r(v5.gtn(1), "modulus must be greater than 1"), this.m = v5, this.prime = null;
    }
    P4.prototype._verify1 = function(i) {
      r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
    }, P4.prototype._verify2 = function(i, a2) {
      r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
    }, P4.prototype.imod = function(i) {
      return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
    }, P4.prototype.neg = function(i) {
      return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
    }, P4.prototype.add = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.add(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2._forceRed(this);
    }, P4.prototype.iadd = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.iadd(a2);
      return h2.cmp(this.m) >= 0 && h2.isub(this.m), h2;
    }, P4.prototype.sub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.sub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2._forceRed(this);
    }, P4.prototype.isub = function(i, a2) {
      this._verify2(i, a2);
      var h2 = i.isub(a2);
      return h2.cmpn(0) < 0 && h2.iadd(this.m), h2;
    }, P4.prototype.shl = function(i, a2) {
      return this._verify1(i), this.imod(i.ushln(a2));
    }, P4.prototype.imul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.imul(a2));
    }, P4.prototype.mul = function(i, a2) {
      return this._verify2(i, a2), this.imod(i.mul(a2));
    }, P4.prototype.isqr = function(i) {
      return this.imul(i, i.clone());
    }, P4.prototype.sqr = function(i) {
      return this.mul(i, i);
    }, P4.prototype.sqrt = function(i) {
      if (i.isZero())
        return i.clone();
      var a2 = this.m.andln(3);
      if (r(a2 % 2 === 1), a2 === 3) {
        var h2 = this.m.add(new f(1)).iushrn(2);
        return this.pow(i, h2);
      }
      for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
        u++, s.iushrn(1);
      r(!s.isZero());
      var c = new f(1).toRed(this), b3 = c.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
      for (n = new f(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
        n.redIAdd(b3);
      for (var d2 = this.pow(n, s), w3 = this.pow(i, s.addn(1).iushrn(1)), g2 = this.pow(i, s), _4 = u;g2.cmp(c) !== 0; ) {
        for (var A2 = g2, R3 = 0;A2.cmp(c) !== 0; R3++)
          A2 = A2.redSqr();
        r(R3 < _4);
        var I = this.pow(d2, new f(1).iushln(_4 - R3 - 1));
        w3 = w3.redMul(I), d2 = I.redSqr(), g2 = g2.redMul(d2), _4 = R3;
      }
      return w3;
    }, P4.prototype.invm = function(i) {
      var a2 = i._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, P4.prototype.pow = function(i, a2) {
      if (a2.isZero())
        return new f(1).toRed(this);
      if (a2.cmpn(1) === 0)
        return i.clone();
      var h2 = 4, s = new Array(1 << h2);
      s[0] = new f(1).toRed(this), s[1] = i;
      for (var u = 2;u < s.length; u++)
        s[u] = this.mul(s[u - 1], i);
      var c = s[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
      for (n === 0 && (n = 26), u = a2.length - 1;u >= 0; u--) {
        for (var d2 = a2.words[u], w3 = n - 1;w3 >= 0; w3--) {
          var g2 = d2 >> w3 & 1;
          if (c !== s[0] && (c = this.sqr(c)), g2 === 0 && b3 === 0) {
            l2 = 0;
            continue;
          }
          b3 <<= 1, b3 |= g2, l2++, !(l2 !== h2 && (u !== 0 || w3 !== 0)) && (c = this.mul(c, s[b3]), l2 = 0, b3 = 0);
        }
        n = 26;
      }
      return c;
    }, P4.prototype.convertTo = function(i) {
      var a2 = i.umod(this.m);
      return a2 === i ? a2.clone() : a2;
    }, P4.prototype.convertFrom = function(i) {
      var a2 = i.clone();
      return a2.red = null, a2;
    }, f.mont = function(i) {
      return new Se2(i);
    };
    function Se2(v5) {
      P4.call(this, v5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o2(Se2, P4), Se2.prototype.convertTo = function(i) {
      return this.imod(i.ushln(this.shift));
    }, Se2.prototype.convertFrom = function(i) {
      var a2 = this.imod(i.mul(this.rinv));
      return a2.red = null, a2;
    }, Se2.prototype.imul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return i.words[0] = 0, i.length = 1, i;
      var h2 = i.imul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.mul = function(i, a2) {
      if (i.isZero() || a2.isZero())
        return new f(0)._forceRed(this);
      var h2 = i.mul(a2), s = h2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h2.isub(s).iushrn(this.shift), c = u;
      return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
    }, Se2.prototype.invm = function(i) {
      var a2 = this.imod(i._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(typeof Sd > "u" || Sd, F3);
});
var Ed = T((xL, z3) => {
  var U3 = w0(), wq = Te().Buffer;
  function Mq(t, e) {
    return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
  }
  z3.exports = Mq;
});
var j3 = T((SL, K3) => {
  var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr2 = Te().Buffer;
  K3.exports = function(e, r, o2) {
    var f;
    e.padding ? f = e.padding : o2 ? f = 1 : f = 4;
    var p2 = _q(e), m2;
    if (f === 4)
      m2 = Aq(p2, r);
    else if (f === 1)
      m2 = Rq(p2, r, o2);
    else if (f === 3) {
      if (m2 = new Rd(r), m2.cmp(p2.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return o2 ? Eq(m2, p2) : Sq(m2, p2);
  };
  function Aq(t, e) {
    var r = t.modulus.byteLength(), o2 = e.length, f = xq("sha1").update(Kr2.alloc(0)).digest(), p2 = f.length, m2 = 2 * p2;
    if (o2 > r - m2 - 2)
      throw new Error("message too long");
    var y3 = Kr2.alloc(r - o2 - m2 - 2), M2 = r - p2 - 1, x3 = Ad(p2), S = W3(Kr2.concat([f, y3, Kr2.alloc(1, 1), e], M2), H3(x3, M2)), E3 = W3(x3, H3(S, p2));
    return new Rd(Kr2.concat([Kr2.alloc(1), E3, S], r));
  }
  function Rq(t, e, r) {
    var o2 = e.length, f = t.modulus.byteLength();
    if (o2 > f - 11)
      throw new Error("message too long");
    var p2;
    return r ? p2 = Kr2.alloc(f - o2 - 3, 255) : p2 = Bq(f - o2 - 3), new Rd(Kr2.concat([Kr2.from([0, r ? 1 : 2]), p2, Kr2.alloc(1), e], f));
  }
  function Bq(t) {
    for (var e = Kr2.allocUnsafe(t), r = 0, o2 = Ad(t * 2), f = 0, p2;r < t; )
      f === o2.length && (o2 = Ad(t * 2), f = 0), p2 = o2[f++], p2 && (e[r++] = p2);
    return e;
  }
});
var Y3 = T((EL, G3) => {
  var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
  G3.exports = function(e, r, o2) {
    var f;
    e.padding ? f = e.padding : o2 ? f = 1 : f = 4;
    var p2 = qq(e), m2 = p2.modulus.byteLength();
    if (r.length > m2 || new $3(r).cmp(p2.modulus) >= 0)
      throw new Error("decryption error");
    var y3;
    o2 ? y3 = kq(new $3(r), p2) : y3 = Iq(r, p2);
    var M2 = Za.alloc(m2 - y3.length);
    if (y3 = Za.concat([M2, y3], m2), f === 4)
      return Lq(p2, y3);
    if (f === 1)
      return Nq(p2, y3, o2);
    if (f === 3)
      return y3;
    throw new Error("unknown padding");
  };
  function Lq(t, e) {
    var r = t.modulus.byteLength(), o2 = Tq("sha1").update(Za.alloc(0)).digest(), f = o2.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var p2 = e.slice(1, f + 1), m2 = e.slice(f + 1), y3 = V3(p2, Z3(m2, f)), M2 = V3(m2, Z3(y3, r - f - 1));
    if (Dq(o2, M2.slice(0, f)))
      throw new Error("decryption error");
    for (var x3 = f;M2[x3] === 0; )
      x3++;
    if (M2[x3++] !== 1)
      throw new Error("decryption error");
    return M2.slice(x3);
  }
  function Nq(t, e, r) {
    for (var o2 = e.slice(0, 2), f = 2, p2 = 0;e[f++] !== 0; )
      if (f >= e.length) {
        p2++;
        break;
      }
    var m2 = e.slice(2, f - 1);
    if ((o2.toString("hex") !== "0002" && !r || o2.toString("hex") !== "0001" && r) && p2++, m2.length < 8 && p2++, p2)
      throw new Error("decryption error");
    return e.slice(f);
  }
  function Dq(t, e) {
    t = Za.from(t), e = Za.from(e);
    var r = 0, o2 = t.length;
    t.length !== e.length && (r++, o2 = Math.min(t.length, e.length));
    for (var f = -1;++f < o2; )
      r += t[f] ^ e[f];
    return r;
  }
});
var X3 = T((Vn) => {
  Vn.publicEncrypt = j3();
  Vn.privateDecrypt = Y3();
  Vn.privateEncrypt = function(e, r) {
    return Vn.publicEncrypt(e, r, true);
  };
  Vn.publicDecrypt = function(e, r) {
    return Vn.privateDecrypt(e, r, true);
  };
});
var ow = T((Va) => {
  function J3() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
  function nw(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > iw || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > rw || t > e)
      throw new RangeError("offset out of range");
  }
  function fw(t, e, r) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > iw || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r || t > rw)
      throw new RangeError("buffer too small");
  }
  Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
  function Pq(t, e, r, o2) {
    if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      o2 = e, e = 0, r = t.length;
    else if (typeof r == "function")
      o2 = r, r = t.length - e;
    else if (typeof o2 != "function")
      throw new TypeError('"cb" argument must be a function');
    return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o2);
  }
  function aw(t, e, r, o2) {
    if (true) {
      var f = t.buffer, p2 = new Uint8Array(f, e, r);
      if (Bd.getRandomValues(p2), o2) {
        process.nextTick(function() {
          o2(null, t);
        });
        return;
      }
      return t;
    }
    if (o2) {
      Q3(r, function(y3, M2) {
        if (y3)
          return o2(y3);
        M2.copy(t, e), o2(null, t);
      });
      return;
    }
    var m2 = Q3(r);
    return m2.copy(t, e), t;
  }
  function Cq(t, e, r) {
    if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
  }
});
var qd = T((ke) => {
  ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
  ke.createHash = ke.Hash = bf();
  ke.createHmac = ke.Hmac = wu();
  var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
  ke.getHashes = function() {
    return Uq;
  };
  var sw = Iu();
  ke.pbkdf2 = sw.pbkdf2;
  ke.pbkdf2Sync = sw.pbkdf2Sync;
  var ui = Vm();
  ke.Cipher = ui.Cipher;
  ke.createCipher = ui.createCipher;
  ke.Cipheriv = ui.Cipheriv;
  ke.createCipheriv = ui.createCipheriv;
  ke.Decipher = ui.Decipher;
  ke.createDecipher = ui.createDecipher;
  ke.Decipheriv = ui.Decipheriv;
  ke.createDecipheriv = ui.createDecipheriv;
  ke.getCiphers = ui.getCiphers;
  ke.listCiphers = ui.listCiphers;
  var $a = hg();
  ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
  ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
  ke.getDiffieHellman = $a.getDiffieHellman;
  ke.createDiffieHellman = $a.createDiffieHellman;
  ke.DiffieHellman = $a.DiffieHellman;
  var M0 = k3();
  ke.createSign = M0.createSign;
  ke.Sign = M0.Sign;
  ke.createVerify = M0.createVerify;
  ke.Verify = M0.Verify;
  ke.createECDH = P3();
  var _0 = X3();
  ke.publicEncrypt = _0.publicEncrypt;
  ke.privateEncrypt = _0.privateEncrypt;
  ke.publicDecrypt = _0.publicDecrypt;
  ke.privateDecrypt = _0.privateDecrypt;
  var hw = ow();
  ke.randomFill = hw.randomFill;
  ke.randomFillSync = hw.randomFillSync;
  ke.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var Xt = {};
Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
ot2(Xt, rn(qd()));
var zq = rn(qd());
var Ga = "buffer";
var uw = (t) => crypto.getRandomValues(t);
var lw = () => crypto.randomUUID();
var Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
function dw() {
  return Hq;
}
var x0 = "timingSafeEqual" in crypto ? (t, e) => {
  let { byteLength: r } = t, { byteLength: o2 } = e;
  if (typeof r != "number" || typeof o2 != "number")
    throw new TypeError("Input must be an array buffer view");
  if (r !== o2)
    throw new RangeError("Input buffers must have the same length");
  return crypto.timingSafeEqual(t, e);
} : undefined;
var Id = "scryptSync" in crypto ? (t, e, r, o2) => {
  let f = crypto.scryptSync(t, e, r, o2);
  return Ga !== "buffer" ? new Buffer(f).toString(Ga) : new Buffer(f);
} : undefined;
var Td = "scryptSync" in crypto ? function(t, e, r, o2, f) {
  if (typeof o2 == "function" && (f = o2, o2 = undefined), typeof f != "function") {
    var p2 = new TypeError("callback must be a function");
    throw p2.code = "ERR_INVALID_CALLBACK", p2;
  }
  try {
    let m2 = crypto.scryptSync(t, e, r, o2);
    process.nextTick(f, null, Ga !== "buffer" ? new Buffer(m2).toString(Ga) : new Buffer(m2));
  } catch (m2) {
    throw m2;
  }
} : undefined;
x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
var cw = crypto;
var Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

// node_modules/@noble/ed25519/lib/esm/index.js
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");

class ExtendedPoint {
  constructor(x3, y3, z, t) {
    this.x = x3;
    this.y = y3;
    this.z = z;
    this.t = t;
  }
  static fromAffine(p2) {
    if (!(p2 instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p2.equals(Point.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p2.x, p2.y, _1n, mod(p2.x * p2.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p2) => p2.z));
    return points.map((p2, i) => p2.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z12 } = this;
    const { x: X2, y: Y2, z: Z22 } = other;
    const X1Z2 = mod(X1 * Z22);
    const X2Z1 = mod(X2 * Z12);
    const Y1Z2 = mod(Y1 * Z22);
    const Y2Z1 = mod(Y2 * Z12);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z12 } = this;
    const { a: a2 } = CURVE;
    const A2 = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C2 = mod(_2n * mod(Z12 * Z12));
    const D2 = mod(a2 * A2);
    const x1y1 = X1 + Y1;
    const E3 = mod(mod(x1y1 * x1y1) - A2 - B);
    const G = D2 + B;
    const F3 = G - C2;
    const H2 = D2 - B;
    const X32 = mod(E3 * F3);
    const Y32 = mod(G * H2);
    const T3 = mod(E3 * H2);
    const Z3 = mod(F3 * G);
    return new ExtendedPoint(X32, Y32, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z12, t: T1 } = this;
    const { x: X2, y: Y2, z: Z22, t: T2 } = other;
    const A2 = mod((Y1 - X1) * (Y2 + X2));
    const B = mod((Y1 + X1) * (Y2 - X2));
    const F3 = mod(B - A2);
    if (F3 === _0n)
      return this.double();
    const C2 = mod(Z12 * _2n * T2);
    const D2 = mod(T1 * _2n * Z22);
    const E3 = D2 + C2;
    const G = B + A2;
    const H2 = D2 - C2;
    const X32 = mod(E3 * F3);
    const Y32 = mod(G * H2);
    const T3 = mod(E3 * H2);
    const Z3 = mod(F3 * G);
    return new ExtendedPoint(X32, Y32, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p2 = this;
    let base = p2;
    for (let window2 = 0;window2 < windows; window2++) {
      base = p2;
      points.push(base);
      for (let i = 1;i < 2 ** (W - 1); i++) {
        base = base.add(p2);
        points.push(base);
      }
      p2 = base.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p2 = ExtendedPoint.ZERO;
    let f = ExtendedPoint.BASE;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0;window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return ExtendedPoint.normalizeZ([p2, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar(scalar, CURVE.l, false);
    const G = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n === _0n)
      return P0;
    if (this.equals(P0) || n === _1n)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p2 = P0;
    let d2 = this;
    while (n > _0n) {
      if (n & _1n)
        p2 = p2.add(d2);
      d2 = d2.double();
      n >>= _1n;
    }
    return p2;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let p2 = this.multiplyUnsafe(CURVE.l / _2n).double();
    if (CURVE.l % _2n)
      p2 = p2.add(this);
    return p2.equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ) {
    const { x: x3, y: y3, z } = this;
    const is0 = this.equals(ExtendedPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z);
    const ax = mod(x3 * invZ);
    const ay = mod(y3 * invZ);
    const zz = mod(z * invZ);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}

class RistrettoPoint {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d: d2 } = CURVE;
    const r = mod(SQRT_M1 * r0 * r0);
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D2 = mod((c - d2 * r) * mod(r + d2));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D2);
    let s_ = mod(s * r0);
    if (!edIsNegative(s_))
      s_ = mod(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt2 = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D2);
    const s22 = s * s;
    const W02 = mod((s + s) * D2);
    const W1 = mod(Nt2 * SQRT_AD_MINUS_ONE);
    const W2 = mod(_1n - s22);
    const W3 = mod(_1n + s22);
    return new ExtendedPoint(mod(W02 * W3), mod(W2 * W1), mod(W1 * W3), mod(W02 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R22 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R22));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a: a2, d: d2 } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
      throw new Error(emsg);
    const s22 = mod(s * s);
    const u1 = mod(_1n + a2 * s22);
    const u2 = mod(_1n - a2 * s22);
    const u1_2 = mod(u1 * u1);
    const u2_2 = mod(u2 * u2);
    const v5 = mod(a2 * d2 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod(v5 * u2_2));
    const Dx = mod(I * u2);
    const Dy = mod(I * Dx * v5);
    let x3 = mod((s + s) * Dx);
    if (edIsNegative(x3))
      x3 = mod(-x3);
    const y3 = mod(u1 * Dy);
    const t = mod(x3 * y3);
    if (!isValid || edIsNegative(t) || y3 === _0n)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x3, y3, _1n, t));
  }
  toRawBytes() {
    let { x: x3, y: y3, z, t } = this.ep;
    const u1 = mod(mod(z + y3) * mod(z - y3));
    const u2 = mod(x3 * y3);
    const u2sq = mod(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
    const D1 = mod(invsqrt * u1);
    const D2 = mod(invsqrt * u2);
    const zInv = mod(D1 * D2 * t);
    let D3;
    if (edIsNegative(t * zInv)) {
      let _x = mod(y3 * SQRT_M1);
      let _y = mod(x3 * SQRT_M1);
      x3 = _x;
      y3 = _y;
      D3 = mod(D1 * INVSQRT_A_MINUS_D);
    } else {
      D3 = D2;
    }
    if (edIsNegative(x3 * zInv))
      y3 = mod(-y3);
    let s = mod((z - y3) * D3);
    if (edIsNegative(s))
      s = mod(-s);
    return numberTo32BytesLE(s);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a2 = this.ep;
    const b3 = other.ep;
    const one = mod(a2.x * b3.y) === mod(a2.y * b3.x);
    const two = mod(a2.y * b3.y) === mod(a2.x * b3.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes = new WeakMap;

class Point {
  constructor(x3, y3) {
    this.x = x3;
    this.y = y3;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d: d2, P: P4 } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y3 = bytesToNumberLE(normed);
    if (strict && y3 >= P4)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y3 >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y22 = mod(y3 * y3);
    const u = mod(y22 - _1n);
    const v5 = mod(d2 * y22 + _1n);
    let { isValid, value: x3 } = uvRatio(u, v5);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x3 & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x3 = mod(-x3);
    }
    return new Point(x3, y3);
  }
  static async fromPrivateKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).point;
  }
  toRawBytes() {
    const bytes = numberTo32BytesLE(this.y);
    bytes[31] |= this.x & _1n ? 128 : 0;
    return bytes;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y: y3 } = this;
    const u = mod((_1n + y3) * invert(_1n - y3));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(mod(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);

class Signature {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes = ensureBytes(hex, 64);
    const r = Point.fromHex(bytes.slice(0, 32), false);
    const s = bytesToNumberLE(bytes.slice(32, 64));
    return new Signature(r, s);
  }
  assertValidity() {
    const { r, s } = this;
    if (!(r instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u8 = new Uint8Array(64);
    u8.set(this.r.toRawBytes());
    u8.set(numberTo32BytesLE(this.s), 32);
    return u8;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
}
function concatBytes(...arrays) {
  if (!arrays.every((a2) => a2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({ length: 256 }, (v5, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0;i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0;i < array.length; i++) {
    const j2 = i * 2;
    const hexByte = hex.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function numberTo32BytesBE(num) {
  const length = 32;
  const hex = num.toString(16).padStart(length * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes) {
  return mod(bytesToNumberLE(bytes) & MAX_255B);
}
function mod(a2, b3 = CURVE.P) {
  const res = a2 % b3;
  return res >= _0n ? res : b3 + res;
}
function invert(number, modulo = CURVE.P) {
  if (number === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a2 = mod(number, modulo);
  let b3 = modulo;
  let x3 = _0n, y3 = _1n, u = _1n, v5 = _0n;
  while (a2 !== _0n) {
    const q = b3 / a2;
    const r = b3 % a2;
    const m2 = x3 - u * q;
    const n = y3 - v5 * q;
    b3 = a2, a2 = r, x3 = u, y3 = v5, u = m2, v5 = n;
  }
  const gcd = b3;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x3, modulo);
}
function invertBatch(nums, p2 = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod(acc * num, p2);
  }, _1n);
  const inverted = invert(lastMultiplied, p2);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod(acc * tmp[i], p2);
    return mod(acc * num, p2);
  }, inverted);
  return tmp;
}
function pow2(x3, power) {
  const { P: P4 } = CURVE;
  let res = x3;
  while (power-- > _0n) {
    res *= res;
    res %= P4;
  }
  return res;
}
function pow_2_252_3(x3) {
  const { P: P4 } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x22 = x3 * x3 % P4;
  const b23 = x22 * x3 % P4;
  const b4 = pow2(b23, _2n) * b23 % P4;
  const b5 = pow2(b4, _1n) * x3 % P4;
  const b10 = pow2(b5, _5n) * b5 % P4;
  const b20 = pow2(b10, _10n) * b10 % P4;
  const b40 = pow2(b20, _20n) * b20 % P4;
  const b80 = pow2(b40, _40n) * b40 % P4;
  const b160 = pow2(b80, _80n) * b80 % P4;
  const b240 = pow2(b160, _80n) * b80 % P4;
  const b250 = pow2(b240, _10n) * b10 % P4;
  const pow_p_5_8 = pow2(b250, _2n) * x3 % P4;
  return { pow_p_5_8, b2: b23 };
}
function uvRatio(u, v5) {
  const v32 = mod(v5 * v5 * v5);
  const v7 = mod(v32 * v32 * v5);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x3 = mod(u * v32 * pow);
  const vx2 = mod(v5 * x3 * x3);
  const root1 = x3;
  const root2 = mod(x3 * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * SQRT_M1);
  if (useRoot1)
    x3 = root1;
  if (useRoot2 || noRoot)
    x3 = root2;
  if (edIsNegative(x3))
    x3 = mod(-x3);
  return { isValid: useRoot1 || useRoot2, value: x3 };
}
function invertSqrt(number) {
  return uvRatio(_1n, number);
}
function modlLE(hash) {
  return mod(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b23) {
  if (b1.length !== b23.length) {
    return false;
  }
  for (let i = 0;i < b1.length; i++) {
    if (b1[i] !== b23[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix2 = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix: prefix2, scalar, point, pointBytes };
}
var _sha512Sync;
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign2(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix: prefix2, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix2, message2));
  const R3 = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R3.toRawBytes(), pointBytes, message2));
  const s = mod(r + k * scalar, CURVE.l);
  return new Signature(R3, s).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes(message2);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
Point.BASE._setWindowSize(8);
var crypto2 = {
  node: exports_crypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : undefined
};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash) => {
    hash = ensureBytes(hash);
    if (hash.length < 40 || hash.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto2.web) {
      return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto2.node) {
      const { randomBytes } = crypto2.node;
      return new Uint8Array(randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: async (...messages) => {
    const message2 = concatBytes(...messages);
    if (crypto2.web) {
      const buffer = await crypto2.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer);
    } else if (crypto2.node) {
      return Uint8Array.from(crypto2.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n);
    return cached;
  },
  sha512Sync: undefined
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// node_modules/@digitalbazaar/ed25519-multikey/lib/validators.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
function assertKeyBytes({ bytes, expectedLength = 32, code }) {
  if (!(bytes instanceof Uint8Array)) {
    throw new TypeError('"bytes" must be a Uint8Array.');
  }
  if (bytes.length !== expectedLength) {
    const error = new Error(`"bytes" must be a ${expectedLength}-byte Uint8Array.`);
    error.name = "DataError";
    if (code) {
      error.code = code;
    }
    throw error;
  }
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js
/*!
 * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.
 */
var crypto3 = globalThis.crypto;
if (!crypto3.getRandomValues) {
  throw new Error('Browser does not provide "crypto.getRandomValues".');
}
async function generateKeyPairFromSeed(seed) {
  assertKeyBytes({
    bytes: seed,
    expectedLength: 32
  });
  const publicKey = await getPublicKey(seed);
  const secretKey = new Uint8Array(64);
  secretKey.set(seed);
  secretKey.set(publicKey, seed.length);
  return {
    publicKey,
    secretKey
  };
}
async function generateKeyPair3() {
  const seed = new Uint8Array(32);
  crypto3.getRandomValues(seed);
  const keyPair = await generateKeyPairFromSeed(seed);
  seed.fill(0);
  return keyPair;
}
async function sign3(secretKey, data) {
  return sign2(data, secretKey.slice(0, 32));
}
async function verify2(publicKey, data, signature) {
  return verify(signature, data, publicKey);
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/factory.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
var ALGORITHM = "Ed25519";
function createSigner({ id, secretKey }) {
  if (!secretKey) {
    throw new Error("A secret key is not available for signing.");
  }
  return {
    algorithm: ALGORITHM,
    id,
    async sign({ data }) {
      return sign3(secretKey, data);
    }
  };
}
function createVerifier({ id, publicKey }) {
  if (!publicKey) {
    throw new Error("A public key is not available for verifying.");
  }
  return {
    algorithm: ALGORITHM,
    id,
    async verify({ data, signature }) {
      return verify2(publicKey, data, signature);
    }
  };
}

// node_modules/base58-universal/lib/baseN.js
var _reverseAlphabets = {};
function encode3(input, alphabet, maxline) {
  if (!(input instanceof Uint8Array)) {
    throw new TypeError('"input" must be a Uint8Array.');
  }
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== undefined && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  if (input.length === 0) {
    return "";
  }
  let output = "";
  let i = 0;
  const base = alphabet.length;
  const first = alphabet.charAt(0);
  const digits = [0];
  for (i = 0;i < input.length; ++i) {
    let carry = input[i];
    for (let j2 = 0;j2 < digits.length; ++j2) {
      carry += digits[j2] << 8;
      digits[j2] = carry % base;
      carry = carry / base | 0;
    }
    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }
  for (i = 0;input[i] === 0 && i < input.length - 1; ++i) {
    output += first;
  }
  for (i = digits.length - 1;i >= 0; --i) {
    output += alphabet[digits[i]];
  }
  if (maxline) {
    const regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join(`\r
`);
  }
  return output;
}
function decode2(input, alphabet) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (input.length === 0) {
    return new Uint8Array;
  }
  let table = _reverseAlphabets[alphabet];
  if (!table) {
    table = _reverseAlphabets[alphabet] = [];
    for (let i = 0;i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  }
  input = input.replace(/\s/g, "");
  const base = alphabet.length;
  const first = alphabet.charAt(0);
  const bytes = [0];
  for (let i = 0;i < input.length; i++) {
    const value = table[input.charCodeAt(i)];
    if (value === undefined) {
      return;
    }
    let carry = value;
    for (let j2 = 0;j2 < bytes.length; ++j2) {
      carry += bytes[j2] * base;
      bytes[j2] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes.push(carry & 255);
      carry >>= 8;
    }
  }
  for (let k = 0;input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }
  return new Uint8Array(bytes.reverse());
}

// node_modules/base58-universal/lib/index.js
/*!
 * Copyright (c) 2019-2022 Digital Bazaar, Inc. All rights reserved.
 */
var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encode4(input, maxline) {
  return encode3(input, alphabet, maxline);
}
function decode3(input) {
  return decode2(input, alphabet);
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js
/*!
 * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.
 */
var ED25519_SIGNATURE_2018_V1_URL = "https://w3id.org/security/suites/ed25519-2018/v1";
var ED25519_SIGNATURE_2020_V1_URL = "https://w3id.org/security/suites/ed25519-2020/v1";
var MULTIBASE_BASE58BTC_HEADER = "z";
var MULTICODEC_PUB_HEADER = new Uint8Array([237, 1]);
var MULTICODEC_PRIV_HEADER = new Uint8Array([128, 38]);
var MULTIKEY_CONTEXT_V1_URL = "https://w3id.org/security/multikey/v1";
var PUBLIC_KEY_SIZE = 32;
var SECRET_KEY_SIZE = 32;

// node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js
/*!
 * Copyright (c) 2020-2024 Digital Bazaar, Inc. All rights reserved.
 */
function mbEncodeKeyPair({ keyPair }) {
  const result = {};
  if (keyPair.publicKey) {
    result.publicKeyMultibase = _encodeMbKey(MULTICODEC_PUB_HEADER, keyPair.publicKey);
  }
  if (keyPair.secretKey) {
    result.secretKeyMultibase = _encodeMbKey(MULTICODEC_PRIV_HEADER, keyPair.secretKey);
  }
  return result;
}
function mbDecodeKeyPair({ publicKeyMultibase, secretKeyMultibase }) {
  if (!(publicKeyMultibase && typeof publicKeyMultibase === "string" && publicKeyMultibase[0] === "z")) {
    throw new Error('"publicKeyMultibase" must be a multibase, base58-encoded string.');
  }
  const publicKeyMulticodec = decode3(publicKeyMultibase.substr(1));
  const publicKey = publicKeyMulticodec.slice(MULTICODEC_PUB_HEADER.length);
  let secretKey;
  if (secretKeyMultibase) {
    if (!(typeof secretKeyMultibase === "string" && secretKeyMultibase[0] === "z")) {
      throw new Error('"secretKeyMultibase" must be a multibase, base58-encoded string.');
    }
    const secretKeyMulticodec = decode3(secretKeyMultibase.substr(1));
    secretKey = secretKeyMulticodec.slice(MULTICODEC_PRIV_HEADER.length);
  }
  return {
    publicKey,
    secretKey
  };
}
function _encodeMbKey(header, key) {
  const mbKey = new Uint8Array(header.length + key.length);
  mbKey.set(header);
  mbKey.set(key, header.length);
  return MULTIBASE_BASE58BTC_HEADER + encode4(mbKey);
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/serialize.js
/*!
 * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.
 */
var LEGACY_SECRET_KEY_SIZE = SECRET_KEY_SIZE + PUBLIC_KEY_SIZE;
async function exportKeyPair({
  keyPair,
  secretKey,
  publicKey,
  includeContext,
  canonicalize = false
} = {}) {
  if (!(publicKey || secretKey)) {
    throw new TypeError('Export requires specifying either "publicKey" or "secretKey".');
  }
  const useSecretKey = secretKey && !!keyPair.secretKey;
  const exported = {};
  if (includeContext) {
    exported["@context"] = MULTIKEY_CONTEXT_V1_URL;
  }
  exported.id = keyPair.id;
  exported.type = "Multikey";
  exported.controller = keyPair.controller;
  if (publicKey) {
    exported.publicKeyMultibase = rawToPublicKeyMultibase(keyPair);
  }
  if (useSecretKey) {
    exported.secretKeyMultibase = rawToSecretKeyMultibase({
      ...keyPair,
      canonicalize
    });
  }
  if (keyPair.revoked) {
    exported.revoked = keyPair.revoked;
  }
  return exported;
}
async function importKeyPair({
  id,
  controller,
  secretKeyMultibase,
  publicKeyMultibase,
  revoked
}) {
  if (!publicKeyMultibase) {
    throw new TypeError('The "publicKeyMultibase" property is required.');
  }
  const {
    publicKey,
    secretKey
  } = mbDecodeKeyPair({ publicKeyMultibase, secretKeyMultibase });
  if (controller && !id) {
    id = `${controller}#${publicKeyMultibase}`;
  }
  return {
    id,
    controller,
    publicKey,
    secretKey,
    publicKeyMultibase,
    secretKeyMultibase,
    revoked
  };
}
function jwkToPublicKeyBytes({ jwk } = {}) {
  const { kty, crv, x: x3 } = jwk;
  if (kty !== "OKP") {
    throw new TypeError('"jwk.kty" must be "OKP".');
  }
  if (crv !== "Ed25519") {
    throw new TypeError('"jwk.crv" must be "Ed25519".');
  }
  if (typeof x3 !== "string") {
    throw new TypeError('"jwk.x" must be a string.');
  }
  const publicKey = decode(jwk.x);
  if (publicKey.length !== PUBLIC_KEY_SIZE) {
    throw new Error(`Invalid public key size (${publicKey.length}); ` + `expected ${PUBLIC_KEY_SIZE}.`);
  }
  return publicKey;
}
function jwkToPublicKeyMultibase({ jwk } = {}) {
  const publicKey = jwkToPublicKeyBytes({ jwk });
  const { publicKeyMultibase } = mbEncodeKeyPair({
    keyPair: { publicKey }
  });
  return publicKeyMultibase;
}
function jwkToSecretKeyBytes({ jwk } = {}) {
  const { kty, crv, d: d2 } = jwk;
  if (kty !== "OKP") {
    throw new TypeError('"jwk.kty" must be "OKP".');
  }
  if (crv !== "Ed25519") {
    throw new TypeError('"jwk.crv" must be "Ed25519".');
  }
  if (typeof d2 !== "string") {
    throw new TypeError('"jwk.d" must be a string.');
  }
  const secretKey = Uint8Array.from(decode(jwk.d));
  if (secretKey.length !== SECRET_KEY_SIZE) {
    throw new Error(`Invalid secret key size (${secretKey.length}); ` + `expected ${SECRET_KEY_SIZE}.`);
  }
  return secretKey;
}
function jwkToSecretKeyMultibase({ jwk } = {}) {
  const secretKey = jwkToSecretKeyBytes({ jwk });
  const { secretKeyMultibase } = mbEncodeKeyPair({
    keyPair: { secretKey }
  });
  return secretKeyMultibase;
}
function rawToPublicKeyMultibase({ publicKey } = {}) {
  if (publicKey.length !== PUBLIC_KEY_SIZE) {
    throw new Error(`Invalid public key size (${publicKey.length}); ` + `expected ${PUBLIC_KEY_SIZE}.`);
  }
  const { publicKeyMultibase } = mbEncodeKeyPair({
    keyPair: { publicKey }
  });
  return publicKeyMultibase;
}
function rawToSecretKeyMultibase({
  secretKey,
  canonicalize = false
} = {}) {
  if (secretKey.length !== SECRET_KEY_SIZE) {
    if (secretKey.length !== LEGACY_SECRET_KEY_SIZE) {
      throw new Error(`Invalid secret key size (${secretKey.length}); ` + `expected ${SECRET_KEY_SIZE}.`);
    }
    if (canonicalize) {
      secretKey = secretKey.subarray(0, SECRET_KEY_SIZE);
    }
  }
  const { secretKeyMultibase } = mbEncodeKeyPair({
    keyPair: { secretKey }
  });
  return secretKeyMultibase;
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslationMap.js
/*!
 * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.
 */
var keyPairTranslationMap = new Map([
  ["Ed25519VerificationKey2020", {
    contextUrl: ED25519_SIGNATURE_2020_V1_URL,
    translationFn: _translateEd25519VerificationKey2020
  }],
  ["Ed25519VerificationKey2018", {
    contextUrl: ED25519_SIGNATURE_2018_V1_URL,
    translationFn: _translateEd25519VerificationKey2018
  }]
]);
async function _translateEd25519VerificationKey2020({ keyPair }) {
  return {
    ...keyPair,
    type: "Multikey",
    "@context": MULTIKEY_CONTEXT_V1_URL,
    secretKeyMultibase: keyPair.privateKeyMultibase
  };
}
async function _translateEd25519VerificationKey2018({ keyPair }) {
  const key = {
    publicKey: decode3(keyPair.publicKeyBase58),
    secretKey: undefined
  };
  if (keyPair.privateKeyBase58) {
    key.secretKey = decode3(keyPair.privateKeyBase58);
  }
  const { publicKeyMultibase, secretKeyMultibase } = mbEncodeKeyPair({
    keyPair: key
  });
  return {
    "@context": MULTIKEY_CONTEXT_V1_URL,
    id: keyPair.id,
    type: "Multikey",
    controller: keyPair.controller,
    revoked: keyPair.revoked,
    publicKeyMultibase,
    secretKeyMultibase
  };
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslator.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
async function toMultikey({ keyPair }) {
  const translationResult = keyPairTranslationMap.get(keyPair.type);
  if (!translationResult) {
    throw new Error(`Unsupported key type "${keyPair.type}".`);
  }
  const { contextUrl, translationFn } = translationResult;
  if (!keyPair["@context"]) {
    keyPair["@context"] = contextUrl;
  }
  if (!_includesContext({ document: keyPair, contextUrl })) {
    throw new Error(`Context not supported "${keyPair["@context"]}".`);
  }
  return translationFn({ keyPair });
}
function _includesContext({ document: document2, contextUrl }) {
  const context2 = document2["@context"];
  return context2 === contextUrl || Array.isArray(context2) && context2.includes(contextUrl);
}

// node_modules/@digitalbazaar/ed25519-multikey/lib/index.js
/*!
 * Copyright (c) 2020-2023 Digital Bazaar, Inc. All rights reserved.
 */
async function generate({ id, controller, seed } = {}) {
  let key;
  if (seed) {
    key = await generateKeyPairFromSeed(seed);
  } else {
    key = await generateKeyPair3();
  }
  const { publicKeyMultibase, secretKeyMultibase } = mbEncodeKeyPair({
    keyPair: key
  });
  if (controller && !id) {
    id = `${controller}#${publicKeyMultibase}`;
  }
  const keyPair = {
    id,
    controller,
    publicKeyMultibase,
    secretKeyMultibase,
    ...key
  };
  return _createKeyPairInterface({ keyPair });
}
async function from(key) {
  let multikey = { ...key };
  if (multikey.type !== "Multikey") {
    if (multikey.publicKeyJwk) {
      return fromJwk({ jwk: multikey.publicKeyJwk, secretKey: false });
    }
    if (multikey.type) {
      multikey = await toMultikey({ keyPair: multikey });
      return _createKeyPairInterface({ keyPair: multikey });
    }
  }
  if (!multikey.type) {
    multikey.type = "Multikey";
  }
  if (!multikey["@context"]) {
    multikey["@context"] = MULTIKEY_CONTEXT_V1_URL;
  }
  _assertMultikey(multikey);
  return _createKeyPairInterface({ keyPair: multikey });
}
async function fromJwk({ jwk, secretKey = false } = {}) {
  const multikey = {
    "@context": MULTIKEY_CONTEXT_V1_URL,
    type: "Multikey",
    publicKeyMultibase: jwkToPublicKeyMultibase({ jwk })
  };
  if (secretKey && jwk.d) {
    multikey.secretKeyMultibase = jwkToSecretKeyMultibase({ jwk });
  }
  return from(multikey);
}
async function _createKeyPairInterface({ keyPair }) {
  if (!keyPair.publicKey) {
    keyPair = await importKeyPair(keyPair);
  }
  keyPair = {
    ...keyPair,
    async export({
      publicKey = true,
      secretKey = false,
      includeContext = true,
      raw = false,
      canonicalize = false
    } = {}) {
      if (raw) {
        const { publicKey: publicKey2, secretKey: secretKey2 } = keyPair;
        const result = {};
        if (publicKey2) {
          result.publicKey = publicKey2.slice();
        }
        if (secretKey2) {
          if (canonicalize && secretKey2.length > SECRET_KEY_SIZE) {
            result.secretKey = secretKey2.subarray(0, SECRET_KEY_SIZE).slice();
          }
          result.secretKey = secretKey2;
        }
        return result;
      }
      return exportKeyPair({
        keyPair,
        publicKey,
        secretKey,
        includeContext,
        canonicalize
      });
    },
    signer() {
      const { id, secretKey } = keyPair;
      return createSigner({ id, secretKey });
    },
    verifier() {
      const { id, publicKey } = keyPair;
      return createVerifier({ id, publicKey });
    }
  };
  return keyPair;
}
function _assertMultikey(key) {
  if (!(key && typeof key === "object")) {
    throw new TypeError('"key" must be an object.');
  }
  if (key.type !== "Multikey") {
    throw new Error('"key" must be a Multikey with type "Multikey".');
  }
  if (!(key["@context"] === MULTIKEY_CONTEXT_V1_URL || Array.isArray(key["@context"]) && key["@context"].includes(MULTIKEY_CONTEXT_V1_URL))) {
    throw new TypeError('"key" must be a Multikey with context ' + `"${MULTIKEY_CONTEXT_V1_URL}".`);
  }
}

// node_modules/@digitalbazaar/eddsa-2022-cryptosuite/lib/createVerifier.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
async function createVerifier2({ verificationMethod }) {
  const key = await from(verificationMethod);
  const verifier = key.verifier();
  return verifier;
}

// node_modules/@digitalbazaar/eddsa-2022-cryptosuite/lib/name.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
var name = "eddsa-2022";

// node_modules/@digitalbazaar/eddsa-2022-cryptosuite/lib/requiredAlgorithm.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */
var requiredAlgorithm = "Ed25519";

// node_modules/@digitalbazaar/eddsa-2022-cryptosuite/lib/index.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
*/
var cryptosuite = {
  canonize,
  createVerifier: createVerifier2,
  name,
  requiredAlgorithm
};

// node_modules/@digitalbazaar/data-integrity/lib/util.js
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */
var w3cDate = (date) => {
  if (date === undefined || date === null) {
    date = new Date;
  } else if (typeof date === "number" || typeof date === "string") {
    date = new Date(date);
  }
  const str = date.toISOString();
  return str.slice(0, -5) + "Z";
};
var concat2 = (b1, b23) => {
  const rval = new Uint8Array(b1.length + b23.length);
  rval.set(b1, 0);
  rval.set(b23, b1.length);
  return rval;
};

// node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js
var import_jsonld_signatures = __toESM(require_jsonld_signatures(), 1);

// node_modules/@digitalbazaar/data-integrity/lib/sha256digest-browser.js
var crypto4 = self && (self.crypto || self.msCrypto);
async function sha256digest({ string }) {
  const bytes = new TextEncoder().encode(string);
  return new Uint8Array(await crypto4.subtle.digest("SHA-256", bytes));
}

// node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js
/*!
 * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.
 */
var { suites: { LinkedDataProof } } = import_jsonld_signatures.default;
var MULTIBASE_BASE58BTC_HEADER2 = "z";
var MULTIBASE_BASE64URL_HEADER = "u";
var DATA_INTEGRITY_CONTEXT_V2 = "https://w3id.org/security/data-integrity/v2";
var DATA_INTEGRITY_CONTEXT_V1 = "https://w3id.org/security/data-integrity/v1";
var PROOF_TYPE = "DataIntegrityProof";
var VC_2_0_CONTEXT = "https://www.w3.org/ns/credentials/v2";

class DataIntegrityProof extends LinkedDataProof {
  constructor({ signer, date, cryptosuite: cryptosuite2, legacyContext = false } = {}) {
    super({ type: PROOF_TYPE });
    const {
      canonize: canonize2,
      createVerifier: createVerifier3,
      name: name2,
      requiredAlgorithm: requiredAlgorithm2,
      derive,
      createProofValue,
      createVerifyData
    } = cryptosuite2;
    if (!(createVerifier3 && typeof createVerifier3 === "function")) {
      throw new TypeError('"cryptosuite.createVerifier" must be a function.');
    }
    if (derive && typeof derive !== "function") {
      throw new TypeError('"cryptosuite.derive" must be a function.');
    }
    if (createProofValue && typeof createProofValue !== "function") {
      throw new TypeError('"cryptosuite.createProofValue" must be a function.');
    }
    if (createVerifyData && typeof createVerifyData !== "function") {
      throw new TypeError('"cryptosuite.createVerifyData" must be a function.');
    }
    this.contextUrl = DATA_INTEGRITY_CONTEXT_V2;
    if (legacyContext) {
      this.contextUrl = DATA_INTEGRITY_CONTEXT_V1;
    }
    this.canonize = canonize2;
    this.createVerifier = createVerifier3;
    this.cryptosuite = name2;
    this._cryptosuite = cryptosuite2;
    this.requiredAlgorithm = requiredAlgorithm2;
    if (date) {
      this.date = new Date(date);
      if (isNaN(this.date)) {
        throw TypeError(`"date" "${date}" is not a valid date.`);
      }
    } else if (date === null) {
      this.date = null;
    }
    const vm = _processSignatureParams({ signer, requiredAlgorithm: requiredAlgorithm2 });
    this.verificationMethod = vm.verificationMethod;
    this.signer = vm.signer;
  }
  async sign({ verifyData, proof }) {
    if (!(this.signer && typeof this.signer.sign === "function")) {
      throw new Error("A signer API has not been specified.");
    }
    const signatureBytes = await this.signer.sign({ data: verifyData });
    proof.proofValue = MULTIBASE_BASE58BTC_HEADER2 + encode4(signatureBytes);
    return proof;
  }
  async verifySignature({ verifyData, verificationMethod, proof }) {
    const verifier = await this.createVerifier({ verificationMethod });
    const isSupportedAlgorithm = Array.isArray(this.requiredAlgorithm) ? this.requiredAlgorithm.includes(verifier.algorithm) : this.requiredAlgorithm === verifier.algorithm;
    if (!isSupportedAlgorithm) {
      const supportedAlgorithms = Array.isArray(this.requiredAlgorithm) ? this.requiredAlgorithm.join(", ") : this.requiredAlgorithm;
      const messageSuffix = Array.isArray(this.requiredAlgorithm) ? `is not a supported algorithm for the cryptosuite. The supported ` + `algorithms are: "${supportedAlgorithms}".` : `does not match the required algorithm for the cryptosuite ` + `"${supportedAlgorithms}".`;
      const message2 = `The verifier's algorithm "${verifier.algorithm}" ` + `${messageSuffix}`;
      throw new Error(message2);
    }
    const { proofValue } = proof;
    if (!(proofValue && typeof proofValue === "string")) {
      throw new TypeError('The proof does not include a valid "proofValue" property.');
    }
    const multibaseHeader = proofValue[0];
    let signature;
    if (multibaseHeader === MULTIBASE_BASE58BTC_HEADER2) {
      signature = decode3(proofValue.slice(1));
    } else if (multibaseHeader === MULTIBASE_BASE64URL_HEADER) {
      signature = decode(proofValue.slice(1));
    } else {
      throw new Error("Only base58btc or base64url multibase encoding is supported.");
    }
    return verifier.verify({ data: verifyData, signature });
  }
  async createProof({ document: document2, purpose, proofSet, documentLoader }) {
    let proof;
    if (this.proof) {
      proof = { ...this.proof };
    } else {
      proof = {};
    }
    proof.type = this.type;
    let date = this.date;
    if (proof.created === undefined && date === undefined) {
      date = new Date;
    }
    if (date && typeof date !== "string") {
      date = w3cDate(date);
    }
    if (date) {
      proof.created = date;
    }
    proof.verificationMethod = this.verificationMethod;
    proof.cryptosuite = this.cryptosuite;
    proof = await this.updateProof({
      document: document2,
      proof,
      purpose,
      proofSet,
      documentLoader
    });
    proof = await purpose.update(proof, { document: document2, suite: this, documentLoader });
    let verifyData;
    if (this._cryptosuite.createVerifyData) {
      verifyData = await this._cryptosuite.createVerifyData({
        cryptosuite: this._cryptosuite,
        document: document2,
        proof,
        proofSet,
        documentLoader,
        dataIntegrityProof: this
      });
    } else {
      verifyData = await this.createVerifyData({ document: document2, proof, proofSet, documentLoader });
    }
    if (this._cryptosuite.createProofValue) {
      proof.proofValue = await this._cryptosuite.createProofValue({
        cryptosuite: this._cryptosuite,
        verifyData,
        document: document2,
        proof,
        proofSet,
        documentLoader,
        dataIntegrityProof: this
      });
    } else {
      proof = await this.sign({ verifyData, document: document2, proof, proofSet, documentLoader });
    }
    return proof;
  }
  async derive({ document: document2, purpose, proofSet, documentLoader }) {
    if (!this._cryptosuite.derive) {
      throw new Error('"cryptosuite.derive" not provided.');
    }
    return this._cryptosuite.derive({
      cryptosuite: this._cryptosuite,
      document: document2,
      purpose,
      proofSet,
      documentLoader,
      dataIntegrityProof: this
    });
  }
  async updateProof({ proof }) {
    return proof;
  }
  async verifyProof({ proof, proofSet, document: document2, documentLoader }) {
    try {
      let verifyData;
      if (this._cryptosuite.createVerifyData) {
        verifyData = await this._cryptosuite.createVerifyData({
          cryptosuite: this._cryptosuite,
          document: document2,
          proof,
          proofSet,
          documentLoader,
          dataIntegrityProof: this
        });
      } else {
        verifyData = await this.createVerifyData({ document: document2, proof, proofSet, documentLoader });
      }
      const verificationMethod = await this.getVerificationMethod({
        proof,
        documentLoader
      });
      const verified = await this.verifySignature({
        verifyData,
        verificationMethod,
        proof
      });
      if (!verified) {
        throw new Error("Invalid signature.");
      }
      return { verified: true, verificationMethod };
    } catch (error) {
      return { verified: false, error };
    }
  }
  async createVerifyData({ document: document2, proof, documentLoader }) {
    let cachedDocHash;
    const { _hashCache } = this;
    if (_hashCache && _hashCache.document === document2) {
      cachedDocHash = _hashCache.hash;
    } else {
      this._hashCache = {
        document: document2,
        hash: cachedDocHash = this.canonize(document2, { documentLoader }).then((c14nDocument) => sha256digest({ string: c14nDocument }))
      };
    }
    const [proofHash, docHash] = await Promise.all([
      this.canonizeProof(proof, { document: document2, documentLoader }).then((c14nProofOptions) => sha256digest({ string: c14nProofOptions })),
      cachedDocHash
    ]);
    return concat2(proofHash, docHash);
  }
  async getVerificationMethod({ proof, documentLoader }) {
    let { verificationMethod } = proof;
    if (typeof verificationMethod === "object") {
      verificationMethod = verificationMethod.id;
    }
    if (!verificationMethod) {
      throw new Error('No "verificationMethod" found in proof.');
    }
    const result = await documentLoader(verificationMethod);
    if (!result) {
      throw new Error(`Unable to load verification method "${verificationMethod}".`);
    }
    const { document: document2 } = result;
    verificationMethod = typeof document2 === "string" ? JSON.parse(document2) : document2;
    return verificationMethod;
  }
  async canonizeProof(proof, { documentLoader, document: document2 }) {
    proof = {
      "@context": document2["@context"],
      ...proof
    };
    this.ensureSuiteContext({ document: proof, addSuiteContext: true });
    delete proof.proofValue;
    return this.canonize(proof, { documentLoader, skipExpansion: false });
  }
  async matchProof({
    proof
  }) {
    const { type, cryptosuite: cryptosuite2 } = proof;
    return type === this.type && cryptosuite2 === this.cryptosuite;
  }
  ensureSuiteContext({ document: document2, addSuiteContext }) {
    const { contextUrl } = this;
    if (_includesContext2({ document: document2, contextUrl }) || _includesContext2({ document: document2, contextUrl: VC_2_0_CONTEXT })) {
      return;
    }
    if (!addSuiteContext) {
      throw new TypeError(`The document to be signed must contain this suite's @context, ` + `"${contextUrl}".`);
    }
    const existingContext = document2["@context"] || [];
    document2["@context"] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];
  }
}
function _includesContext2({ document: document2, contextUrl }) {
  const context2 = document2["@context"];
  return context2 === contextUrl || Array.isArray(context2) && context2.includes(contextUrl);
}
function _processSignatureParams({ signer, requiredAlgorithm: requiredAlgorithm2 }) {
  const vm = {
    verificationMethod: undefined,
    signer: undefined
  };
  if (!signer) {
    return vm;
  }
  if (typeof signer.sign !== "function") {
    throw new TypeError("A signer API has not been specified.");
  }
  const isSupportedAlgorithm = Array.isArray(requiredAlgorithm2) ? requiredAlgorithm2.includes(signer.algorithm) : requiredAlgorithm2 === signer.algorithm;
  if (!isSupportedAlgorithm) {
    const supportedAlgorithms = Array.isArray(requiredAlgorithm2) ? requiredAlgorithm2.join(", ") : requiredAlgorithm2;
    const messageSuffix = Array.isArray(requiredAlgorithm2) ? `is not a supported algorithm for the cryptosuite. The supported ` + `algorithms are: "${supportedAlgorithms}".` : `does not match the required algorithm for the cryptosuite ` + `"${supportedAlgorithms}".`;
    const message2 = `The signer's algorithm "${signer.algorithm}" ` + `${messageSuffix}`;
    throw new Error(message2);
  }
  vm.signer = signer;
  vm.verificationMethod = signer.id;
  return vm;
}

// node_modules/@digitalbazaar/data-integrity/lib/index.js
/*!
 * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.
 */

// src/controller/index.ts
var import_data_integrity_context = __toESM(require_js2(), 1);

// node_modules/@inrupt/solid-client/dist/interfaces.mjs
function hasResourceInfo(resource) {
  const potentialResourceInfo = resource;
  return typeof potentialResourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo === "object";
}
function hasServerResourceInfo(resource) {
  const potentialResourceInfo = resource;
  return typeof potentialResourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo === "object" && typeof potentialResourceInfo.internal_resourceInfo.linkedResources === "object";
}
function hasChangelog(dataset) {
  const potentialChangeLog = dataset;
  return typeof potentialChangeLog.internal_changeLog === "object" && Array.isArray(potentialChangeLog.internal_changeLog.additions) && Array.isArray(potentialChangeLog.internal_changeLog.deletions);
}

class SolidClientError extends Error {
}

// node_modules/@inrupt/solid-client/dist/interfaces.internal.mjs
function internal_toIriString(iri) {
  return typeof iri === "string" ? iri : iri.value;
}
function normalizeUrl(inputUrl, options = {}) {
  const normalizedUrl = new URL(inputUrl);
  normalizedUrl.pathname = normalizedUrl.pathname.replace(/\/\/+/g, "/");
  if (options.trailingSlash === false && normalizedUrl.pathname.slice(-1) === "/") {
    normalizedUrl.pathname = normalizedUrl.pathname.slice(0, normalizedUrl.pathname.length - 1);
  }
  if (options.trailingSlash === true && normalizedUrl.pathname.slice(-1) !== "/") {
    normalizedUrl.pathname = `${normalizedUrl.pathname}/`;
  }
  return normalizedUrl.href;
}

// node_modules/@inrupt/solid-client/dist/resource/resource.internal.mjs
var import_http_link_header = __toESM(require_link(), 1);
function internal_parseResourceInfo(response) {
  var _a, _b, _c, _d2, _e;
  const contentTypeParts = (_b = (_a = response.headers.get("Content-Type")) === null || _a === undefined ? undefined : _a.split(";")) !== null && _b !== undefined ? _b : [];
  const isSolidDataset = contentTypeParts.length > 0 && ["text/turtle", "application/ld+json"].includes(contentTypeParts[0]);
  const resourceInfo = {
    sourceIri: response.url,
    isRawData: !isSolidDataset,
    contentLocation: (_c = response.headers.get("Content-Location")) !== null && _c !== undefined ? _c : undefined,
    contentType: (_d2 = response.headers.get("Content-Type")) !== null && _d2 !== undefined ? _d2 : undefined,
    linkedResources: {},
    location: (_e = response.headers.get("Location")) !== null && _e !== undefined ? _e : undefined
  };
  const linkHeader = response.headers.get("Link");
  if (linkHeader) {
    const parsedLinks = import_http_link_header.default.parse(linkHeader);
    const aclLinks = parsedLinks.get("rel", "acl");
    if (aclLinks.length === 1) {
      resourceInfo.aclUrl = new URL(aclLinks[0].uri, resourceInfo.sourceIri).href;
    }
    resourceInfo.linkedResources = parsedLinks.refs.reduce((rels, ref) => {
      var _a2;
      var _b2;
      (_a2 = rels[_b2 = ref.rel]) !== null && _a2 !== undefined || (rels[_b2] = []);
      rels[ref.rel].push(new URL(ref.uri, resourceInfo.sourceIri).href);
      return rels;
    }, resourceInfo.linkedResources);
  }
  const wacAllowHeader = response.headers.get("WAC-Allow");
  if (wacAllowHeader) {
    resourceInfo.permissions = parseWacAllowHeader(wacAllowHeader);
  }
  return resourceInfo;
}
function parseWacAllowHeader(wacAllowHeader) {
  function parsePermissionStatement(permissionStatement) {
    const permissions = permissionStatement.split(" ");
    const writePermission = permissions.includes("write");
    return writePermission ? {
      read: permissions.includes("read"),
      append: true,
      write: true,
      control: permissions.includes("control")
    } : {
      read: permissions.includes("read"),
      append: permissions.includes("append"),
      write: false,
      control: permissions.includes("control")
    };
  }
  function getStatementFor(header, scope) {
    const relevantEntries = header.split(",").map((rawEntry) => rawEntry.split("=")).filter((parts) => parts.length === 2 && parts[0].trim() === scope);
    if (relevantEntries.length !== 1) {
      return "";
    }
    const relevantStatement = relevantEntries[0][1].trim();
    if (relevantStatement.charAt(0) !== '"' || relevantStatement.charAt(relevantStatement.length - 1) !== '"') {
      return "";
    }
    return relevantStatement.substring(1, relevantStatement.length - 1);
  }
  return {
    user: parsePermissionStatement(getStatementFor(wacAllowHeader, "user")),
    public: parsePermissionStatement(getStatementFor(wacAllowHeader, "public"))
  };
}
function internal_cloneResource(resource) {
  let clonedResource;
  if (typeof resource.slice === "function") {
    clonedResource = Object.assign(resource.slice(), { ...resource });
  } else {
    clonedResource = { ...resource };
  }
  return clonedResource;
}
function internal_isUnsuccessfulResponse(response) {
  return !response.ok;
}
function internal_isAuthenticationFailureResponse(response) {
  return response.status === 401 || response.status === 403;
}

// node_modules/@inrupt/solid-client/dist/constants.mjs
var acl = {
  Authorization: "http://www.w3.org/ns/auth/acl#Authorization",
  AuthenticatedAgent: "http://www.w3.org/ns/auth/acl#AuthenticatedAgent",
  accessTo: "http://www.w3.org/ns/auth/acl#accessTo",
  agent: "http://www.w3.org/ns/auth/acl#agent",
  agentGroup: "http://www.w3.org/ns/auth/acl#agentGroup",
  agentClass: "http://www.w3.org/ns/auth/acl#agentClass",
  default: "http://www.w3.org/ns/auth/acl#default",
  defaultForNew: "http://www.w3.org/ns/auth/acl#defaultForNew",
  mode: "http://www.w3.org/ns/auth/acl#mode",
  origin: "http://www.w3.org/ns/auth/acl#origin"
};
var rdf3 = {
  type: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
};
var ldp = {
  BasicContainer: "http://www.w3.org/ns/ldp#BasicContainer",
  Container: "http://www.w3.org/ns/ldp#Container",
  Resource: "http://www.w3.org/ns/ldp#Resource",
  contains: "http://www.w3.org/ns/ldp#contains"
};
var foaf = {
  Agent: "http://xmlns.com/foaf/0.1/Agent",
  primaryTopic: "http://xmlns.com/foaf/0.1/primaryTopic",
  isPrimaryTopicOf: "http://xmlns.com/foaf/0.1/isPrimaryTopicOf"
};
var acp = {
  AccessControlResource: "http://www.w3.org/ns/solid/acp#AccessControlResource",
  Policy: "http://www.w3.org/ns/solid/acp#Policy",
  AccessControl: "http://www.w3.org/ns/solid/acp#AccessControl",
  Read: "http://www.w3.org/ns/solid/acp#Read",
  Append: "http://www.w3.org/ns/solid/acp#Append",
  Write: "http://www.w3.org/ns/solid/acp#Write",
  Rule: "http://www.w3.org/ns/solid/acp#Rule",
  Matcher: "http://www.w3.org/ns/solid/acp#Matcher",
  accessControl: "http://www.w3.org/ns/solid/acp#accessControl",
  memberAccessControl: "http://www.w3.org/ns/solid/acp#memberAccessControl",
  apply: "http://www.w3.org/ns/solid/acp#apply",
  applyMembers: "http://www.w3.org/ns/solid/acp#applyMembers",
  allow: "http://www.w3.org/ns/solid/acp#allow",
  deny: "http://www.w3.org/ns/solid/acp#deny",
  allOf: "http://www.w3.org/ns/solid/acp#allOf",
  anyOf: "http://www.w3.org/ns/solid/acp#anyOf",
  noneOf: "http://www.w3.org/ns/solid/acp#noneOf",
  access: "http://www.w3.org/ns/solid/acp#access",
  accessMembers: "http://www.w3.org/ns/solid/acp#accessMembers",
  agent: "http://www.w3.org/ns/solid/acp#agent",
  group: "http://www.w3.org/ns/solid/acp#group",
  client: "http://www.w3.org/ns/solid/acp#client",
  PublicAgent: "http://www.w3.org/ns/solid/acp#PublicAgent",
  AuthenticatedAgent: "http://www.w3.org/ns/solid/acp#AuthenticatedAgent",
  CreatorAgent: "http://www.w3.org/ns/solid/acp#CreatorAgent"
};

// node_modules/@inrupt/solid-client/dist/resource/resource.mjs
async function getResourceInfo(url, options) {
  var _a, _b;
  const response = await ((_a = options === null || options === undefined ? undefined : options.fetch) !== null && _a !== undefined ? _a : fetch)(normalizeUrl(url), {
    method: "HEAD"
  });
  return responseToResourceInfo(response, {
    ignoreAuthenticationErrors: (_b = options === null || options === undefined ? undefined : options.ignoreAuthenticationErrors) !== null && _b !== undefined ? _b : false
  });
}
function responseToResourceInfo(response, options = { ignoreAuthenticationErrors: false }) {
  if (internal_isUnsuccessfulResponse(response) && (!internal_isAuthenticationFailureResponse(response) || !options.ignoreAuthenticationErrors)) {
    throw new FetchError(`Fetching the metadata of the Resource at [${response.url}] failed: [${response.status}] [${response.statusText}].`, response);
  }
  const resourceInfo = internal_parseResourceInfo(response);
  return { internal_resourceInfo: resourceInfo };
}
function getContentType(resource) {
  var _a;
  return (_a = resource.internal_resourceInfo.contentType) !== null && _a !== undefined ? _a : null;
}
function getSourceUrl(resource) {
  if (hasResourceInfo(resource)) {
    return resource.internal_resourceInfo.sourceIri;
  }
  return null;
}
var getSourceIri = getSourceUrl;
function getLinkedResourceUrlAll(resource) {
  return resource.internal_resourceInfo.linkedResources;
}
class FetchError extends SolidClientError {
  get statusCode() {
    return this.response.status;
  }
  get statusText() {
    return this.response.statusText;
  }
  constructor(message2, errorResponse) {
    super(message2);
    this.response = errorResponse;
  }
}

// node_modules/@inrupt/solid-client/dist/formats/turtle.mjs
var getTurtleParser = () => {
  const onQuadCallbacks = [];
  const onCompleteCallbacks = [];
  const onErrorCallbacks = [];
  return {
    onQuad: (callback) => {
      onQuadCallbacks.push(callback);
    },
    onError: (callback) => {
      onErrorCallbacks.push(callback);
    },
    onComplete: (callback) => {
      onCompleteCallbacks.push(callback);
    },
    parse: (source, resourceInfo) => {
      getParser(getSourceUrl(resourceInfo)).parse(source, (error, quad2) => {
        if (error) {
          onErrorCallbacks.forEach((callback) => callback(error));
        } else if (quad2) {
          onQuadCallbacks.forEach((callback) => callback(quad2));
        } else {
          onCompleteCallbacks.forEach((callback) => callback());
        }
      });
    }
  };
};
function getParser(baseIri) {
  return new N3Parser({ format: "text/turtle", baseIRI: baseIri });
}
async function triplesToTurtle(quads, options) {
  const format = "text/turtle";
  const writer = new N3Writer({ format, prefixes: options === null || options === undefined ? undefined : options.prefixes });
  const triples = quads.map((quad2) => N3DataFactory_default.quad(quad2.subject, quad2.predicate, quad2.object, undefined));
  writer.addQuads(triples);
  const writePromise = new Promise((resolve, reject) => {
    writer.end((error, result) => {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    });
  });
  const rawTurtle = await writePromise;
  return rawTurtle;
}

// node_modules/@inrupt/solid-client/dist/rdf.internal.mjs
var localNodeSkolemPrefix = "https://inrupt.com/.well-known/sdk-local-node/";
var { freeze } = Object;
function isLocalNodeIri(iri) {
  return iri.substring(0, localNodeSkolemPrefix.length) === localNodeSkolemPrefix;
}
function getLocalNodeName(localNodeIri) {
  return localNodeIri.substring(localNodeSkolemPrefix.length);
}
function getLocalNodeIri(localNodeName) {
  return `${localNodeSkolemPrefix}${localNodeName}`;
}
function isBlankNodeId(value) {
  return typeof value === "string" && value.substring(0, 2) === "_:";
}
function getBlankNodeValue(blankNodeId) {
  return blankNodeId.substring(2);
}
function getBlankNodeId(blankNode2) {
  return `_:${blankNode2.value}`;
}

// node_modules/@inrupt/solid-client/dist/datatypes.mjs
var xmlSchemaTypes = {
  boolean: "http://www.w3.org/2001/XMLSchema#boolean",
  dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
  date: "http://www.w3.org/2001/XMLSchema#date",
  time: "http://www.w3.org/2001/XMLSchema#time",
  decimal: "http://www.w3.org/2001/XMLSchema#decimal",
  integer: "http://www.w3.org/2001/XMLSchema#integer",
  string: "http://www.w3.org/2001/XMLSchema#string",
  langString: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"
};
function serializeBoolean(value) {
  return value ? "true" : "false";
}
function deserializeBoolean(value) {
  if (value === "true" || value === "1") {
    return true;
  }
  if (value === "false" || value === "0") {
    return false;
  }
  return null;
}
function serializeTime(value) {
  let millisecondString;
  let timezoneString;
  if (value.millisecond) {
    if (value.millisecond < 10) {
      millisecondString = `00${value.millisecond}`;
    } else if (value.millisecond < 100) {
      millisecondString = `0${value.millisecond}`;
    } else {
      millisecondString = value.millisecond;
    }
  }
  if (typeof value.timezoneHourOffset === "number") {
    const timezoneFormatted = Math.abs(value.timezoneHourOffset) < 10 ? `0${Math.abs(value.timezoneHourOffset)}` : Math.abs(value.timezoneHourOffset);
    timezoneString = value.timezoneHourOffset >= 0 ? `+${timezoneFormatted}` : `-${timezoneFormatted}`;
    if (value.timezoneMinuteOffset) {
      timezoneString = `${timezoneString}:${value.timezoneMinuteOffset < 10 ? `0${value.timezoneMinuteOffset}` : value.timezoneMinuteOffset}`;
    } else {
      timezoneString += ":00";
    }
  }
  return `${value.hour < 10 ? `0${value.hour}` : value.hour}:${value.minute < 10 ? `0${value.minute}` : value.minute}:${value.second < 10 ? `0${value.second}` : value.second}${value.millisecond ? `.${millisecondString}` : ""}${timezoneString || ""}`;
}
function deserializeTime(literalString) {
  const timeRegEx = /\d\d:\d\d:\d\d(\.\d+)?(Z|(\+|-)\d\d:\d\d)?/;
  if (!timeRegEx.test(literalString)) {
    return null;
  }
  const [timeString, timezoneString] = splitTimeFromTimezone(literalString);
  const [hourString, minuteString, timeRest] = timeString.split(":");
  let utcHours = Number.parseInt(hourString, 10);
  let utcMinutes = Number.parseInt(minuteString, 10);
  const [secondString, optionalMillisecondString] = timeRest.split(".");
  const utcSeconds = Number.parseInt(secondString, 10);
  const utcMilliseconds = optionalMillisecondString ? Number.parseInt(optionalMillisecondString, 10) : undefined;
  if (utcMinutes >= 60) {
    utcHours += 1;
    utcMinutes -= 60;
  }
  const deserializedTime = {
    hour: utcHours,
    minute: utcMinutes,
    second: utcSeconds
  };
  if (typeof utcMilliseconds === "number") {
    deserializedTime.millisecond = utcMilliseconds;
  }
  if (typeof timezoneString === "string") {
    const [hourOffset, minuteOffset] = getTimezoneOffsets(timezoneString);
    if (typeof hourOffset !== "number" || hourOffset > 24 || typeof minuteOffset !== "number" || minuteOffset > 59) {
      return null;
    }
    deserializedTime.timezoneHourOffset = hourOffset;
    deserializedTime.timezoneMinuteOffset = minuteOffset;
  }
  return deserializedTime;
}
function serializeDatetime(value) {
  return value.toISOString();
}
function deserializeDatetime(literalString) {
  const datetimeRegEx = /-?\d{4,}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(Z|(\+|-)\d\d:\d\d)?/;
  if (!datetimeRegEx.test(literalString)) {
    return null;
  }
  const [signedDateString, rest] = literalString.split("T");
  const [yearMultiplier, dateString] = signedDateString.charAt(0) === "-" ? [-1, signedDateString.substring(1)] : [1, signedDateString];
  const [yearString, monthString, dayString] = dateString.split("-");
  const utcFullYear = Number.parseInt(yearString, 10) * yearMultiplier;
  const utcMonth = Number.parseInt(monthString, 10) - 1;
  const utcDate = Number.parseInt(dayString, 10);
  const [timeString, timezoneString] = splitTimeFromTimezone(rest);
  const [hourOffset, minuteOffset] = typeof timezoneString === "string" ? getTimezoneOffsets(timezoneString) : [0, 0];
  const [hourString, minuteString, timeRest] = timeString.split(":");
  const utcHours = Number.parseInt(hourString, 10) + hourOffset;
  const utcMinutes = Number.parseInt(minuteString, 10) + minuteOffset;
  const [secondString, optionalMillisecondString] = timeRest.split(".");
  const utcSeconds = Number.parseInt(secondString, 10);
  const utcMilliseconds = optionalMillisecondString ? Number.parseInt(optionalMillisecondString, 10) : 0;
  const date = new Date(Date.UTC(utcFullYear, utcMonth, utcDate, utcHours, utcMinutes, utcSeconds, utcMilliseconds));
  if (utcFullYear >= 0 && utcFullYear < 100) {
    date.setUTCFullYear(date.getUTCFullYear() - 1900);
  }
  return date;
}
function serializeDate(value) {
  const year2 = value.getFullYear();
  const month = value.getMonth() + 1;
  const day2 = value.getDate();
  const [, timezone] = splitTimeFromTimezone(value.toISOString());
  return `${year2}-${String(month).padStart(2, "0")}-${String(day2).padStart(2, "0")}${timezone}`;
}
function deserializeDate(literalString) {
  const dateRegEx = /-?\d{4,}-\d\d-\d\d(Z|(\+|-)\d\d:\d\d)?/;
  if (!dateRegEx.test(literalString)) {
    return null;
  }
  const signedDateString = literalString;
  const [yearMultiplier, dateString] = signedDateString.charAt(0) === "-" ? [-1, signedDateString.substring(1)] : [1, signedDateString];
  const [yearString, monthString, dayAndTimezoneString] = dateString.split("-");
  const dayString = dayAndTimezoneString.length > 2 ? dayAndTimezoneString.substring(0, 2) : dayAndTimezoneString;
  const utcFullYear = Number.parseInt(yearString, 10) * yearMultiplier;
  const utcMonth = Number.parseInt(monthString, 10) - 1;
  const utcDate = Number.parseInt(dayString, 10);
  const hour2 = 12;
  const date = new Date(Date.UTC(utcFullYear, utcMonth, utcDate, hour2));
  if (utcFullYear >= 0 && utcFullYear < 100) {
    date.setUTCFullYear(date.getUTCFullYear() - 1900);
  }
  return date;
}
function splitTimeFromTimezone(timeString) {
  if (timeString.endsWith("Z")) {
    return [timeString.substring(0, timeString.length - 1), "Z"];
  }
  const splitOnPlus = timeString.split("+");
  const splitOnMinus = timeString.split("-");
  if (splitOnPlus.length === 1 && splitOnMinus.length === 1) {
    return [splitOnPlus[0], undefined];
  }
  return splitOnPlus.length > splitOnMinus.length ? [splitOnPlus[0], `+${splitOnPlus[1]}`] : [splitOnMinus[0], `-${splitOnMinus[1]}`];
}
function getTimezoneOffsets(timezoneString) {
  if (timezoneString === "Z") {
    return [0, 0];
  }
  const multiplier = timezoneString.charAt(0) === "+" ? 1 : -1;
  const [hourString, minuteString] = timezoneString.substring(1).split(":");
  const hours = Number.parseInt(hourString, 10);
  const minutes = Number.parseInt(minuteString, 10);
  return [hours * multiplier, minutes * multiplier];
}
function serializeDecimal(value) {
  return value.toString();
}
function deserializeDecimal(literalString) {
  const deserialized = Number.parseFloat(literalString);
  if (Number.isNaN(deserialized)) {
    return null;
  }
  return deserialized;
}
function serializeInteger(value) {
  return value.toString();
}
function deserializeInteger(literalString) {
  const deserialized = Number.parseInt(literalString, 10);
  if (Number.isNaN(deserialized)) {
    return null;
  }
  return deserialized;
}
function normalizeLocale(locale) {
  return locale.toLowerCase();
}
function isNamedNode2(value) {
  return isTerm(value) && value.termType === "NamedNode";
}
function isLiteral2(value) {
  return isTerm(value) && value.termType === "Literal";
}
function isTerm(value) {
  return value !== null && typeof value === "object" && typeof value.termType === "string" && typeof value.value === "string" && typeof value.equals === "function";
}
function isLocalNode(value) {
  return isNamedNode2(value) && isLocalNodeIri(value.value);
}
function internal_isValidUrl(iri) {
  const iriString = internal_toIriString(iri);
  if (typeof URL !== "function") {
    return true;
  }
  try {
    new URL(iriString);
    return true;
  } catch (_a) {
    return false;
  }
}
function resolveIriForLocalNode(localNode, resourceIri) {
  return N3DataFactory_default.namedNode(resolveLocalIri(getLocalNodeName(localNode.value), resourceIri));
}
function resolveLocalIri(name2, resourceIri) {
  if (typeof URL !== "function") {
    throw new Error("The URL interface is not available, so an IRI cannot be determined.");
  }
  const thingIri = new URL(resourceIri);
  thingIri.hash = name2;
  return thingIri.href;
}

// node_modules/@inrupt/solid-client/dist/rdfjs.internal.mjs
function addRdfJsQuadToDataset(dataset, quad2, quadParseOptions = {}) {
  var _a;
  const supportedGraphTypes = [
    "NamedNode",
    "DefaultGraph"
  ];
  if (!supportedGraphTypes.includes(quad2.graph.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.graph.termType}] as their Graph node.`);
  }
  const graphId = quad2.graph.termType === "DefaultGraph" ? "default" : quad2.graph.value;
  const graph = (_a = dataset.graphs[graphId]) !== null && _a !== undefined ? _a : {};
  return freeze({
    ...dataset,
    graphs: freeze({
      ...dataset.graphs,
      [graphId]: addRdfJsQuadToGraph(graph, quad2, quadParseOptions)
    })
  });
}
function addRdfJsQuadToGraph(graph, quad2, quadParseOptions) {
  var _a;
  const supportedSubjectTypes = [
    "NamedNode",
    "BlankNode"
  ];
  if (!supportedSubjectTypes.includes(quad2.subject.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.subject.termType}] as their Subject node.`);
  }
  const subjectIri = quad2.subject.termType === "BlankNode" ? `_:${quad2.subject.value}` : quad2.subject.value;
  const subject = (_a = graph[subjectIri]) !== null && _a !== undefined ? _a : {
    type: "Subject",
    url: subjectIri,
    predicates: {}
  };
  return freeze({
    ...graph,
    [subjectIri]: addRdfJsQuadToSubject(subject, quad2, quadParseOptions)
  });
}
function addRdfJsQuadToSubject(subject, quad2, quadParseOptions) {
  return freeze({
    ...subject,
    predicates: addRdfJsQuadToPredicates(subject.predicates, quad2, quadParseOptions)
  });
}
function addRdfJsQuadToPredicates(predicates, quad2, quadParseOptions) {
  var _a;
  const supportedPredicateTypes = [
    "NamedNode"
  ];
  if (!supportedPredicateTypes.includes(quad2.predicate.termType)) {
    throw new Error(`Cannot parse Quads with nodes of type [${quad2.predicate.termType}] as their Predicate node.`);
  }
  const predicateIri = quad2.predicate.value;
  const objects = (_a = predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  return freeze({
    ...predicates,
    [predicateIri]: addRdfJsQuadToObjects(objects, quad2, quadParseOptions)
  });
}
function addRdfJsQuadToObjects(objects, quad2, quadParseOptions) {
  var _a, _b, _c, _d2, _e, _f, _g, _h;
  if (quad2.object.termType === "NamedNode") {
    const namedNodes = freeze([
      ...(_a = objects.namedNodes) !== null && _a !== undefined ? _a : [],
      quad2.object.value
    ]);
    return freeze({
      ...objects,
      namedNodes
    });
  }
  if (quad2.object.termType === "Literal") {
    if (quad2.object.datatype.value === xmlSchemaTypes.langString) {
      const locale = quad2.object.language.toLowerCase();
      const thisLocaleStrings = freeze([
        ...(_c = (_b = objects.langStrings) === null || _b === undefined ? undefined : _b[locale]) !== null && _c !== undefined ? _c : [],
        quad2.object.value
      ]);
      const langStrings = freeze({
        ...(_d2 = objects.langStrings) !== null && _d2 !== undefined ? _d2 : {},
        [locale]: thisLocaleStrings
      });
      return freeze({
        ...objects,
        langStrings
      });
    }
    const thisTypeValues = freeze([
      ...(_f = (_e = objects.literals) === null || _e === undefined ? undefined : _e[quad2.object.datatype.value]) !== null && _f !== undefined ? _f : [],
      quad2.object.value
    ]);
    const literals = freeze({
      ...(_g = objects.literals) !== null && _g !== undefined ? _g : {},
      [quad2.object.datatype.value]: thisTypeValues
    });
    return freeze({
      ...objects,
      literals
    });
  }
  if (quad2.object.termType === "BlankNode") {
    const blankNodePredicates = getPredicatesForBlankNode(quad2.object, quadParseOptions);
    const blankNodes = freeze([
      ...(_h = objects.blankNodes) !== null && _h !== undefined ? _h : [],
      blankNodePredicates
    ]);
    return freeze({
      ...objects,
      blankNodes
    });
  }
  throw new Error(`Objects of type [${quad2.object.termType}] are not supported.`);
}
function getPredicatesForBlankNode(node, quadParseOptions) {
  var _a, _b;
  const chainBlankNodes = (_a = quadParseOptions.chainBlankNodes) !== null && _a !== undefined ? _a : [];
  if (chainBlankNodes.find((chainBlankNode) => chainBlankNode.equals(node)) === undefined) {
    return getBlankNodeId(node);
  }
  const quads = (_b = quadParseOptions.otherQuads) !== null && _b !== undefined ? _b : [];
  const quadsWithNodeAsSubject = quads.filter((quad2) => quad2.subject.equals(node));
  const predicates = quadsWithNodeAsSubject.filter((quad2) => !isBlankNode2(quad2.object)).reduce((predicatesAcc, quad2) => {
    var _a2;
    const supportedPredicateTypes = [
      "NamedNode"
    ];
    if (!supportedPredicateTypes.includes(quad2.predicate.termType)) {
      throw new Error(`Cannot parse Quads with nodes of type [${quad2.predicate.termType}] as their Predicate node.`);
    }
    const objects = (_a2 = predicatesAcc[quad2.predicate.value]) !== null && _a2 !== undefined ? _a2 : {};
    return freeze({
      ...predicatesAcc,
      [quad2.predicate.value]: addRdfJsQuadToObjects(objects, quad2, quadParseOptions)
    });
  }, {});
  const blankNodeObjectQuads = quadsWithNodeAsSubject.filter((quad2) => isBlankNode2(quad2.object));
  return blankNodeObjectQuads.reduce((predicatesAcc, quad2) => {
    var _a2, _b2;
    const supportedPredicateTypes = [
      "NamedNode"
    ];
    if (!supportedPredicateTypes.includes(quad2.predicate.termType)) {
      throw new Error(`Cannot parse Quads with nodes of type [${quad2.predicate.termType}] as their Predicate node.`);
    }
    const objects = (_a2 = predicatesAcc[quad2.predicate.value]) !== null && _a2 !== undefined ? _a2 : {};
    const blankNodes = (_b2 = objects.blankNodes) !== null && _b2 !== undefined ? _b2 : [];
    return freeze({
      ...predicatesAcc,
      [quad2.predicate.value]: {
        ...objects,
        blankNodes: [
          ...blankNodes,
          getPredicatesForBlankNode(quad2.object, quadParseOptions)
        ]
      }
    });
  }, predicates);
}
function getChainBlankNodes(quads) {
  const blankNodeSubjects = quads.map((quad2) => quad2.subject).filter(isBlankNode2);
  const blankNodeObjects = quads.map((quad2) => quad2.object).filter(isBlankNode2);
  function everyNodeTheSame(nodes) {
    return nodes.every((otherNode) => nodes.every((anotherNode) => otherNode.equals(anotherNode)));
  }
  const cycleBlankNodes = [];
  blankNodeObjects.forEach((blankNodeObject) => {
    cycleBlankNodes.push(...getCycleBlankNodes(blankNodeObject, quads));
  });
  const chainBlankNodes = blankNodeSubjects.concat(blankNodeObjects).filter((blankNode2) => {
    if (cycleBlankNodes.some((cycleBlankNode) => cycleBlankNode.equals(blankNode2))) {
      return false;
    }
    const subjectsWithThisNodeAsObject = quads.filter((quad2) => quad2.object.equals(blankNode2)).map((quad2) => quad2.subject);
    return subjectsWithThisNodeAsObject.length > 0 && everyNodeTheSame(subjectsWithThisNodeAsObject);
  });
  return chainBlankNodes;
}
function toRdfJsQuads(dataset, options = {}) {
  var _a;
  const quads = [];
  const dataFactory = (_a = options.dataFactory) !== null && _a !== undefined ? _a : N3DataFactory_default;
  Object.keys(dataset.graphs).forEach((graphIri) => {
    const graph = dataset.graphs[graphIri];
    const graphNode = graphIri === "default" ? dataFactory.defaultGraph() : dataFactory.namedNode(graphIri);
    Object.keys(graph).forEach((subjectIri) => {
      const { predicates } = graph[subjectIri];
      const subjectNode = isBlankNodeId(subjectIri) ? dataFactory.blankNode(getBlankNodeValue(subjectIri)) : dataFactory.namedNode(subjectIri);
      quads.push(...subjectToRdfJsQuads(predicates, subjectNode, graphNode, options));
    });
  });
  return quads;
}
function subjectToRdfJsQuads(predicates, subjectNode, graphNode, options = {}) {
  var _a;
  const quads = [];
  const dataFactory = (_a = options.dataFactory) !== null && _a !== undefined ? _a : N3DataFactory_default;
  Object.keys(predicates).forEach((predicateIri) => {
    var _a2, _b, _c, _d2;
    const predicateNode = dataFactory.namedNode(predicateIri);
    const langStrings = (_a2 = predicates[predicateIri].langStrings) !== null && _a2 !== undefined ? _a2 : {};
    const namedNodes = (_b = predicates[predicateIri].namedNodes) !== null && _b !== undefined ? _b : [];
    const literals = (_c = predicates[predicateIri].literals) !== null && _c !== undefined ? _c : {};
    const blankNodes = (_d2 = predicates[predicateIri].blankNodes) !== null && _d2 !== undefined ? _d2 : [];
    const literalTypes = Object.keys(literals);
    literalTypes.forEach((typeIri) => {
      const typeNode = dataFactory.namedNode(typeIri);
      const literalValues = literals[typeIri];
      literalValues.forEach((value) => {
        const literalNode = dataFactory.literal(value, typeNode);
        quads.push(dataFactory.quad(subjectNode, predicateNode, literalNode, graphNode));
      });
    });
    const locales = Object.keys(langStrings);
    locales.forEach((locale) => {
      const localeValues = langStrings[locale];
      localeValues.forEach((value) => {
        const langStringNode = dataFactory.literal(value, locale);
        quads.push(dataFactory.quad(subjectNode, predicateNode, langStringNode, graphNode));
      });
    });
    namedNodes.forEach((namedNodeIri) => {
      const node = dataFactory.namedNode(namedNodeIri);
      quads.push(dataFactory.quad(subjectNode, predicateNode, node, graphNode));
    });
    blankNodes.forEach((blankNodeIdOrPredicates) => {
      if (isBlankNodeId(blankNodeIdOrPredicates)) {
        const blankNode2 = dataFactory.blankNode(getBlankNodeValue(blankNodeIdOrPredicates));
        quads.push(dataFactory.quad(subjectNode, predicateNode, blankNode2, graphNode));
      } else {
        const node = dataFactory.blankNode();
        const blankNodeObjectQuad = dataFactory.quad(subjectNode, predicateNode, node, graphNode);
        const blankNodeSubjectQuads = subjectToRdfJsQuads(blankNodeIdOrPredicates, node, graphNode);
        quads.push(blankNodeObjectQuad);
        quads.push(...blankNodeSubjectQuads);
      }
    });
  });
  return quads;
}
function getCycleBlankNodes(currentNode, quads, traversedBlankNodes = []) {
  if (traversedBlankNodes.find((traversedBlankNode) => traversedBlankNode.equals(currentNode)) !== undefined) {
    return traversedBlankNodes;
  }
  const blankNodeObjects = quads.filter((quad2) => quad2.subject.equals(currentNode) && isBlankNode2(quad2.object)).map((quad2) => quad2.object);
  if (blankNodeObjects.length === 0) {
    return [];
  }
  const nextTraversedNodes = [...traversedBlankNodes, currentNode];
  const cycleBlankNodeArrays = blankNodeObjects.map((nextNode) => getCycleBlankNodes(nextNode, quads, nextTraversedNodes));
  const allCycleBlankNodes = [];
  for (const cycleBlankNodes of cycleBlankNodeArrays) {
    allCycleBlankNodes.push(...cycleBlankNodes);
  }
  return allCycleBlankNodes;
}
function isBlankNode2(term) {
  return term.termType === "BlankNode";
}
// node_modules/@inrupt/solid-client/dist/resource/file.mjs
var RESERVED_HEADERS = ["Slug", "If-None-Match", "Content-Type"];
function containsReserved(header) {
  return RESERVED_HEADERS.some((reserved) => header[reserved] !== undefined);
}
async function overwriteFile(fileUrl, file, options) {
  const fileUrlString = internal_toIriString(fileUrl);
  const response = await writeFile(fileUrlString, file, "PUT", options);
  if (internal_isUnsuccessfulResponse(response)) {
    throw new FetchError(`Overwriting the file at [${fileUrlString}] failed: [${response.status}] [${response.statusText}] ${await response.text()}.`, response);
  }
  const blobClone = internal_cloneResource(file);
  const resourceInfo = internal_parseResourceInfo(response);
  resourceInfo.sourceIri = fileUrlString;
  resourceInfo.isRawData = true;
  return Object.assign(blobClone, { internal_resourceInfo: resourceInfo });
}
function isHeadersArray(headers) {
  return Array.isArray(headers);
}
function hasHeadersObjectForEach(headers) {
  return typeof headers.forEach === "function";
}
function flattenHeaders(headersToFlatten) {
  if (typeof headersToFlatten === "undefined") {
    return {};
  }
  let flatHeaders = {};
  if (isHeadersArray(headersToFlatten)) {
    headersToFlatten.forEach(([key, value]) => {
      flatHeaders[key] = value;
    });
  } else if (hasHeadersObjectForEach(headersToFlatten)) {
    headersToFlatten.forEach((value, key) => {
      flatHeaders[key] = value;
    });
  } else {
    flatHeaders = headersToFlatten;
  }
  return flatHeaders;
}
async function writeFile(targetUrl, file, method, options = {}) {
  var _a, _b, _c;
  const headers = flattenHeaders((_b = (_a = options.init) === null || _a === undefined ? undefined : _a.headers) !== null && _b !== undefined ? _b : {});
  if (containsReserved(headers)) {
    throw new Error(`No reserved header (${RESERVED_HEADERS.join(", ")}) should be set in the optional RequestInit.`);
  }
  if (options.slug !== undefined) {
    headers.Slug = options.slug;
  } else if ("name" in file && file.name !== undefined) {
    headers.Slug = file.name;
  }
  headers["Content-Type"] = getContentType2(file, options.contentType);
  return ((_c = options.fetch) !== null && _c !== undefined ? _c : fetch)(targetUrl, {
    ...options.init,
    headers,
    method,
    body: file
  });
}
function getContentType2(file, contentTypeOverride) {
  if (typeof contentTypeOverride === "string") {
    return contentTypeOverride;
  }
  const fileType = typeof file === "object" && file !== null && "type" in file && typeof file.type === "string" && file.type.length > 0 ? file.type : undefined;
  return fileType !== null && fileType !== undefined ? fileType : "application/octet-stream";
}
// node_modules/@inrupt/solid-client/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues2;
var rnds82 = new Uint8Array(16);
function rng2() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds82);
}

// node_modules/@inrupt/solid-client/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex2 = [];
for (let i = 0;i < 256; ++i) {
  byteToHex2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify2(arr, offset = 0) {
  return byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]];
}

// node_modules/@inrupt/solid-client/node_modules/uuid/dist/esm-browser/native.js
var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default2 = {
  randomUUID: randomUUID2
};

// node_modules/@inrupt/solid-client/node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  if (native_default2.randomUUID && !buf && !options) {
    return native_default2.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0;i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
var v4_default2 = v42;
// node_modules/@inrupt/solid-client/dist/thing/thing.internal.mjs
function internal_getReadableValue(value) {
  var _a, _b, _c, _d2, _e, _f, _g, _h;
  if (isNamedNode2(value)) {
    return `<${value.value}> (URL)`;
  }
  if (isLiteral2(value)) {
    if (!isNamedNode2(value.datatype)) {
      return `[${value.value}] (RDF/JS Literal of unknown type)`;
    }
    let val;
    switch (value.datatype.value) {
      case xmlSchemaTypes.boolean:
        val = (_b = (_a = deserializeBoolean(value.value)) === null || _a === undefined ? undefined : _a.valueOf()) !== null && _b !== undefined ? _b : `Invalid data: \`${value.value}\``;
        return `${val} (boolean)`;
      case xmlSchemaTypes.dateTime:
        val = (_d2 = (_c = deserializeDatetime(value.value)) === null || _c === undefined ? undefined : _c.toUTCString()) !== null && _d2 !== undefined ? _d2 : `Invalid data: \`${value.value}\``;
        return `${val} (datetime)`;
      case xmlSchemaTypes.decimal:
        val = (_f = (_e = deserializeDecimal(value.value)) === null || _e === undefined ? undefined : _e.toString()) !== null && _f !== undefined ? _f : `Invalid data: \`${value.value}\``;
        return `${val} (decimal)`;
      case xmlSchemaTypes.integer:
        val = (_h = (_g = deserializeInteger(value.value)) === null || _g === undefined ? undefined : _g.toString()) !== null && _h !== undefined ? _h : `Invalid data: \`${value.value}\``;
        return `${val} (integer)`;
      case xmlSchemaTypes.langString:
        return `"${value.value}" (${value.language} string)`;
      case xmlSchemaTypes.string:
        return `"${value.value}" (string)`;
      default:
        return `[${value.value}] (RDF/JS Literal of type: \`${value.datatype.value}\`)`;
    }
  }
  if (value.termType === "BlankNode") {
    return `[${value.value}] (RDF/JS BlankNode)`;
  }
  if (value.termType === "Quad") {
    return `??? (nested RDF* Quad)`;
  }
  if (value.termType === "Variable") {
    return `?${value.value} (RDF/JS Variable)`;
  }
  return value;
}
function internal_throwIfNotThing(thing) {
  if (!isThing(thing)) {
    throw new ThingExpectedError(thing);
  }
}
function internal_addAdditionsToChangeLog(solidDataset, additions) {
  const changeLog = hasChangelog(solidDataset) ? solidDataset.internal_changeLog : { additions: [], deletions: [] };
  const [newAdditions, newDeletions] = additions.filter((addition) => !containsBlankNode(addition)).reduce(([additionsAcc, deletionsAcc], addition) => {
    const existingDeletion = deletionsAcc.find((deletion) => deletion.equals(addition));
    if (typeof existingDeletion !== "undefined") {
      return [
        additionsAcc,
        deletionsAcc.filter((deletion) => !deletion.equals(addition))
      ];
    }
    return [additionsAcc.concat(addition), deletionsAcc];
  }, [changeLog.additions, changeLog.deletions]);
  return freeze({
    ...solidDataset,
    internal_changeLog: {
      additions: newAdditions,
      deletions: newDeletions
    }
  });
}
function internal_addDeletionsToChangeLog(solidDataset, deletions) {
  const changeLog = hasChangelog(solidDataset) ? solidDataset.internal_changeLog : { additions: [], deletions: [] };
  const [newAdditions, newDeletions] = deletions.filter((deletion) => !containsBlankNode(deletion)).reduce(([additionsAcc, deletionsAcc], deletion) => {
    const existingAddition = additionsAcc.find((addition) => addition.equals(deletion));
    if (typeof existingAddition !== "undefined") {
      return [
        additionsAcc.filter((addition) => !addition.equals(deletion)),
        deletionsAcc
      ];
    }
    return [additionsAcc, deletionsAcc.concat(deletion)];
  }, [changeLog.additions, changeLog.deletions]);
  return freeze({
    ...solidDataset,
    internal_changeLog: {
      additions: newAdditions,
      deletions: newDeletions
    }
  });
}
function internal_withChangeLog(solidDataset) {
  const newSolidDataset = hasChangelog(solidDataset) ? solidDataset : freeze({
    ...solidDataset,
    internal_changeLog: { additions: [], deletions: [] }
  });
  return newSolidDataset;
}
function containsBlankNode(quad2) {
  return quad2.subject.termType === "BlankNode" || quad2.object.termType === "BlankNode";
}

// node_modules/@inrupt/solid-client/dist/thing/get.mjs
function getUrl(thing, property) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateUrl = internal_toIriString(property);
  const firstUrl = (_c = (_b = (_a = thing.predicates[predicateUrl]) === null || _a === undefined ? undefined : _a.namedNodes) === null || _b === undefined ? undefined : _b[0]) !== null && _c !== undefined ? _c : null;
  if (firstUrl === null) {
    return null;
  }
  return isLocalNodeIri(firstUrl) ? `#${getLocalNodeName(firstUrl)}` : firstUrl;
}
var getIri = getUrl;
function getUrlAll(thing, property) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateUrl = internal_toIriString(property);
  return (_c = (_b = (_a = thing.predicates[predicateUrl]) === null || _a === undefined ? undefined : _a.namedNodes) === null || _b === undefined ? undefined : _b.map((iri) => isLocalNodeIri(iri) ? `#${getLocalNodeName(iri)}` : iri)) !== null && _c !== undefined ? _c : [];
}
var getIriAll = getUrlAll;
function getNamedNodeAll(thing, property) {
  const iriStrings = getIriAll(thing, property);
  return iriStrings.map((iriString) => N3DataFactory_default.namedNode(iriString));
}
function getLiteralAll(thing, property) {
  var _a, _b, _c, _d2;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  let literals = [];
  const langStrings = (_b = (_a = thing.predicates[predicateIri]) === null || _a === undefined ? undefined : _a.langStrings) !== null && _b !== undefined ? _b : {};
  const locales = Object.keys(langStrings);
  for (const locale of locales) {
    const stringsInLocale = langStrings[locale];
    const localeLiterals = stringsInLocale.map((langString) => N3DataFactory_default.literal(langString, locale));
    literals = literals.concat(localeLiterals);
  }
  const otherLiterals = (_d2 = (_c = thing.predicates[predicateIri]) === null || _c === undefined ? undefined : _c.literals) !== null && _d2 !== undefined ? _d2 : {};
  const dataTypes = Object.keys(otherLiterals);
  for (const dataType of dataTypes) {
    const values = otherLiterals[dataType];
    const typeNode = N3DataFactory_default.namedNode(dataType);
    const dataTypeLiterals = values.map((value) => N3DataFactory_default.literal(value, typeNode));
    literals = literals.concat(dataTypeLiterals);
  }
  return literals;
}
function getTermAll(thing, property) {
  var _a, _b;
  internal_throwIfNotThing(thing);
  const namedNodes = getNamedNodeAll(thing, property);
  const literals = getLiteralAll(thing, property);
  const predicateIri = internal_toIriString(property);
  const blankNodeValues = (_b = (_a = thing.predicates[predicateIri]) === null || _a === undefined ? undefined : _a.blankNodes) !== null && _b !== undefined ? _b : [];
  const blankNodes = blankNodeValues.map((rawBlankNode) => {
    const blankNodeName = isBlankNodeId(rawBlankNode) ? getBlankNodeValue(rawBlankNode) : undefined;
    return N3DataFactory_default.blankNode(blankNodeName);
  });
  const terms = namedNodes.concat(literals).concat(blankNodes);
  return terms;
}

// node_modules/@inrupt/solid-client/dist/thing/thing.mjs
function getThing(solidDataset, thingUrl, options = {}) {
  var _a;
  if (!internal_isValidUrl(thingUrl)) {
    throw new ValidThingUrlExpectedError(thingUrl);
  }
  const graph = typeof options.scope !== "undefined" ? internal_toIriString(options.scope) : "default";
  const thingsByIri = (_a = solidDataset.graphs[graph]) !== null && _a !== undefined ? _a : {};
  const thingIri = internal_toIriString(thingUrl);
  const resolvedThingIri = isLocalNodeIri(thingIri) && hasServerResourceInfo(solidDataset) ? resolveLocalIri(getLocalNodeName(thingIri), getSourceUrl(solidDataset)) : thingIri;
  const thing = thingsByIri[resolvedThingIri];
  if (typeof thing === "undefined") {
    return null;
  }
  return thing;
}
function getThingAll(solidDataset, options = { acceptBlankNodes: false }) {
  var _a;
  const graph = typeof options.scope !== "undefined" ? internal_toIriString(options.scope) : "default";
  const thingsByIri = (_a = solidDataset.graphs[graph]) !== null && _a !== undefined ? _a : {};
  return Object.values(thingsByIri).filter((thing) => !isBlankNodeId(thing.url) || options.acceptBlankNodes);
}
function setThing(solidDataset, thing) {
  var _a;
  const thingIri = isThingLocal(thing) && hasServerResourceInfo(solidDataset) ? resolveLocalIri(getLocalNodeName(thing.url), getSourceUrl(solidDataset)) : thing.url;
  const defaultGraph2 = solidDataset.graphs.default;
  const updatedDefaultGraph = freeze({
    ...defaultGraph2,
    [thingIri]: freeze({ ...thing, url: thingIri })
  });
  const updatedGraphs = freeze({
    ...solidDataset.graphs,
    default: updatedDefaultGraph
  });
  const subjectNode = N3DataFactory_default.namedNode(thingIri);
  const deletedThingPredicates = (_a = solidDataset.graphs.default[thingIri]) === null || _a === undefined ? undefined : _a.predicates;
  const deletions = typeof deletedThingPredicates !== "undefined" ? subjectToRdfJsQuads(deletedThingPredicates, subjectNode, N3DataFactory_default.defaultGraph()) : [];
  const additions = subjectToRdfJsQuads(thing.predicates, subjectNode, N3DataFactory_default.defaultGraph());
  return internal_addAdditionsToChangeLog(internal_addDeletionsToChangeLog(freeze({
    ...solidDataset,
    graphs: updatedGraphs
  }), deletions), additions);
}
function removeThing(solidDataset, thing) {
  var _a;
  let thingIri;
  if (isNamedNode2(thing)) {
    thingIri = thing.value;
  } else if (typeof thing === "string") {
    thingIri = isLocalNodeIri(thing) && hasServerResourceInfo(solidDataset) ? resolveLocalIri(getLocalNodeName(thing), getSourceUrl(solidDataset)) : thing;
  } else if (isThingLocal(thing)) {
    thingIri = thing.url;
  } else {
    thingIri = asIri(thing);
  }
  const defaultGraph2 = solidDataset.graphs.default;
  const updatedDefaultGraph = { ...defaultGraph2 };
  delete updatedDefaultGraph[thingIri];
  const updatedGraphs = freeze({
    ...solidDataset.graphs,
    default: freeze(updatedDefaultGraph)
  });
  const subjectNode = N3DataFactory_default.namedNode(thingIri);
  const deletedThingPredicates = (_a = solidDataset.graphs.default[thingIri]) === null || _a === undefined ? undefined : _a.predicates;
  const deletions = typeof deletedThingPredicates !== "undefined" ? subjectToRdfJsQuads(deletedThingPredicates, subjectNode, N3DataFactory_default.defaultGraph()) : [];
  return internal_addDeletionsToChangeLog(freeze({
    ...solidDataset,
    graphs: updatedGraphs
  }), deletions);
}
function createThing(options = {}) {
  var _a;
  if (typeof options.url !== "undefined") {
    const { url } = options;
    if (!internal_isValidUrl(url)) {
      throw new ValidThingUrlExpectedError(url);
    }
    const thing2 = freeze({
      type: "Subject",
      predicates: freeze({}),
      url
    });
    return thing2;
  }
  const name2 = (_a = options.name) !== null && _a !== undefined ? _a : generateName();
  const localNodeIri = getLocalNodeIri(name2);
  const thing = freeze({
    type: "Subject",
    predicates: freeze({}),
    url: localNodeIri
  });
  return thing;
}
function isThing(input) {
  return typeof input === "object" && input !== null && typeof input.type === "string" && input.type === "Subject";
}
function asUrl(thing, baseUrl) {
  if (isThingLocal(thing)) {
    if (typeof baseUrl === "undefined") {
      throw new Error("The URL of a Thing that has not been persisted cannot be determined without a base URL.");
    }
    return resolveLocalIri(getLocalNodeName(thing.url), baseUrl);
  }
  return thing.url;
}
var asIri = asUrl;
function thingAsMarkdown(thing) {
  let thingAsMarkdown2 = "";
  if (isThingLocal(thing)) {
    thingAsMarkdown2 += `## Thing (no URL yet — identifier: \`#${getLocalNodeName(thing.url)}\`)
`;
  } else {
    thingAsMarkdown2 += `## Thing: ${thing.url}
`;
  }
  const predicateIris = Object.keys(thing.predicates);
  if (predicateIris.length === 0) {
    thingAsMarkdown2 += `
<empty>
`;
  } else {
    for (const predicate of predicateIris) {
      thingAsMarkdown2 += `
Property: ${predicate}
`;
      const values = getTermAll(thing, predicate);
      thingAsMarkdown2 += values.reduce((acc, value) => {
        return `${acc}- ${internal_getReadableValue(value)}
`;
      }, "");
    }
  }
  return thingAsMarkdown2;
}
function isThingLocal(thing) {
  return isLocalNodeIri(thing.url);
}

class ThingExpectedError extends SolidClientError {
  constructor(receivedValue) {
    const message2 = `Expected a Thing, but received: [${receivedValue}].`;
    super(message2);
    this.receivedValue = receivedValue;
  }
}

class ValidPropertyUrlExpectedError extends SolidClientError {
  constructor(receivedValue) {
    const value = isNamedNode2(receivedValue) ? receivedValue.value : receivedValue;
    const message2 = `Expected a valid URL to identify a property, but received: [${value}].`;
    super(message2);
    this.receivedProperty = value;
  }
}

class ValidValueUrlExpectedError extends SolidClientError {
  constructor(receivedValue) {
    const value = isNamedNode2(receivedValue) ? receivedValue.value : receivedValue;
    const message2 = `Expected a valid URL value, but received: [${value}].`;
    super(message2);
    this.receivedValue = value;
  }
}

class ValidThingUrlExpectedError extends SolidClientError {
  constructor(receivedValue) {
    const value = isNamedNode2(receivedValue) ? receivedValue.value : receivedValue;
    const message2 = `Expected a valid URL to identify a Thing, but received: [${value}].`;
    super(message2);
    this.receivedValue = value;
  }
}
var generateName = () => {
  return v4_default2();
};

// node_modules/@inrupt/solid-client/dist/resource/iri.internal.mjs
function normalizeServerSideIri(iri) {
  const iriObj = new URL(iri);
  iriObj.hash = "";
  return iriObj.href;
}

// node_modules/@inrupt/solid-client/dist/resource/solidDataset.mjs
function createSolidDataset() {
  return freeze({
    type: "Dataset",
    graphs: {
      default: {}
    }
  });
}
async function responseToSolidDataset(response, parseOptions = {}) {
  if (internal_isUnsuccessfulResponse(response)) {
    throw new FetchError(`Fetching the SolidDataset at [${response.url}] failed: [${response.status}] [${response.statusText}] ${await response.text()}.`, response);
  }
  const resourceInfo = responseToResourceInfo(response);
  const parsers = {
    "text/turtle": getTurtleParser(),
    ...parseOptions.parsers
  };
  const contentType = getContentType(resourceInfo);
  if (contentType === null) {
    throw new Error(`Could not determine the content type of the Resource at [${getSourceUrl(resourceInfo)}].`);
  }
  const mimeType = contentType.split(";")[0];
  const parser = parsers[mimeType];
  if (typeof parser === "undefined") {
    throw new Error(`The Resource at [${getSourceUrl(resourceInfo)}] has a MIME type of [${mimeType}], but the only parsers available are for the following MIME types: [${Object.keys(parsers).join(", ")}].`);
  }
  const data = await response.text();
  const parsingPromise = new Promise((resolve, reject) => {
    let solidDataset = freeze({
      graphs: freeze({ default: freeze({}) }),
      type: "Dataset"
    });
    const quadsWithBlankNodes = [];
    const allQuads = [];
    parser.onError((error) => {
      reject(new Error(`Encountered an error parsing the Resource at [${getSourceUrl(resourceInfo)}] with content type [${contentType}]: ${error}`));
    });
    parser.onQuad((quad2) => {
      allQuads.push(quad2);
      if (quad2.subject.termType === "BlankNode" || quad2.object.termType === "BlankNode") {
        quadsWithBlankNodes.push(quad2);
      } else {
        solidDataset = addRdfJsQuadToDataset(solidDataset, quad2);
      }
    });
    parser.onComplete(async () => {
      const maxBlankNodesToDetectChainsFor = 20;
      const chainBlankNodes = quadsWithBlankNodes.length <= maxBlankNodesToDetectChainsFor ? getChainBlankNodes(quadsWithBlankNodes) : [];
      const quadsWithoutChainBlankNodeSubjects = quadsWithBlankNodes.filter((quad2) => chainBlankNodes.every((chainBlankNode) => !chainBlankNode.equals(quad2.subject)));
      solidDataset = quadsWithoutChainBlankNodeSubjects.reduce((datasetAcc, quad2) => addRdfJsQuadToDataset(datasetAcc, quad2, {
        otherQuads: allQuads,
        chainBlankNodes
      }), solidDataset);
      const solidDatasetWithResourceInfo = freeze({
        ...solidDataset,
        ...resourceInfo
      });
      resolve(solidDatasetWithResourceInfo);
    });
    parser.parse(data, resourceInfo);
  });
  return parsingPromise;
}
async function getSolidDataset(url, options) {
  var _a, _b;
  const normalizedUrl = normalizeUrl(internal_toIriString(url));
  const parserContentTypes = Object.keys((_a = options === null || options === undefined ? undefined : options.parsers) !== null && _a !== undefined ? _a : {});
  const acceptedContentTypes = parserContentTypes.length > 0 ? parserContentTypes.join(", ") : "text/turtle";
  const response = await ((_b = options === null || options === undefined ? undefined : options.fetch) !== null && _b !== undefined ? _b : fetch)(normalizedUrl, {
    headers: {
      Accept: acceptedContentTypes
    }
  });
  if (internal_isUnsuccessfulResponse(response)) {
    throw new FetchError(`Fetching the Resource at [${normalizedUrl}] failed: [${response.status}] [${response.statusText}] ${await response.text()}.`, response);
  }
  const solidDataset = await responseToSolidDataset(response, options);
  return solidDataset;
}
async function prepareSolidDatasetUpdate(solidDataset) {
  const deleteStatement = solidDataset.internal_changeLog.deletions.length > 0 ? `DELETE DATA {${(await triplesToTurtle(solidDataset.internal_changeLog.deletions.map(getNamedNodesForLocalNodes))).trim()}};` : "";
  const insertStatement = solidDataset.internal_changeLog.additions.length > 0 ? `INSERT DATA {${(await triplesToTurtle(solidDataset.internal_changeLog.additions.map(getNamedNodesForLocalNodes))).trim()}};` : "";
  return {
    method: "PATCH",
    body: `${deleteStatement} ${insertStatement}`,
    headers: {
      "Content-Type": "application/sparql-update"
    }
  };
}
async function prepareSolidDatasetCreation(solidDataset, options) {
  return {
    method: "PUT",
    body: await triplesToTurtle(toRdfJsQuads(solidDataset).map(getNamedNodesForLocalNodes), options),
    headers: {
      "Content-Type": "text/turtle",
      "If-None-Match": "*",
      Link: `<${ldp.Resource}>; rel="type"`
    }
  };
}
async function saveSolidDatasetAt(url, solidDataset, options) {
  var _a;
  const targetUrl = normalizeUrl(internal_toIriString(url));
  const datasetWithChangelog = internal_withChangeLog(solidDataset);
  const requestInit = isUpdate(datasetWithChangelog, targetUrl) ? await prepareSolidDatasetUpdate(datasetWithChangelog) : await prepareSolidDatasetCreation(datasetWithChangelog, options);
  const response = await ((_a = options === null || options === undefined ? undefined : options.fetch) !== null && _a !== undefined ? _a : fetch)(targetUrl, requestInit);
  if (internal_isUnsuccessfulResponse(response)) {
    const diagnostics = isUpdate(datasetWithChangelog, targetUrl) ? `The changes that were sent to the Pod are listed below.

${changeLogAsMarkdown(datasetWithChangelog)}` : `The SolidDataset that was sent to the Pod is listed below.

${solidDatasetAsMarkdown(datasetWithChangelog)}`;
    throw new FetchError(`Storing the Resource at [${targetUrl}] failed: [${response.status}] [${response.statusText}] ${await response.text()}.

${diagnostics}`, response);
  }
  const resourceInfo = {
    ...internal_parseResourceInfo(response),
    isRawData: false
  };
  const storedDataset = freeze({
    ...solidDataset,
    internal_changeLog: { additions: [], deletions: [] },
    internal_resourceInfo: resourceInfo
  });
  const storedDatasetWithResolvedIris = resolveLocalIrisInSolidDataset(storedDataset);
  return storedDatasetWithResolvedIris;
}
function isSourceIriEqualTo(dataset, iri) {
  return normalizeServerSideIri(dataset.internal_resourceInfo.sourceIri) === normalizeServerSideIri(iri);
}
function isUpdate(solidDataset, url) {
  return hasChangelog(solidDataset) && hasResourceInfo(solidDataset) && typeof solidDataset.internal_resourceInfo.sourceIri === "string" && isSourceIriEqualTo(solidDataset, url);
}
function solidDatasetAsMarkdown(solidDataset) {
  let readableSolidDataset = "";
  if (hasResourceInfo(solidDataset)) {
    readableSolidDataset += `# SolidDataset: ${getSourceUrl(solidDataset)}
`;
  } else {
    readableSolidDataset += `# SolidDataset (no URL yet)
`;
  }
  const things = getThingAll(solidDataset);
  if (things.length === 0) {
    readableSolidDataset += `
<empty>
`;
  } else {
    things.forEach((thing) => {
      readableSolidDataset += `
${thingAsMarkdown(thing)}`;
      if (hasChangelog(solidDataset)) {
        readableSolidDataset += `
${getReadableChangeLogSummary(solidDataset, thing)}
`;
      }
    });
  }
  return readableSolidDataset;
}
function changeLogAsMarkdown(solidDataset) {
  if (!hasResourceInfo(solidDataset)) {
    return "This is a newly initialized SolidDataset, so there is no source to compare it to.";
  }
  if (!hasChangelog(solidDataset) || solidDataset.internal_changeLog.additions.length === 0 && solidDataset.internal_changeLog.deletions.length === 0) {
    return `## Changes compared to ${getSourceUrl(solidDataset)}

` + `This SolidDataset has not been modified since it was fetched from ${getSourceUrl(solidDataset)}.
`;
  }
  let readableChangeLog = `## Changes compared to ${getSourceUrl(solidDataset)}
`;
  const changeLogsByThingAndProperty = sortChangeLogByThingAndProperty(solidDataset);
  Object.keys(changeLogsByThingAndProperty).forEach((thingUrl) => {
    readableChangeLog += `
### Thing: ${thingUrl}
`;
    const changeLogByProperty = changeLogsByThingAndProperty[thingUrl];
    Object.keys(changeLogByProperty).forEach((propertyUrl) => {
      readableChangeLog += `
Property: ${propertyUrl}
`;
      const { deleted } = changeLogByProperty[propertyUrl];
      const { added } = changeLogByProperty[propertyUrl];
      if (deleted.length > 0) {
        readableChangeLog += `- Removed:
`;
        readableChangeLog += deleted.reduce((acc, deletedValue) => {
          return `${acc}  - ${internal_getReadableValue(deletedValue)}
`;
        }, "");
      }
      if (added.length > 0) {
        readableChangeLog += `- Added:
`;
        readableChangeLog += added.reduce((acc, addedValue) => {
          return `${acc}  - ${internal_getReadableValue(addedValue)}
`;
        }, "");
      }
    });
  });
  return readableChangeLog;
}
function sortChangeLogByThingAndProperty(solidDataset) {
  const changeLogsByThingAndProperty = Object.create(null);
  solidDataset.internal_changeLog.deletions.forEach((deletion) => {
    var _a, _b;
    var _c;
    const subjectNode = isLocalNode(deletion.subject) ? resolveIriForLocalNode(deletion.subject, getSourceUrl(solidDataset)) : deletion.subject;
    if (!isNamedNode2(subjectNode) || !isNamedNode2(deletion.predicate)) {
      return;
    }
    const thingUrl = internal_toIriString(subjectNode);
    const propertyUrl = internal_toIriString(deletion.predicate);
    (_a = changeLogsByThingAndProperty[thingUrl]) !== null && _a !== undefined || (changeLogsByThingAndProperty[thingUrl] = Object.create(null));
    (_b = (_c = changeLogsByThingAndProperty[thingUrl])[propertyUrl]) !== null && _b !== undefined || (_c[propertyUrl] = {
      added: [],
      deleted: []
    });
    changeLogsByThingAndProperty[thingUrl][propertyUrl].deleted.push(deletion.object);
  });
  solidDataset.internal_changeLog.additions.forEach((addition) => {
    var _a, _b;
    var _c;
    const subjectNode = isLocalNode(addition.subject) ? resolveIriForLocalNode(addition.subject, getSourceUrl(solidDataset)) : addition.subject;
    if (!isNamedNode2(subjectNode) || !isNamedNode2(addition.predicate)) {
      return;
    }
    const thingUrl = internal_toIriString(subjectNode);
    const propertyUrl = internal_toIriString(addition.predicate);
    (_a = changeLogsByThingAndProperty[thingUrl]) !== null && _a !== undefined || (changeLogsByThingAndProperty[thingUrl] = Object.create(null));
    (_b = (_c = changeLogsByThingAndProperty[thingUrl])[propertyUrl]) !== null && _b !== undefined || (_c[propertyUrl] = {
      added: [],
      deleted: []
    });
    changeLogsByThingAndProperty[thingUrl][propertyUrl].added.push(addition.object);
  });
  return changeLogsByThingAndProperty;
}
function getReadableChangeLogSummary(solidDataset, thing) {
  const subject = N3DataFactory_default.namedNode(thing.url);
  const nrOfAdditions = solidDataset.internal_changeLog.additions.reduce((count, addition) => addition.subject.equals(subject) ? count + 1 : count, 0);
  const nrOfDeletions = solidDataset.internal_changeLog.deletions.reduce((count, deletion) => deletion.subject.equals(subject) ? count + 1 : count, 0);
  const additionString = nrOfAdditions === 1 ? "1 new value added" : `${nrOfAdditions} new values added`;
  const deletionString = nrOfDeletions === 1 ? "1 value removed" : `${nrOfDeletions} values removed`;
  return `(${additionString} / ${deletionString})`;
}
function getNamedNodesForLocalNodes(quad2) {
  const subject = isNamedNode2(quad2.subject) ? getNamedNodeFromLocalNode(quad2.subject) : quad2.subject;
  const object = isNamedNode2(quad2.object) ? getNamedNodeFromLocalNode(quad2.object) : quad2.object;
  return N3DataFactory_default.quad(subject, quad2.predicate, object, quad2.graph);
}
function getNamedNodeFromLocalNode(node) {
  if (isLocalNodeIri(node.value)) {
    return N3DataFactory_default.namedNode(`#${getLocalNodeName(node.value)}`);
  }
  return node;
}
function resolveLocalIrisInSolidDataset(solidDataset) {
  const resourceIri = getSourceUrl(solidDataset);
  const defaultGraph2 = solidDataset.graphs.default;
  const thingIris = Object.keys(defaultGraph2);
  const updatedDefaultGraph = thingIris.reduce((graphAcc, thingIri) => {
    const resolvedThing = resolveLocalIrisInThing(graphAcc[thingIri], resourceIri);
    const resolvedThingIri = isLocalNodeIri(thingIri) ? `${resourceIri}#${getLocalNodeName(thingIri)}` : thingIri;
    const updatedGraph = { ...graphAcc };
    delete updatedGraph[thingIri];
    updatedGraph[resolvedThingIri] = resolvedThing;
    return freeze(updatedGraph);
  }, defaultGraph2);
  const updatedGraphs = freeze({
    ...solidDataset.graphs,
    default: updatedDefaultGraph
  });
  return freeze({
    ...solidDataset,
    graphs: updatedGraphs
  });
}
function resolveLocalIrisInThing(thing, baseIri) {
  const predicateIris = Object.keys(thing.predicates);
  const updatedPredicates = predicateIris.reduce((predicatesAcc, predicateIri) => {
    var _a;
    const namedNodes = (_a = predicatesAcc[predicateIri].namedNodes) !== null && _a !== undefined ? _a : [];
    if (namedNodes.every((namedNode2) => !isLocalNodeIri(namedNode2))) {
      return predicatesAcc;
    }
    const updatedNamedNodes = freeze(namedNodes.map((namedNode2) => isLocalNodeIri(namedNode2) ? `${baseIri}#${getLocalNodeName(namedNode2)}` : namedNode2));
    const updatedPredicate = freeze({
      ...predicatesAcc[predicateIri],
      namedNodes: updatedNamedNodes
    });
    return freeze({
      ...predicatesAcc,
      [predicateIri]: updatedPredicate
    });
  }, thing.predicates);
  return freeze({
    ...thing,
    predicates: updatedPredicates,
    url: isLocalNodeIri(thing.url) ? `${baseIri}#${getLocalNodeName(thing.url)}` : thing.url
  });
}

// node_modules/@inrupt/solid-client/dist/thing/add.mjs
var addUrl = (thing, property, url) => {
  var _a, _b;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  if (!isThing(url) && !internal_isValidUrl(url)) {
    throw new ValidValueUrlExpectedError(url);
  }
  const predicateIri = internal_toIriString(property);
  const existingPredicate = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  const existingNamedNodes = (_b = existingPredicate.namedNodes) !== null && _b !== undefined ? _b : [];
  let iriToAdd;
  if (isNamedNode2(url)) {
    iriToAdd = url.value;
  } else if (typeof url === "string") {
    iriToAdd = url;
  } else if (isThingLocal(url)) {
    iriToAdd = url.url;
  } else {
    iriToAdd = asIri(url);
  }
  const updatedNamedNodes = freeze(existingNamedNodes.concat(internal_toIriString(iriToAdd)));
  const updatedPredicate = freeze({
    ...existingPredicate,
    namedNodes: updatedNamedNodes
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  const updatedThing = freeze({
    ...thing,
    predicates: updatedPredicates
  });
  return updatedThing;
};
var addIri = addUrl;
var addBoolean = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeBoolean(value), xmlSchemaTypes.boolean);
};
var addDatetime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeDatetime(value), xmlSchemaTypes.dateTime);
};
var addDate = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeDate(value), xmlSchemaTypes.date);
};
var addTime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeTime(value), xmlSchemaTypes.time);
};
var addDecimal = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeDecimal(value), xmlSchemaTypes.decimal);
};
var addInteger = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, serializeInteger(value), xmlSchemaTypes.integer);
};
function addStringWithLocale(thing, property, value, locale) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  const normalizedLocale = normalizeLocale(locale);
  const existingPredicate = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  const existingLangStrings = (_b = existingPredicate.langStrings) !== null && _b !== undefined ? _b : {};
  const existingStringsInLocale = (_c = existingLangStrings[normalizedLocale]) !== null && _c !== undefined ? _c : [];
  const updatedStringsInLocale = freeze(existingStringsInLocale.concat(value));
  const updatedLangStrings = freeze({
    ...existingLangStrings,
    [normalizedLocale]: updatedStringsInLocale
  });
  const updatedPredicate = freeze({
    ...existingPredicate,
    langStrings: updatedLangStrings
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  const updatedThing = freeze({
    ...thing,
    predicates: updatedPredicates
  });
  return updatedThing;
}
var addStringNoLocale = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addLiteralOfType(thing, property, value, xmlSchemaTypes.string);
};
function addNamedNode(thing, property, value) {
  return addUrl(thing, property, value.value);
}
function addLiteral(thing, property, value) {
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const typeIri = value.datatype.value;
  if (typeIri === xmlSchemaTypes.langString) {
    return addStringWithLocale(thing, property, value.value, value.language);
  }
  return addLiteralOfType(thing, property, value.value, value.datatype.value);
}
function addTerm(thing, property, value) {
  var _a, _b;
  if (value.termType === "NamedNode") {
    return addNamedNode(thing, property, value);
  }
  if (value.termType === "Literal") {
    return addLiteral(thing, property, value);
  }
  if (value.termType === "BlankNode") {
    internal_throwIfNotThing(thing);
    if (!internal_isValidUrl(property)) {
      throw new ValidPropertyUrlExpectedError(property);
    }
    const predicateIri = internal_toIriString(property);
    const existingPredicate = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
    const existingBlankNodes = (_b = existingPredicate.blankNodes) !== null && _b !== undefined ? _b : [];
    const updatedBlankNodes = freeze(existingBlankNodes.concat(getBlankNodeId(value)));
    const updatedPredicate = freeze({
      ...existingPredicate,
      blankNodes: updatedBlankNodes
    });
    const updatedPredicates = freeze({
      ...thing.predicates,
      [predicateIri]: updatedPredicate
    });
    const updatedThing = freeze({
      ...thing,
      predicates: updatedPredicates
    });
    return updatedThing;
  }
  throw new Error(`Term type [${value.termType}] is not supported by @inrupt/solid-client.`);
}
function addLiteralOfType(thing, property, value, type) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  const existingPredicate = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  const existingLiterals = (_b = existingPredicate.literals) !== null && _b !== undefined ? _b : {};
  const existingValuesOfType = (_c = existingLiterals[type]) !== null && _c !== undefined ? _c : [];
  const updatedValuesOfType = freeze(existingValuesOfType.concat(value));
  const updatedLiterals = freeze({
    ...existingLiterals,
    [type]: updatedValuesOfType
  });
  const updatedPredicate = freeze({
    ...existingPredicate,
    literals: updatedLiterals
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  const updatedThing = freeze({
    ...thing,
    predicates: updatedPredicates
  });
  return updatedThing;
}

// node_modules/@inrupt/solid-client/dist/thing/remove.mjs
function removeAll(thing, property) {
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  const newPredicates = { ...thing.predicates };
  delete newPredicates[predicateIri];
  return freeze({
    ...thing,
    predicates: freeze(newPredicates)
  });
}
var removeUrl = (thing, property, value) => {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  if (!isThing(value) && !internal_isValidUrl(value)) {
    throw new ValidValueUrlExpectedError(value);
  }
  const iriToRemove = isThing(value) ? asIri(value) : internal_toIriString(value);
  const updatedNamedNodes = freeze((_c = (_b = (_a = thing.predicates[predicateIri]) === null || _a === undefined ? undefined : _a.namedNodes) === null || _b === undefined ? undefined : _b.filter((namedNode2) => namedNode2.toLowerCase() !== iriToRemove.toLowerCase())) !== null && _c !== undefined ? _c : []);
  const updatedPredicate = freeze({
    ...thing.predicates[predicateIri],
    namedNodes: updatedNamedNodes
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  return freeze({
    ...thing,
    predicates: updatedPredicates
  });
};
var removeIri = removeUrl;
var removeBoolean = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.boolean, (foundBoolean) => deserializeBoolean(foundBoolean) === value);
};
var removeDatetime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.dateTime, (foundDatetime) => {
    var _a;
    return ((_a = deserializeDatetime(foundDatetime)) === null || _a === undefined ? undefined : _a.getTime()) === value.getTime();
  });
};
var removeDate = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.date, function(foundDate) {
    const deserializedDate = deserializeDate(foundDate);
    if (deserializedDate) {
      return deserializedDate.getFullYear() === value.getFullYear() && deserializedDate.getMonth() === value.getMonth() && deserializedDate.getUTCDate() === value.getUTCDate();
    }
    return false;
  });
};
var removeTime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.time, function(foundTime) {
    const deserializedTime = deserializeTime(foundTime);
    if (deserializedTime) {
      return deserializedTime.hour === value.hour && deserializedTime.minute === value.minute && deserializedTime.second === value.second && deserializedTime.millisecond === value.millisecond && deserializedTime.timezoneHourOffset === value.timezoneHourOffset && deserializedTime.timezoneMinuteOffset === value.timezoneMinuteOffset;
    }
    return false;
  });
};
var removeDecimal = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.decimal, (foundDecimal) => deserializeDecimal(foundDecimal) === value);
};
var removeInteger = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.integer, (foundInteger) => deserializeInteger(foundInteger) === value);
};
function removeStringWithLocale(thing, property, value, locale) {
  var _a, _b;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  const existingLangStrings = (_b = (_a = thing.predicates[predicateIri]) === null || _a === undefined ? undefined : _a.langStrings) !== null && _b !== undefined ? _b : {};
  const matchingLocale = Object.keys(existingLangStrings).find((existingLocale) => normalizeLocale(existingLocale) === normalizeLocale(locale) && Array.isArray(existingLangStrings[existingLocale]) && existingLangStrings[existingLocale].length > 0);
  if (typeof matchingLocale !== "string") {
    return thing;
  }
  const existingStringsInLocale = existingLangStrings[matchingLocale];
  const updatedStringsInLocale = freeze(existingStringsInLocale.filter((existingString) => existingString !== value));
  const updatedLangStrings = freeze({
    ...existingLangStrings,
    [matchingLocale]: updatedStringsInLocale
  });
  const updatedPredicate = freeze({
    ...thing.predicates[predicateIri],
    langStrings: updatedLangStrings
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  return freeze({
    ...thing,
    predicates: updatedPredicates
  });
}
var removeStringNoLocale = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return removeLiteralMatching(thing, property, xmlSchemaTypes.string, (foundString) => foundString === value);
};
function removeNamedNode(thing, property, value) {
  return removeUrl(thing, property, value.value);
}
function removeLiteral(thing, property, value) {
  var _a, _b, _c;
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const typeIri = value.datatype.value;
  if (typeIri === xmlSchemaTypes.langString) {
    return removeStringWithLocale(thing, property, value.value, value.language);
  }
  const predicateIri = internal_toIriString(property);
  const existingPredicateValues = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  const existingLiterals = (_b = existingPredicateValues.literals) !== null && _b !== undefined ? _b : {};
  const existingValuesOfType = (_c = existingLiterals[typeIri]) !== null && _c !== undefined ? _c : [];
  const updatedValues = freeze(existingValuesOfType.filter((existingValue) => existingValue !== value.value));
  const updatedLiterals = freeze({
    ...existingLiterals,
    [typeIri]: updatedValues
  });
  const updatedPredicate = freeze({
    ...existingPredicateValues,
    literals: updatedLiterals
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  const updatedThing = freeze({
    ...thing,
    predicates: updatedPredicates
  });
  return updatedThing;
}
function removeLiteralMatching(thing, property, type, matcher) {
  var _a, _b, _c;
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  const predicateIri = internal_toIriString(property);
  const existingPredicateValues = (_a = thing.predicates[predicateIri]) !== null && _a !== undefined ? _a : {};
  const existingLiterals = (_b = existingPredicateValues.literals) !== null && _b !== undefined ? _b : {};
  const existingValuesOfType = (_c = existingLiterals[type]) !== null && _c !== undefined ? _c : [];
  const updatedValues = freeze(existingValuesOfType.filter((existingValue) => !matcher(existingValue)));
  const updatedLiterals = freeze({
    ...existingLiterals,
    [type]: updatedValues
  });
  const updatedPredicate = freeze({
    ...existingPredicateValues,
    literals: updatedLiterals
  });
  const updatedPredicates = freeze({
    ...thing.predicates,
    [predicateIri]: updatedPredicate
  });
  const updatedThing = freeze({
    ...thing,
    predicates: updatedPredicates
  });
  return updatedThing;
}

// node_modules/@inrupt/solid-client/dist/thing/set.mjs
var setUrl = (thing, property, url) => {
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  if (!isThing(url) && !internal_isValidUrl(url)) {
    throw new ValidValueUrlExpectedError(url);
  }
  return addUrl(removeAll(thing, property), property, url);
};
var setIri = setUrl;
var setBoolean = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addBoolean(removeAll(thing, property), property, value);
};
var setDatetime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addDatetime(removeAll(thing, property), property, value);
};
var setDate = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addDate(removeAll(thing, property), property, value);
};
var setTime = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addTime(removeAll(thing, property), property, value);
};
var setDecimal = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addDecimal(removeAll(thing, property), property, value);
};
var setInteger = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addInteger(removeAll(thing, property), property, value);
};
function setStringWithLocale(thing, property, value, locale) {
  internal_throwIfNotThing(thing);
  return addStringWithLocale(removeAll(thing, property), property, value, locale);
}
var setStringNoLocale = (thing, property, value) => {
  internal_throwIfNotThing(thing);
  return addStringNoLocale(removeAll(thing, property), property, value);
};
function setNamedNode(thing, property, value) {
  internal_throwIfNotThing(thing);
  return addNamedNode(removeAll(thing, property), property, value);
}
function setLiteral(thing, property, value) {
  internal_throwIfNotThing(thing);
  return addLiteral(removeAll(thing, property), property, value);
}
function setTerm(thing, property, value) {
  internal_throwIfNotThing(thing);
  if (!internal_isValidUrl(property)) {
    throw new ValidPropertyUrlExpectedError(property);
  }
  return addTerm(removeAll(thing, property), property, value);
}

// node_modules/@inrupt/solid-client/dist/thing/build.mjs
function buildThing(init = createThing()) {
  let thing = isThing(init) ? init : createThing(init);
  function getAdder(adder) {
    return (property, value) => {
      thing = adder(thing, property, value);
      return builder;
    };
  }
  function getSetter(setter) {
    return (property, value) => {
      thing = setter(thing, property, value);
      return builder;
    };
  }
  function getRemover(remover) {
    return (property, value) => {
      thing = remover(thing, property, value);
      return builder;
    };
  }
  const builder = {
    build: () => thing,
    addUrl: getAdder(addUrl),
    addIri: getAdder(addIri),
    addBoolean: getAdder(addBoolean),
    addDatetime: getAdder(addDatetime),
    addDate: getAdder(addDate),
    addTime: getAdder(addTime),
    addDecimal: getAdder(addDecimal),
    addInteger: getAdder(addInteger),
    addStringNoLocale: getAdder(addStringNoLocale),
    addStringEnglish: (property, value) => {
      thing = addStringWithLocale(thing, property, value, "en");
      return builder;
    },
    addStringWithLocale: (property, value, locale) => {
      thing = addStringWithLocale(thing, property, value, locale);
      return builder;
    },
    addNamedNode: getAdder(addNamedNode),
    addLiteral: getAdder(addLiteral),
    addTerm: getAdder(addTerm),
    setUrl: getSetter(setUrl),
    setIri: getSetter(setIri),
    setBoolean: getSetter(setBoolean),
    setDatetime: getSetter(setDatetime),
    setDate: getSetter(setDate),
    setTime: getSetter(setTime),
    setDecimal: getSetter(setDecimal),
    setInteger: getSetter(setInteger),
    setStringNoLocale: getSetter(setStringNoLocale),
    setStringEnglish: (property, value) => {
      thing = setStringWithLocale(thing, property, value, "en");
      return builder;
    },
    setStringWithLocale: (property, value, locale) => {
      thing = setStringWithLocale(thing, property, value, locale);
      return builder;
    },
    setNamedNode: getSetter(setNamedNode),
    setLiteral: getSetter(setLiteral),
    setTerm: getSetter(setTerm),
    removeAll: (property) => {
      thing = removeAll(thing, property);
      return builder;
    },
    removeUrl: getRemover(removeUrl),
    removeIri: getRemover(removeIri),
    removeBoolean: getRemover(removeBoolean),
    removeDatetime: getRemover(removeDatetime),
    removeDate: getRemover(removeDate),
    removeTime: getRemover(removeTime),
    removeDecimal: getRemover(removeDecimal),
    removeInteger: getRemover(removeInteger),
    removeStringNoLocale: getRemover(removeStringNoLocale),
    removeStringEnglish: (property, value) => buildThing(removeStringWithLocale(thing, property, value, "en")),
    removeStringWithLocale: (property, value, locale) => buildThing(removeStringWithLocale(thing, property, value, locale)),
    removeNamedNode: getRemover(removeNamedNode),
    removeLiteral: getRemover(removeLiteral)
  };
  return builder;
}

// node_modules/@inrupt/solid-client/dist/acp/acp.internal.mjs
function isAcr(linkedAccessResource) {
  const relTypeLinks = getLinkedResourceUrlAll(linkedAccessResource).type;
  return Array.isArray(relTypeLinks) && relTypeLinks.includes(acp.AccessControlResource);
}

// node_modules/@inrupt/solid-client/dist/acl/acl.internal.mjs
async function internal_fetchAcl(resourceInfo, options) {
  if (!hasAccessibleAcl(resourceInfo)) {
    return {
      resourceAcl: null,
      fallbackAcl: null
    };
  }
  try {
    const resourceAcl = await internal_fetchResourceAcl(resourceInfo, options);
    const acl2 = resourceAcl === null ? {
      resourceAcl: null,
      fallbackAcl: await internal_fetchFallbackAcl(resourceInfo, options)
    } : { resourceAcl, fallbackAcl: null };
    return acl2;
  } catch (e) {
    if (e instanceof AclIsAcrError) {
      return {
        resourceAcl: null,
        fallbackAcl: null
      };
    }
    throw e;
  }
}
async function internal_fetchResourceAcl(dataset, options) {
  if (!hasAccessibleAcl(dataset)) {
    return null;
  }
  try {
    const aclSolidDataset = await getSolidDataset(dataset.internal_resourceInfo.aclUrl, options);
    if (isAcr(aclSolidDataset)) {
      throw new AclIsAcrError(dataset, aclSolidDataset);
    }
    return freeze({
      ...aclSolidDataset,
      internal_accessTo: getSourceUrl(dataset)
    });
  } catch (e) {
    if (e instanceof AclIsAcrError) {
      throw e;
    }
    return null;
  }
}
async function internal_fetchFallbackAcl(resource, options) {
  const resourceUrl = new URL(getSourceUrl(resource));
  const resourcePath = resourceUrl.pathname;
  if (resourcePath === "/") {
    return null;
  }
  const containerPath = internal_getContainerPath(resourcePath);
  const containerIri = new URL(containerPath, resourceUrl.origin).href;
  const containerInfo = await getResourceInfo(containerIri, options);
  if (!hasAccessibleAcl(containerInfo)) {
    return null;
  }
  const containerAcl = await internal_fetchResourceAcl(containerInfo, options);
  if (containerAcl === null) {
    return internal_fetchFallbackAcl(containerInfo, options);
  }
  return containerAcl;
}
function internal_getContainerPath(resourcePath) {
  const resourcePathWithoutTrailingSlash = resourcePath.substring(resourcePath.length - 1) === "/" ? resourcePath.substring(0, resourcePath.length - 1) : resourcePath;
  const containerPath = `${resourcePath.substring(0, resourcePathWithoutTrailingSlash.lastIndexOf("/"))}/`;
  return containerPath;
}
function internal_getAclRules(aclDataset) {
  const things = getThingAll(aclDataset);
  return things.filter(isAclRule);
}
function isAclRule(thing) {
  return getIriAll(thing, rdf3.type).includes(acl.Authorization);
}
function internal_getResourceAclRulesForResource(aclRules, resource) {
  return aclRules.filter((rule) => appliesToResource(rule, resource));
}
function appliesToResource(aclRule, resource) {
  return getIriAll(aclRule, acl.accessTo).includes(resource);
}
function internal_getDefaultAclRulesForResource(aclRules, resource) {
  return aclRules.filter((rule) => isDefaultForResource(rule, resource));
}
function isDefaultForResource(aclRule, resource) {
  return getIriAll(aclRule, acl.default).includes(resource) || getIriAll(aclRule, acl.defaultForNew).includes(resource);
}
function internal_getAccess(rule) {
  const ruleAccessModes = getIriAll(rule, acl.mode);
  const writeAccess = ruleAccessModes.includes(internal_accessModeIriStrings.write);
  return writeAccess ? {
    read: ruleAccessModes.includes(internal_accessModeIriStrings.read),
    append: true,
    write: true,
    control: ruleAccessModes.includes(internal_accessModeIriStrings.control)
  } : {
    read: ruleAccessModes.includes(internal_accessModeIriStrings.read),
    append: ruleAccessModes.includes(internal_accessModeIriStrings.append),
    write: false,
    control: ruleAccessModes.includes(internal_accessModeIriStrings.control)
  };
}
function internal_combineAccessModes(modes) {
  return modes.reduce((accumulator, current) => {
    const writeAccess = accumulator.write || current.write;
    return writeAccess ? {
      read: accumulator.read || current.read,
      append: true,
      write: true,
      control: accumulator.control || current.control
    } : {
      read: accumulator.read || current.read,
      append: accumulator.append || current.append,
      write: false,
      control: accumulator.control || current.control
    };
  }, { read: false, append: false, write: false, control: false });
}
function internal_removeEmptyAclRules(aclDataset) {
  const aclRules = internal_getAclRules(aclDataset);
  const aclRulesToRemove = aclRules.filter(isEmptyAclRule);
  const updatedAclDataset = aclRulesToRemove.reduce(removeThing, aclDataset);
  return updatedAclDataset;
}
function isEmptyAclRule(aclRule) {
  if (subjectToRdfJsQuads(aclRule.predicates, N3DataFactory_default.namedNode(aclRule.url), N3DataFactory_default.defaultGraph()).some((quad2) => !isAclQuad(quad2))) {
    return false;
  }
  if (getIri(aclRule, acl.accessTo) === null && getIri(aclRule, acl.default) === null && getIri(aclRule, acl.defaultForNew) === null) {
    return true;
  }
  if (getIri(aclRule, acl.mode) === null) {
    return true;
  }
  if (getIri(aclRule, acl.agent) === null && getIri(aclRule, acl.agentGroup) === null && getIri(aclRule, acl.agentClass) === null) {
    return true;
  }
  return false;
}
function isAclQuad(quad2) {
  const { predicate } = quad2;
  const { object } = quad2;
  if (predicate.equals(N3DataFactory_default.namedNode(rdf3.type)) && object.equals(N3DataFactory_default.namedNode(acl.Authorization))) {
    return true;
  }
  if (predicate.equals(N3DataFactory_default.namedNode(acl.accessTo)) || predicate.equals(N3DataFactory_default.namedNode(acl.default)) || predicate.equals(N3DataFactory_default.namedNode(acl.defaultForNew))) {
    return true;
  }
  if (predicate.equals(N3DataFactory_default.namedNode(acl.mode)) && Object.values(internal_accessModeIriStrings).some((mode) => object.equals(N3DataFactory_default.namedNode(mode)))) {
    return true;
  }
  if (predicate.equals(N3DataFactory_default.namedNode(acl.agent)) || predicate.equals(N3DataFactory_default.namedNode(acl.agentGroup)) || predicate.equals(N3DataFactory_default.namedNode(acl.agentClass))) {
    return true;
  }
  if (predicate.equals(N3DataFactory_default.namedNode(acl.origin))) {
    return true;
  }
  return false;
}
var internal_accessModeIriStrings = {
  read: "http://www.w3.org/ns/auth/acl#Read",
  append: "http://www.w3.org/ns/auth/acl#Append",
  write: "http://www.w3.org/ns/auth/acl#Write",
  control: "http://www.w3.org/ns/auth/acl#Control"
};
function internal_getAclRulesForIri(aclRules, targetIri, targetType) {
  return aclRules.filter((rule) => getIriAll(rule, targetType).includes(targetIri));
}
function internal_getAccessByIri(aclRules, targetType) {
  const targetIriAccess = {};
  aclRules.forEach((rule) => {
    const ruleTargetIri = getIriAll(rule, targetType);
    const access = internal_getAccess(rule);
    ruleTargetIri.forEach((targetIri) => {
      targetIriAccess[targetIri] = typeof targetIriAccess[targetIri] === "undefined" ? access : internal_combineAccessModes([targetIriAccess[targetIri], access]);
    });
  });
  return targetIriAccess;
}
function internal_initialiseAclRule(access) {
  let newRule = createThing();
  newRule = setIri(newRule, rdf3.type, acl.Authorization);
  if (access.read) {
    newRule = addIri(newRule, acl.mode, internal_accessModeIriStrings.read);
  }
  if (access.append && !access.write) {
    newRule = addIri(newRule, acl.mode, internal_accessModeIriStrings.append);
  }
  if (access.write) {
    newRule = addIri(newRule, acl.mode, internal_accessModeIriStrings.write);
  }
  if (access.control) {
    newRule = addIri(newRule, acl.mode, internal_accessModeIriStrings.control);
  }
  return newRule;
}
function internal_duplicateAclRule(sourceRule) {
  let targetRule = createThing();
  targetRule = setIri(targetRule, rdf3.type, acl.Authorization);
  function copyIris(inputRule, outputRule, predicate) {
    return getIriAll(inputRule, predicate).reduce((outputRule2, iriTarget) => addIri(outputRule2, predicate, iriTarget), outputRule);
  }
  targetRule = copyIris(sourceRule, targetRule, acl.accessTo);
  targetRule = copyIris(sourceRule, targetRule, acl.default);
  targetRule = copyIris(sourceRule, targetRule, acl.defaultForNew);
  targetRule = copyIris(sourceRule, targetRule, acl.agent);
  targetRule = copyIris(sourceRule, targetRule, acl.agentGroup);
  targetRule = copyIris(sourceRule, targetRule, acl.agentClass);
  targetRule = copyIris(sourceRule, targetRule, acl.origin);
  targetRule = copyIris(sourceRule, targetRule, acl.mode);
  return targetRule;
}
function internal_setAcl(resource, acl2) {
  return Object.assign(internal_cloneResource(resource), { internal_acl: acl2 });
}
var supportedActorPredicates = [
  acl.agent,
  acl.agentClass,
  acl.agentGroup,
  acl.origin
];
function internal_removeActorFromRule(rule, actor, actorPredicate, resourceIri, ruleType) {
  if (!getIriAll(rule, actorPredicate).includes(actor)) {
    const emptyRule = internal_initialiseAclRule({
      read: false,
      append: false,
      write: false,
      control: false
    });
    return [rule, emptyRule];
  }
  const ruleWithoutActor = removeIri(rule, actorPredicate, actor);
  let ruleForOtherTargets = internal_duplicateAclRule(rule);
  ruleForOtherTargets = removeIri(ruleForOtherTargets, ruleType === "resource" ? acl.accessTo : acl.default, resourceIri);
  if (ruleType === "default") {
    ruleForOtherTargets = removeIri(ruleForOtherTargets, acl.defaultForNew, resourceIri);
  }
  ruleForOtherTargets = setIri(ruleForOtherTargets, actorPredicate, actor);
  supportedActorPredicates.filter((predicate) => predicate !== actorPredicate).forEach((predicate) => {
    ruleForOtherTargets = removeAll(ruleForOtherTargets, predicate);
  });
  return [ruleWithoutActor, ruleForOtherTargets];
}
function internal_setActorAccess(aclDataset, access, actorPredicate, accessType, actor) {
  let filteredAcl = aclDataset;
  getThingAll(aclDataset).forEach((aclRule) => {
    const [filteredRule, remainingRule] = internal_removeActorFromRule(aclRule, actor, actorPredicate, aclDataset.internal_accessTo, accessType);
    filteredAcl = setThing(filteredAcl, filteredRule);
    filteredAcl = setThing(filteredAcl, remainingRule);
  });
  let newRule = internal_initialiseAclRule(access);
  newRule = setIri(newRule, accessType === "resource" ? acl.accessTo : acl.default, aclDataset.internal_accessTo);
  newRule = setIri(newRule, actorPredicate, actor);
  const updatedAcl = setThing(filteredAcl, newRule);
  return internal_removeEmptyAclRules(updatedAcl);
}
function internal_setResourceAcl(resource, acl2) {
  const newAcl = {
    resourceAcl: acl2,
    fallbackAcl: null
  };
  return internal_setAcl(resource, newAcl);
}
function internal_getResourceAcl(resource) {
  return resource.internal_acl.resourceAcl;
}

class AclIsAcrError extends Error {
  constructor(sourceResource, aclResource) {
    super(`[${getSourceIri(sourceResource)}] is governed by Access Control Policies in [${getSourceIri(aclResource)}] rather than by Web Access Control.`);
  }
}

// node_modules/@inrupt/solid-client/dist/acl/acl.mjs
function hasResourceAcl(resource) {
  return resource.internal_acl.resourceAcl !== null && getSourceUrl(resource) === resource.internal_acl.resourceAcl.internal_accessTo && resource.internal_resourceInfo.aclUrl === getSourceUrl(resource.internal_acl.resourceAcl);
}
function getResourceAcl(resource) {
  if (!hasResourceAcl(resource)) {
    return null;
  }
  return resource.internal_acl.resourceAcl;
}
function hasFallbackAcl(resource) {
  return resource.internal_acl.fallbackAcl !== null;
}
function getFallbackAcl(dataset) {
  if (!hasFallbackAcl(dataset)) {
    return null;
  }
  return dataset.internal_acl.fallbackAcl;
}
function createAcl(targetResource) {
  const emptyResourceAcl = freeze({
    ...createSolidDataset(),
    internal_accessTo: getSourceUrl(targetResource),
    internal_resourceInfo: {
      sourceIri: targetResource.internal_resourceInfo.aclUrl,
      isRawData: false,
      linkedResources: {}
    }
  });
  return emptyResourceAcl;
}
function createAclFromFallbackAcl(resource) {
  const emptyResourceAcl = createAcl(resource);
  const fallbackAclRules = internal_getAclRules(resource.internal_acl.fallbackAcl);
  const defaultAclRules = internal_getDefaultAclRulesForResource(fallbackAclRules, resource.internal_acl.fallbackAcl.internal_accessTo);
  const newAclRules = defaultAclRules.map((rule) => {
    rule = removeAll(rule, acl.default);
    rule = removeAll(rule, acl.defaultForNew);
    rule = setIri(rule, acl.accessTo, getSourceUrl(resource));
    rule = setIri(rule, acl.default, getSourceUrl(resource));
    return rule;
  });
  const initialisedResourceAcl = newAclRules.reduce(setThing, emptyResourceAcl);
  return initialisedResourceAcl;
}
async function saveAclFor(resource, resourceAcl, options) {
  if (!hasAccessibleAcl(resource)) {
    throw new Error(`Could not determine the location of the ACL for the Resource at [${getSourceUrl(resource)}]; possibly the current user does not have Control access to that Resource. Try calling \`hasAccessibleAcl()\` before calling \`saveAclFor()\`.`);
  }
  const savedDataset = await saveSolidDatasetAt(resource.internal_resourceInfo.aclUrl, resourceAcl, options);
  const savedAclDataset = {
    ...savedDataset,
    internal_accessTo: getSourceUrl(resource)
  };
  return savedAclDataset;
}
function hasAccessibleAcl(dataset) {
  return typeof dataset.internal_resourceInfo.aclUrl === "string";
}

// node_modules/@inrupt/solid-client/dist/acl/agent.mjs
function getAgentAccess(resourceInfo, agent) {
  if (hasResourceAcl(resourceInfo)) {
    return getAgentResourceAccess(resourceInfo.internal_acl.resourceAcl, agent);
  }
  if (hasFallbackAcl(resourceInfo)) {
    return getAgentDefaultAccess(resourceInfo.internal_acl.fallbackAcl, agent);
  }
  return null;
}
function getAgentAccessAll(resourceInfo) {
  if (hasResourceAcl(resourceInfo)) {
    const resourceAcl = getResourceAcl(resourceInfo);
    return getAgentResourceAccessAll(resourceAcl);
  }
  if (hasFallbackAcl(resourceInfo)) {
    const fallbackAcl = getFallbackAcl(resourceInfo);
    return getAgentDefaultAccessAll(fallbackAcl);
  }
  return null;
}
function getAgentResourceAccess(aclDataset, agent) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getResourceAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const agentResourceRules = getAgentAclRulesForAgent(resourceRules, agent);
  const agentAccessModes = agentResourceRules.map(internal_getAccess);
  return internal_combineAccessModes(agentAccessModes);
}
function getAgentResourceAccessAll(aclDataset) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getResourceAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const agentResourceRules = getAgentAclRules(resourceRules);
  return getAccessByAgent(agentResourceRules);
}
function setAgentResourceAccess(aclDataset, agent, access) {
  return internal_setActorAccess(aclDataset, access, acl.agent, "resource", agent);
}
function getAgentDefaultAccess(aclDataset, agent) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getDefaultAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const agentResourceRules = getAgentAclRulesForAgent(resourceRules, agent);
  const agentAccessModes = agentResourceRules.map(internal_getAccess);
  return internal_combineAccessModes(agentAccessModes);
}
function getAgentDefaultAccessAll(aclDataset) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getDefaultAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const agentResourceRules = getAgentAclRules(resourceRules);
  return getAccessByAgent(agentResourceRules);
}
function getAgentAclRulesForAgent(aclRules, agent) {
  return internal_getAclRulesForIri(aclRules, agent, acl.agent);
}
function getAgentAclRules(aclRules) {
  return aclRules.filter(isAgentAclRule);
}
function isAgentAclRule(aclRule) {
  return getIri(aclRule, acl.agent) !== null;
}
function getAccessByAgent(aclRules) {
  return internal_getAccessByIri(aclRules, acl.agent);
}

// node_modules/@inrupt/solid-client/dist/acl/class.mjs
function getPublicAccess(resourceInfo) {
  if (hasResourceAcl(resourceInfo)) {
    return getPublicResourceAccess(resourceInfo.internal_acl.resourceAcl);
  }
  if (hasFallbackAcl(resourceInfo)) {
    return getPublicDefaultAccess(resourceInfo.internal_acl.fallbackAcl);
  }
  return null;
}
function getPublicResourceAccess(aclDataset) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getResourceAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const publicResourceRules = getClassAclRulesForClass(resourceRules, foaf.Agent);
  const publicAccessModes = publicResourceRules.map(internal_getAccess);
  return internal_combineAccessModes(publicAccessModes);
}
function getPublicDefaultAccess(aclDataset) {
  const allRules = internal_getAclRules(aclDataset);
  const resourceRules = internal_getDefaultAclRulesForResource(allRules, aclDataset.internal_accessTo);
  const publicResourceRules = getClassAclRulesForClass(resourceRules, foaf.Agent);
  const publicAccessModes = publicResourceRules.map(internal_getAccess);
  return internal_combineAccessModes(publicAccessModes);
}
function setPublicResourceAccess(aclDataset, access) {
  return internal_setActorAccess(aclDataset, access, acl.agentClass, "resource", foaf.Agent);
}
function getClassAclRulesForClass(aclRules, agentClass) {
  return aclRules.filter((rule) => appliesToClass(rule, agentClass));
}
function appliesToClass(aclRule, agentClass) {
  return getIriAll(aclRule, acl.agentClass).includes(agentClass);
}

// node_modules/@inrupt/solid-client/dist/universal/index.mjs
var exports_universal = {};
__export(exports_universal, {
  setPublicAccess: () => setPublicAccess2,
  setAgentAccess: () => setAgentAccess2,
  getPublicAccess: () => getPublicAccess4,
  getAgentAccessAll: () => getAgentAccessAll4,
  getAgentAccess: () => getAgentAccess4,
  getAclServerResourceInfo: () => getAclServerResourceInfo
});

// node_modules/@inrupt/solid-client/dist/universal/getAclServerResourceInfo.mjs
async function getAclServerResourceInfo(resource, options) {
  if (typeof resource.internal_resourceInfo.aclUrl !== "string") {
    return null;
  }
  try {
    return await getResourceInfo(resource.internal_resourceInfo.aclUrl, options);
  } catch (_a) {
    return null;
  }
}
// node_modules/@inrupt/solid-client/dist/acp/constants.mjs
var ACP_NAMESPACE = "http://www.w3.org/ns/solid/acp#";
var ACP = {
  AccessControl: ACP_NAMESPACE.concat("AccessControl"),
  AccessControlResource: ACP_NAMESPACE.concat("AccessControlResource"),
  AuthenticatedAgent: ACP_NAMESPACE.concat("AuthenticatedAgent"),
  CreatorAgent: ACP_NAMESPACE.concat("CreatorAgent"),
  Matcher: ACP_NAMESPACE.concat("Matcher"),
  Policy: ACP_NAMESPACE.concat("Policy"),
  PublicAgent: ACP_NAMESPACE.concat("PublicAgent"),
  access: ACP_NAMESPACE.concat("access"),
  accessControl: ACP_NAMESPACE.concat("accessControl"),
  agent: ACP_NAMESPACE.concat("agent"),
  allOf: ACP_NAMESPACE.concat("allOf"),
  allow: ACP_NAMESPACE.concat("allow"),
  anyOf: ACP_NAMESPACE.concat("anyOf"),
  apply: ACP_NAMESPACE.concat("apply"),
  client: ACP_NAMESPACE.concat("client"),
  deny: ACP_NAMESPACE.concat("deny"),
  memberAccessControl: ACP_NAMESPACE.concat("memberAccessControl"),
  noneOf: ACP_NAMESPACE.concat("noneOf"),
  vc: ACP_NAMESPACE.concat("vc")
};
var ACL_NAMESPACE = "http://www.w3.org/ns/auth/acl#";
var ACL = {
  Append: ACL_NAMESPACE.concat("Append"),
  Control: ACL_NAMESPACE.concat("Control"),
  Read: ACL_NAMESPACE.concat("Read"),
  Write: ACL_NAMESPACE.concat("Write")
};

// node_modules/@inrupt/solid-client/dist/acp/acp.mjs
var import_http_link_header2 = __toESM(require_link(), 1);
async function saveAcrFor(resource, options) {
  const acr = internal_getAcr(resource);
  const savedAcr = await saveSolidDatasetAt(getSourceUrl(acr), acr, options);
  return internal_setAcr(resource, savedAcr);
}
function hasAccessibleAcr(resource) {
  return typeof resource.internal_acp === "object" && resource.internal_acp !== null && typeof resource.internal_acp.acr === "object" && resource.internal_acp.acr !== null;
}

// node_modules/@inrupt/solid-client/dist/acp/control.internal.mjs
function internal_getAcr(resource) {
  if (!hasAccessibleAcr(resource)) {
    throw new Error(`An Access Control Resource for [${getSourceUrl(resource)}] is not available. This could be because the current user is not allowed to see it, or because their Pod Server does not support Access Control Resources.`);
  }
  return resource.internal_acp.acr;
}
function internal_setAcr(resource, acr) {
  return Object.assign(internal_cloneResource(resource), {
    internal_acp: {
      ...resource.internal_acp,
      acr
    }
  });
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getAccessControlResourceThing.mjs
function getAccessControlResourceThing(resource) {
  const acr = internal_getAcr(resource);
  const acrUrl = getSourceUrl(acr);
  return getThing(acr, acrUrl);
}

// node_modules/@inrupt/solid-client/dist/acp/accessControl/getAccessControlUrlAll.mjs
function getAccessControlUrlAll(resourceWithAcr) {
  const acrThing = getAccessControlResourceThing(resourceWithAcr);
  if (acrThing === null) {
    return [];
  }
  return getIriAll(acrThing, ACP.accessControl);
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getPolicyUrls.mjs
function getPolicyUrls(resource, accessControlUrls, type) {
  const acr = internal_getAcr(resource);
  return Array.from(new Set(accessControlUrls.map((accessControlUrl) => {
    const accessControlThing = getThing(acr, accessControlUrl);
    if (accessControlThing !== null) {
      return getIriAll(accessControlThing, type);
    }
    return [];
  }).reduce((previousValue, currentValue) => previousValue.concat(currentValue), [])));
}

// node_modules/@inrupt/solid-client/dist/acp/policy/getPolicyUrlAll.mjs
function getPolicyUrlAll(resourceWithAcr) {
  return getPolicyUrls(resourceWithAcr, getAccessControlUrlAll(resourceWithAcr), ACP.apply);
}

// node_modules/@inrupt/solid-client/dist/acp/util/getAgentAccess.mjs
var import_http_link_header3 = __toESM(require_link(), 1);

// node_modules/@inrupt/solid-client/dist/acp/policy/getAcrPolicyUrlAll.mjs
function getAcrPolicyUrlAll(resourceWithAcr) {
  return getPolicyUrls(resourceWithAcr, getAccessControlUrlAll(resourceWithAcr), ACP.access);
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getModes.mjs
function getModes(policy, type) {
  const modes = getIriAll(policy, type);
  return {
    read: modes.includes(ACL.Read),
    append: modes.includes(ACL.Append),
    write: modes.includes(ACL.Write),
    controlRead: false,
    controlWrite: false
  };
}

// node_modules/@inrupt/solid-client/dist/acp/policy/getAllowModes.mjs
function getAllowModes(policy) {
  return getModes(policy, ACP.allow);
}

// node_modules/@inrupt/solid-client/dist/acp/policy/getDenyModes.mjs
function getDenyModes(policy) {
  return getModes(policy, ACP.deny);
}

// node_modules/@inrupt/solid-client/dist/acp/util/getAgentAccess.mjs
function isAgentMatched(acr, policy, webId) {
  const allOfMatchers = getUrlAll(policy, ACP.allOf).map((url) => getThing(internal_getAcr(acr), url)).filter((thing) => thing !== null);
  const allOfMatched = allOfMatchers.every((thing) => {
    return getUrlAll(thing, ACP.agent).includes(webId);
  });
  const anyOfMatchers = getUrlAll(policy, ACP.anyOf).map((url) => getThing(internal_getAcr(acr), url)).filter((thing) => thing !== null);
  const anyOfMatched = anyOfMatchers.some((thing) => {
    return getUrlAll(thing, ACP.agent).includes(webId);
  });
  const noneOfMatchers = getUrlAll(policy, ACP.noneOf).map((url) => getThing(internal_getAcr(acr), url)).filter((thing) => thing !== null);
  const noneOfMatched = noneOfMatchers.some((thing) => {
    return getUrlAll(thing, ACP.agent).includes(webId);
  });
  return allOfMatchers.length + anyOfMatchers.length > 0 && (allOfMatchers.length === 0 || allOfMatched) && (anyOfMatchers.length === 0 || anyOfMatched) && (noneOfMatchers.length === 0 || !noneOfMatched);
}
function reduceModes(policy, modes, type) {
  const allowed = getAllowModes(policy);
  const denied = getDenyModes(policy);
  if (type === "control") {
    return {
      read: modes.read,
      append: modes.append,
      write: modes.write,
      controlRead: (modes.controlRead || allowed.read) && !denied.read,
      controlWrite: (modes.controlWrite || allowed.write) && !denied.write
    };
  }
  return {
    read: (modes.read || allowed.read) && !denied.read,
    append: (modes.append || allowed.append) && !denied.append,
    write: (modes.write || allowed.write) && !denied.write,
    controlRead: modes.controlRead,
    controlWrite: modes.controlWrite
  };
}
async function getAgentAccess2(resourceWithAcr, webId) {
  let resourceAccess = {
    read: false,
    append: false,
    write: false,
    controlRead: false,
    controlWrite: false
  };
  const policyAll = getPolicyUrlAll(resourceWithAcr).map((url) => getThing(internal_getAcr(resourceWithAcr), url)).filter((policy) => policy !== null);
  policyAll.forEach((policy) => {
    if (isAgentMatched(resourceWithAcr, policy, webId)) {
      resourceAccess = reduceModes(policy, resourceAccess, "resource");
    }
  });
  const acrPolicyAll = getAcrPolicyUrlAll(resourceWithAcr).map((url) => getThing(internal_getAcr(resourceWithAcr), url)).filter((policy) => policy !== null);
  acrPolicyAll.forEach((policy) => {
    if (isAgentMatched(resourceWithAcr, policy, webId)) {
      resourceAccess = reduceModes(policy, resourceAccess, "control");
    }
  });
  return resourceAccess;
}

// node_modules/@inrupt/solid-client/dist/access/wac.mjs
function universalAccessToAcl(newAccess, previousAccess) {
  var _a, _b, _c, _d2;
  if (newAccess.controlRead !== newAccess.controlWrite) {
    throw new Error("For Pods using Web Access Control, controlRead and controlWrite must be equal.");
  }
  return {
    read: (_a = newAccess.read) !== null && _a !== undefined ? _a : previousAccess.read,
    append: (_b = newAccess.append) !== null && _b !== undefined ? _b : previousAccess.append,
    write: (_c = newAccess.write) !== null && _c !== undefined ? _c : previousAccess.write,
    control: (_d2 = newAccess.controlRead) !== null && _d2 !== undefined ? _d2 : previousAccess.control
  };
}
function aclAccessToUniversal(access) {
  return {
    read: access.read,
    write: access.write,
    append: access.append,
    controlRead: access.control,
    controlWrite: access.control
  };
}
async function getActorAccess(resource, actor, accessEvaluationCallback, options) {
  const resourceAcl = await internal_fetchAcl(resource, options);
  const wacAccess = accessEvaluationCallback(internal_setAcl(resource, resourceAcl), actor);
  if (wacAccess === null) {
    return null;
  }
  return aclAccessToUniversal(wacAccess);
}
async function getActorClassAccess(resource, accessEvaluationCallback, options) {
  const resourceAcl = await internal_fetchAcl(resource, options);
  const wacAccess = accessEvaluationCallback(internal_setAcl(resource, resourceAcl));
  if (wacAccess === null) {
    return null;
  }
  return aclAccessToUniversal(wacAccess);
}
async function getActorAccessAll(resource, accessEvaluationCallback, options) {
  const resourceAcl = await internal_fetchAcl(resource, options);
  const wacAgentAccess = accessEvaluationCallback(internal_setAcl(resource, resourceAcl));
  if (wacAgentAccess === null) {
    return null;
  }
  const result = {};
  for (const [webId, wacAccess] of Object.entries(wacAgentAccess)) {
    result[webId] = aclAccessToUniversal(wacAccess);
  }
  return result;
}
function getAgentAccess3(resource, agent, options) {
  return getActorAccess(resource, agent, getAgentAccess, options);
}
function getPublicAccess2(resource, options) {
  return getActorClassAccess(resource, getPublicAccess, options);
}
function getAgentAccessAll2(resource, options) {
  return getActorAccessAll(resource, getAgentAccessAll, options);
}
async function prepareResourceAcl(resource, options) {
  if (!hasAccessibleAcl(resource)) {
    return null;
  }
  const acl2 = await internal_fetchAcl(resource, options);
  const resourceWithAcl = internal_setAcl(resource, acl2);
  let resourceAcl;
  if (hasResourceAcl(resourceWithAcl)) {
    resourceAcl = internal_getResourceAcl(resourceWithAcl);
  } else if (hasFallbackAcl(resourceWithAcl)) {
    resourceAcl = createAclFromFallbackAcl(resourceWithAcl);
  } else {
    return null;
  }
  return internal_setResourceAcl(resourceWithAcl, resourceAcl);
}
async function saveUpdatedAcl(resource, acl2, options) {
  let savedAcl = null;
  try {
    savedAcl = await saveAclFor(resource, acl2, options);
    return internal_setResourceAcl(resource, savedAcl);
  } catch (e) {
    return null;
  }
}
async function setActorClassAccess(resource, access, getAccess, setAccess, options) {
  const resourceWithOldAcl = await prepareResourceAcl(resource, options);
  if (resourceWithOldAcl === null) {
    return null;
  }
  const resourceAcl = getResourceAcl(resourceWithOldAcl);
  const currentAccess = getAccess(resourceWithOldAcl);
  const wacAccess = universalAccessToAcl(access, currentAccess);
  const updatedResourceAcl = setAccess(resourceAcl, wacAccess);
  return saveUpdatedAcl(resourceWithOldAcl, updatedResourceAcl, options);
}
async function setActorAccess(resource, actor, access, getAccess, setAccess, options) {
  const resourceWithOldAcl = await prepareResourceAcl(resource, options);
  if (resourceWithOldAcl === null) {
    return null;
  }
  const currentAccess = getAccess(resourceWithOldAcl, actor);
  const resourceAcl = getResourceAcl(resourceWithOldAcl);
  const wacAccess = universalAccessToAcl(access, currentAccess);
  const updatedResourceAcl = setAccess(resourceAcl, actor, wacAccess);
  return saveUpdatedAcl(resourceWithOldAcl, updatedResourceAcl, options);
}
async function setAgentResourceAccess2(resource, agent, access, options) {
  return setActorAccess(resource, agent, access, getAgentAccess, setAgentResourceAccess, options);
}
async function setPublicResourceAccess2(resource, access, options) {
  return setActorClassAccess(resource, access, getPublicAccess, setPublicResourceAccess, options);
}

// node_modules/@inrupt/solid-client/dist/acp/util/getAcrUrl.mjs
async function getAcrUrl(resource, options) {
  const aclServerResourceInfo = await getAclServerResourceInfo(resource, options);
  if (aclServerResourceInfo === null) {
    return null;
  }
  const relTypeLinks = getLinkedResourceUrlAll(aclServerResourceInfo).type;
  if (Array.isArray(relTypeLinks) && relTypeLinks.includes(ACP.AccessControlResource)) {
    return getSourceUrl(aclServerResourceInfo);
  }
  return null;
}

// node_modules/@inrupt/solid-client/dist/acp/util/getResourceAcr.mjs
async function getResourceAcr(resource, options) {
  const acrUrl = await getAcrUrl(resource, options);
  if (acrUrl === null) {
    return null;
  }
  let acr;
  try {
    acr = await getSolidDataset(acrUrl, options);
  } catch (e) {
    return null;
  }
  return {
    ...resource,
    internal_acp: {
      acr: {
        ...acr,
        accessTo: getSourceUrl(resource)
      }
    }
  };
}

// node_modules/@inrupt/solid-client/dist/universal/getAgentAccess.mjs
async function getAgentAccess4(resourceUrl, webId, options) {
  const resourceInfo = await getResourceInfo(resourceUrl, options);
  const acr = await getResourceAcr(resourceInfo, options);
  if (acr === null) {
    return getAgentAccess3(resourceInfo, webId, options);
  }
  return getAgentAccess2(acr, webId);
}
// node_modules/@inrupt/solid-client/dist/acp/util/getAgentUrlAll.mjs
var import_http_link_header4 = __toESM(require_link(), 1);
function getAgentUrlAll(acr) {
  return Array.from(new Set(getThingAll(internal_getAcr(acr)).map((thing) => {
    return getUrlAll(thing, ACP.agent);
  }).reduce((flatArray, agentArray) => {
    return flatArray.concat(agentArray);
  }, [])));
}

// node_modules/@inrupt/solid-client/dist/acp/util/getAgentAccessAll.mjs
async function getAgentAccessAll3(resourceWithAcr) {
  return (await Promise.all(getAgentUrlAll(resourceWithAcr).map(async (agent) => ({
    [agent]: await getAgentAccess2(resourceWithAcr, agent)
  })))).reduce((agentAccessAll, currentAgentAccess) => ({
    ...agentAccessAll,
    ...currentAgentAccess
  }), {});
}

// node_modules/@inrupt/solid-client/dist/universal/getAgentAccessAll.mjs
async function getAgentAccessAll4(resourceUrl, options) {
  const resourceInfo = await getResourceInfo(resourceUrl, options);
  const acr = await getResourceAcr(resourceInfo, options);
  if (acr === null) {
    return getAgentAccessAll2(resourceInfo, options);
  }
  return getAgentAccessAll3(acr);
}
// node_modules/@inrupt/solid-client/dist/acp/util/getPublicAccess.mjs
async function getPublicAccess3(resourceWithAcr) {
  return getAgentAccess2(resourceWithAcr, ACP.PublicAgent);
}

// node_modules/@inrupt/solid-client/dist/universal/getPublicAccess.mjs
async function getPublicAccess4(resourceUrl, options) {
  const resourceInfo = await getResourceInfo(resourceUrl, options);
  const acr = await getResourceAcr(resourceInfo, options);
  if (acr === null) {
    return getPublicAccess2(resourceInfo, options);
  }
  return getPublicAccess3(acr);
}
// node_modules/@inrupt/solid-client/dist/acp/util/setAgentAccess.mjs
var import_http_link_header9 = __toESM(require_link(), 1);

// node_modules/@inrupt/solid-client/dist/acp/internal/setDefaultAgentMatcherPolicyMatcherThingIfNotExist.mjs
var import_http_link_header8 = __toESM(require_link(), 1);

// node_modules/@inrupt/solid-client/dist/acp/internal/setAccessControlResourceThing.mjs
function setAccessControlResourceThing(resource, thing) {
  return Object.assign(internal_cloneResource(resource), {
    internal_acp: {
      ...resource.internal_acp,
      acr: setThing(resource.internal_acp.acr, thing)
    }
  });
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getDefaultAccessControlUrl.mjs
var import_http_link_header5 = __toESM(require_link(), 1);
var DEFAULT_ACCESS_CONTROL = "defaultAccessControl";
var DEFAULT_ACR_ACCESS_CONTROL = "defaultAcrAccessControl";
function getDefaultAccessControlUrl(resource, name2) {
  const acr = internal_getAcr(resource);
  const acrUrl = getSourceUrl(acr);
  return acrUrl.concat("#").concat(name2);
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getDefaultAgentMatcherPolicyUrl.mjs
function getDefaultAgentMatcherPolicyUrl(resource, name2, mode) {
  return getDefaultAccessControlUrl(resource, name2).concat("AgentMatcher").concat(mode.charAt(0).toUpperCase() + mode.slice(1)).concat("Policy");
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getDefaultAccessControlThing.mjs
var import_http_link_header6 = __toESM(require_link(), 1);
function getDefaultAccessControlThing(resource, name2) {
  const acr = internal_getAcr(resource);
  const defaultAccessControlUrl = getDefaultAccessControlUrl(resource, name2);
  const accessControlThing = getThing(acr, defaultAccessControlUrl);
  if (accessControlThing === null || typeof accessControlThing === "undefined") {
    return createThing({ url: defaultAccessControlUrl });
  }
  return accessControlThing;
}

// node_modules/@inrupt/solid-client/dist/acp/internal/setDefaultAccessControlThingIfNotExist.mjs
var import_http_link_header7 = __toESM(require_link(), 1);
function getAccessControlTypeFromDefaultAccessControlName(name2) {
  if (name2.includes("Member")) {
    return ACP.memberAccessControl;
  }
  return ACP.accessControl;
}
function setDefaultAccessControlThingIfNotExist(resource, name2) {
  const defaultAccessControlThingUrl = getDefaultAccessControlUrl(resource, name2);
  const acr = internal_getAcr(resource);
  let accessControlResourceThing = getAccessControlResourceThing(resource);
  if (accessControlResourceThing === null || typeof accessControlResourceThing === "undefined") {
    accessControlResourceThing = createThing({ url: getSourceUrl(acr) });
  }
  const accessControlUrlAll = getIriAll(accessControlResourceThing, getAccessControlTypeFromDefaultAccessControlName(name2));
  if (!accessControlUrlAll.includes(defaultAccessControlThingUrl)) {
    accessControlResourceThing = buildThing(accessControlResourceThing).addUrl(getAccessControlTypeFromDefaultAccessControlName(name2), defaultAccessControlThingUrl).build();
    return setAccessControlResourceThing(resource, accessControlResourceThing);
  }
  return resource;
}

// node_modules/@inrupt/solid-client/dist/acp/policy/addAcrPolicyUrl.mjs
function addAcrPolicyUrl(resourceWithAcr, policyUrl) {
  const resourceWithAcrContainingDefaultAccessControl = setDefaultAccessControlThingIfNotExist(resourceWithAcr, DEFAULT_ACR_ACCESS_CONTROL);
  const defaultAccessControlThing = getDefaultAccessControlThing(resourceWithAcrContainingDefaultAccessControl, DEFAULT_ACR_ACCESS_CONTROL);
  return setAccessControlResourceThing(resourceWithAcrContainingDefaultAccessControl, buildThing(defaultAccessControlThing).addUrl(ACP.access, policyUrl).build());
}

// node_modules/@inrupt/solid-client/dist/acp/policy/addPolicyUrl.mjs
function addPolicyUrl(resourceWithAcr, policyUrl) {
  const resourceWithAcrContainingDefaultAccessControl = setDefaultAccessControlThingIfNotExist(resourceWithAcr, DEFAULT_ACCESS_CONTROL);
  const defaultAccessControlThing = getDefaultAccessControlThing(resourceWithAcrContainingDefaultAccessControl, DEFAULT_ACCESS_CONTROL);
  return setAccessControlResourceThing(resourceWithAcrContainingDefaultAccessControl, buildThing(defaultAccessControlThing).addUrl(ACP.apply, policyUrl).build());
}

// node_modules/@inrupt/solid-client/dist/acp/internal/setDefaultAgentMatcherPolicyThingIfNotExist.mjs
function setDefaultAgentMatcherPolicyThingIfNotExist(resource, name2, mode) {
  const policyUrl = getDefaultAgentMatcherPolicyUrl(resource, name2, mode);
  if (policyUrl.includes("Acr")) {
    return addAcrPolicyUrl(resource, policyUrl);
  }
  return addPolicyUrl(resource, policyUrl);
}

// node_modules/@inrupt/solid-client/dist/acp/internal/getDefaultAgentMatcherPolicyMatcherUrl.mjs
function getDefaultAgentMatcherPolicyMatcherUrl(resource, name2, mode) {
  return getDefaultAgentMatcherPolicyUrl(resource, name2, mode).concat("Matcher");
}

// node_modules/@inrupt/solid-client/dist/acp/internal/setModes.mjs
function setModes(policy, modes, type) {
  let newPolicy = removeAll(policy, type);
  if (modes.read || modes.controlRead) {
    newPolicy = addIri(newPolicy, type, ACL.Read);
  }
  if (modes.append) {
    newPolicy = addIri(newPolicy, type, ACL.Append);
  }
  if (modes.write || modes.controlWrite) {
    newPolicy = addIri(newPolicy, type, ACL.Write);
  }
  return newPolicy;
}

// node_modules/@inrupt/solid-client/dist/acp/internal/setDefaultAgentMatcherPolicyMatcherThingIfNotExist.mjs
var DEFAULT_POLICY_MATCHER_PREDICATE = ACP.anyOf;
function setDefaultAgentMatcherPolicyMatcherThingIfNotExist(resource, name2, mode) {
  const policyUrl = getDefaultAgentMatcherPolicyUrl(resource, name2, mode);
  const matcherUrl = getDefaultAgentMatcherPolicyMatcherUrl(resource, name2, mode);
  let defaultAgentMatcherPolicyThing = getThing(internal_getAcr(resource), policyUrl);
  if (!defaultAgentMatcherPolicyThing) {
    resource = setDefaultAgentMatcherPolicyThingIfNotExist(resource, name2, mode);
    defaultAgentMatcherPolicyThing = createThing({ url: policyUrl });
    defaultAgentMatcherPolicyThing = setModes(defaultAgentMatcherPolicyThing, { [mode]: true }, ACP.allow);
  }
  const agentMatcherPolicyUrlAll = getIriAll(defaultAgentMatcherPolicyThing, DEFAULT_POLICY_MATCHER_PREDICATE);
  if (!agentMatcherPolicyUrlAll.includes(matcherUrl)) {
    defaultAgentMatcherPolicyThing = buildThing(defaultAgentMatcherPolicyThing).addUrl(DEFAULT_POLICY_MATCHER_PREDICATE, matcherUrl).build();
    return setAccessControlResourceThing(resource, defaultAgentMatcherPolicyThing);
  }
  return resource;
}

// node_modules/@inrupt/solid-client/dist/acp/matcher.mjs
function addAgent(matcher, agent) {
  return addIri(matcher, acp.agent, agent);
}
function removeAgent(matcher, agent) {
  return removeIri(matcher, acp.agent, agent);
}

// node_modules/@inrupt/solid-client/dist/acp/util/setAgentAccess.mjs
function setAgentAccessMode(resourceWithAcr, webId, name2, mode, operation) {
  var _a;
  const matcherUrl = getDefaultAgentMatcherPolicyMatcherUrl(resourceWithAcr, name2, mode);
  const resourceWithDefaultAgentMatcher = setDefaultAgentMatcherPolicyMatcherThingIfNotExist(resourceWithAcr, name2, mode);
  const defaultAgentMatcherThing = (_a = getThing(internal_getAcr(resourceWithDefaultAgentMatcher), matcherUrl)) !== null && _a !== undefined ? _a : createThing({ url: matcherUrl });
  return setAccessControlResourceThing(resourceWithDefaultAgentMatcher, operation === "add" ? addAgent(defaultAgentMatcherThing, webId) : removeAgent(defaultAgentMatcherThing, webId));
}
async function setAgentAccess(resourceWithAcr, webId, access) {
  const agentAccessModes = await getAgentAccess2(resourceWithAcr, webId);
  if (typeof access.read === "boolean" && agentAccessModes.read !== access.read) {
    resourceWithAcr = setAgentAccessMode(resourceWithAcr, webId, DEFAULT_ACCESS_CONTROL, "read", access.read ? "add" : "remove");
  }
  if (typeof access.append === "boolean" && agentAccessModes.append !== access.append) {
    resourceWithAcr = setAgentAccessMode(resourceWithAcr, webId, DEFAULT_ACCESS_CONTROL, "append", access.append ? "add" : "remove");
  }
  if (typeof access.write === "boolean" && agentAccessModes.write !== access.write) {
    resourceWithAcr = setAgentAccessMode(resourceWithAcr, webId, DEFAULT_ACCESS_CONTROL, "write", access.write ? "add" : "remove");
  }
  if (typeof access.controlRead === "boolean" && agentAccessModes.controlRead !== access.controlRead) {
    resourceWithAcr = setAgentAccessMode(resourceWithAcr, webId, DEFAULT_ACR_ACCESS_CONTROL, "controlRead", access.controlRead ? "add" : "remove");
  }
  if (typeof access.controlWrite === "boolean" && agentAccessModes.controlWrite !== access.controlWrite) {
    resourceWithAcr = setAgentAccessMode(resourceWithAcr, webId, DEFAULT_ACR_ACCESS_CONTROL, "controlWrite", access.controlWrite ? "add" : "remove");
  }
  return resourceWithAcr;
}

// node_modules/@inrupt/solid-client/dist/universal/setAgentAccess.mjs
async function setAgentAccess2(resourceUrl, webId, access, options) {
  const resourceInfo = await getResourceInfo(resourceUrl, options);
  const acr = await getResourceAcr(resourceInfo, options);
  if (acr === null) {
    await setAgentResourceAccess2(resourceInfo, webId, access, options);
    return getAgentAccess3(resourceInfo, webId, options);
  }
  try {
    await saveAcrFor(await setAgentAccess(acr, webId, access), options);
    return await getAgentAccess4(resourceUrl, webId, options);
  } catch (e) {
    return null;
  }
}
// node_modules/@inrupt/solid-client/dist/acp/util/setPublicAccess.mjs
async function setPublicAccess(resourceWithAcr, access) {
  return setAgentAccess(resourceWithAcr, ACP.PublicAgent, access);
}

// node_modules/@inrupt/solid-client/dist/universal/setPublicAccess.mjs
async function setPublicAccess2(resourceUrl, access, options) {
  const resourceInfo = await getResourceInfo(resourceUrl, options);
  const acr = await getResourceAcr(resourceInfo, options);
  if (acr === null) {
    await setPublicResourceAccess2(resourceInfo, access, options);
    return getPublicAccess2(resourceInfo, options);
  }
  try {
    await saveAcrFor(await setPublicAccess(acr, access), options);
    return await getPublicAccess4(resourceUrl, options);
  } catch (e) {
    return null;
  }
}
// src/controller/index.ts
var { contexts: credentialsContexts, constants: { CREDENTIALS_CONTEXT_V1_URL } } = context$1;
var { purposes: { AssertionProofPurpose } } = import_jsonld_signatures2.default;
function isVC(o2) {
  let valid = false;
  let validationError = undefined;
  try {
    if (!o2.type) {
      throw new Error('"type" property is required.');
    }
    if (!o2.credentialSubject) {
      throw new Error('"credentialSubject" property is required.');
    }
    if (!o2.issuer) {
      throw new Error('"issuer" property is required.');
    }
    valid = true;
  } catch (error) {
    validationError = error.toString();
  } finally {
    return { valid, validationError };
  }
}
function createSignSuite(key) {
  return new DataIntegrityProof({
    signer: key.signer(),
    cryptosuite
  });
}
function createVerifySuite() {
  return new DataIntegrityProof({
    cryptosuite
  });
}
async function sign4(params) {
  const { documentLoader, key, credential } = params;
  const suite = createSignSuite(key);
  const signedCredential = await import_jsonld_signatures2.default.sign(credential, {
    suite,
    purpose: new AssertionProofPurpose,
    documentLoader
  });
  return signedCredential;
}
async function verify3(params) {
  const { credential, documentLoader } = params;
  const validationResult = isVC(credential);
  const suite = createVerifySuite();
  const verifyParams = {
    suite,
    purpose: new AssertionProofPurpose,
    documentLoader
  };
  const verificationResult = await import_jsonld_signatures2.default.verify(credential, verifyParams);
  return {
    validationResult,
    verificationResult
  };
}
function createCredential(k, credentialSubject) {
  return {
    "@context": [CREDENTIALS_CONTEXT_V1_URL],
    type: ["VerifiableCredential"],
    issuer: k.controller,
    issuanceDate: getCurrentDateTime(),
    credentialSubject
  };
}
function getKeypairUrl(webId) {
  return webId.replace("/profile/card#me", "/keypair");
}
function getKeyControllerDocumentUrl(webId) {
  return webId.replace("/card#me", "/key");
}
function getCardUrl(webId) {
  return webId.replace("#me", "");
}
async function storeKeypairOnSolidPod(key, webId, authFetch) {
  const privateExport = await exportKeypair(key, { publicKey: true, secretKey: true, includeContext: true });
  const urlKeypair = getKeypairUrl(webId);
  let response = await authFetch(urlKeypair, {
    method: "PUT",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(privateExport)
  });
  if (!response.ok)
    throw new Error("Failed to upload keypair!");
}
async function fetchKeypairFromSolidPod(webId, authFetch) {
  const urlKeypair = getKeypairUrl(webId);
  const response = await authFetch(urlKeypair);
  let kpResource = await response.json();
  const kp = await from(kpResource);
  return kp;
}
async function createKey(webId, password) {
  const keyId = getKeyControllerDocumentUrl(webId);
  let seed = new Uint8Array(32);
  seed = Buffer.alloc(32, Uint8Array.from(Buffer.from(password)));
  const k = await generate({
    seed,
    id: keyId,
    controller: webId
  });
  return k;
}
function preloadDocumentLoaderContexts(jdl) {
  jdl.addStatic(CREDENTIALS_CONTEXT_V1_URL, credentialsContexts.get(CREDENTIALS_CONTEXT_V1_URL));
  jdl.addStatic(import_data_integrity_context.default.constants.CONTEXT_URL, import_data_integrity_context.default.contexts.get(import_data_integrity_context.default.constants.CONTEXT_URL));
}
function createControllerDocument(k, embedVerificationMethod = false) {
  const vm = embedVerificationMethod ? k : k.id;
  const controllerDocumentObject = {
    "@context": [
      "https://www.w3.org/ns/did/v1"
    ],
    id: k.controller,
    verificationMethod: [
      vm
    ],
    assertionMethod: [
      k.id
    ]
  };
  const controllerDocumentAsNQuadString = `
<${k.controller}> <https://w3id.org/security#assertionMethod> <${k.id}> .
<${k.controller}> <https://w3id.org/security#verificationMethod> <${vm}> .
`;
  return { controllerDocumentObject, controllerDocumentAsNQuadString };
}
var addControllerDocumentToCard = async function(authFetch, webId, controllerDoc) {
  const patchInsert = controllerDoc.controllerDocumentAsNQuadString;
  const url = getCardUrl(webId);
  await n3patch(url, authFetch, undefined, patchInsert);
};
async function addFileToContainer(authFetch, urlContainer, data, mimeType = "application/ld+json", slug, publicAccess) {
  const file = new Blob([data]);
  const fileUrl = new URL(slug, urlContainer).toString();
  await overwriteFile(fileUrl, file, { contentType: mimeType, fetch: authFetch });
  const serverResourceInformation = await getResourceInfo(fileUrl, { fetch: authFetch });
  if (publicAccess) {
    await exports_universal.setPublicAccess(serverResourceInformation.internal_resourceInfo.sourceIri, publicAccess, { fetch: authFetch });
  }
  return serverResourceInformation.internal_resourceInfo.sourceIri;
}
async function exportKeypair(key, params) {
  return await key.export(params);
}
async function n3patch(url, authFetch, where, inserts, deletes, prefixes2) {
  const clauses = [
    where ? `solid:where { ${where} }` : where,
    inserts ? `solid:inserts { ${inserts} }` : inserts,
    deletes ? `solid:deletes { ${deletes} }` : deletes
  ].filter((c) => c).join(`;
`);
  const n3Patch = `
        @prefix solid: <http://www.w3.org/ns/solid/terms#>.
        ${prefixes2 ? Object.entries(prefixes2).map(([p2, ns]) => `@prefix ${p2}: <${ns}> .`).join(`
`) : ""}
        
        _:rename a solid:InsertDeletePatch;
            ${clauses}
        .
        `;
  const response = await authFetch(url, {
    method: "PATCH",
    headers: {
      "content-type": "text/n3"
    },
    body: n3Patch
  });
  const { ok, status, statusText } = response;
  if (!ok)
    throw new Error(`
            N3 Patch failed.
            Url: ${url}
            Status: ${status} - ${statusText}
            N3 Patch:
${n3Patch}
            `);
}

// src/vcCore.ts
var jdl = new JsonLdDocumentLoader;
preloadDocumentLoaderContexts(jdl);
async function coreSetup(email, password, css, webId, options) {
  const key = await createKey(webId, password);
  const authFetch = options?.authFetch || await getAuthenticatedFetch(email, password, css, webId);
  await storeKeypairOnSolidPod(key, webId, authFetch);
  const publicKeyExport = await exportKeypair(key, { publicKey: true, includeContext: true });
  await addFileToContainer(authFetch, getKeyControllerDocumentUrl(webId), Buffer.from(JSON.stringify(publicKeyExport, null, 2)), "application/json", "key", { append: false, controlRead: false, controlWrite: false, write: false, read: true });
  const controllerDoc = createControllerDocument(publicKeyExport);
  await addControllerDocumentToCard(authFetch, webId, controllerDoc);
}
async function coreIssue(email, password, css, webId, contentType, data, options) {
  let parsedData = await parseToJsonLD(data, contentType);
  const authFetch = options?.authFetch || await getAuthenticatedFetch(email, password, css, webId);
  const kp = await fetchKeypairFromSolidPod(webId, authFetch);
  const credentialSubject = parsedData;
  const credential = createCredential(kp, credentialSubject);
  const signedCredential = await sign4({
    key: kp,
    credential,
    documentLoader: createDocumentLoader(jdl)
  });
  return { contentType: "application/ld+json", signedCredentialText: JSON.stringify(signedCredential) };
}
async function coreVerify(verifiableCredential) {
  const documentLoader = createDocumentLoader(jdl);
  const { validationResult, verificationResult } = await verify3({
    credential: verifiableCredential,
    documentLoader
  });
  return { validationResult, verificationResult };
}
export {
  coreVerify,
  coreSetup,
  coreIssue
};
